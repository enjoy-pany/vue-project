/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 22);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap) {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\tvar base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16).Buffer))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4wLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/OTEwMCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwidXNlU291cmNlTWFwIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiam9pbiIsImkiLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJsZW5ndGgiLCJpZCIsInB1c2giLCJjc3NNYXBwaW5nIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsImNvbmNhdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsIkJ1ZmZlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBSUE7QUFDQUEsT0FBT0MsT0FBUCxHQUFpQixVQUFTQyxZQUFULEVBQXVCO0FBQ3ZDLEtBQUlDLE9BQU8sRUFBWDs7QUFFQTtBQUNBQSxNQUFLQyxRQUFMLEdBQWdCLFNBQVNBLFFBQVQsR0FBb0I7QUFDbkMsU0FBTyxLQUFLQyxHQUFMLENBQVMsVUFBVUMsSUFBVixFQUFnQjtBQUMvQixPQUFJQyxVQUFVQyx1QkFBdUJGLElBQXZCLEVBQTZCSixZQUE3QixDQUFkO0FBQ0EsT0FBR0ksS0FBSyxDQUFMLENBQUgsRUFBWTtBQUNYLFdBQU8sWUFBWUEsS0FBSyxDQUFMLENBQVosR0FBc0IsR0FBdEIsR0FBNEJDLE9BQTVCLEdBQXNDLEdBQTdDO0FBQ0EsSUFGRCxNQUVPO0FBQ04sV0FBT0EsT0FBUDtBQUNBO0FBQ0QsR0FQTSxFQU9KRSxJQVBJLENBT0MsRUFQRCxDQUFQO0FBUUEsRUFURDs7QUFXQTtBQUNBTixNQUFLTyxDQUFMLEdBQVMsVUFBU0MsT0FBVCxFQUFrQkMsVUFBbEIsRUFBOEI7QUFDdEMsTUFBRyxPQUFPRCxPQUFQLEtBQW1CLFFBQXRCLEVBQ0NBLFVBQVUsQ0FBQyxDQUFDLElBQUQsRUFBT0EsT0FBUCxFQUFnQixFQUFoQixDQUFELENBQVY7QUFDRCxNQUFJRSx5QkFBeUIsRUFBN0I7QUFDQSxPQUFJLElBQUlILElBQUksQ0FBWixFQUFlQSxJQUFJLEtBQUtJLE1BQXhCLEVBQWdDSixHQUFoQyxFQUFxQztBQUNwQyxPQUFJSyxLQUFLLEtBQUtMLENBQUwsRUFBUSxDQUFSLENBQVQ7QUFDQSxPQUFHLE9BQU9LLEVBQVAsS0FBYyxRQUFqQixFQUNDRix1QkFBdUJFLEVBQXZCLElBQTZCLElBQTdCO0FBQ0Q7QUFDRCxPQUFJTCxJQUFJLENBQVIsRUFBV0EsSUFBSUMsUUFBUUcsTUFBdkIsRUFBK0JKLEdBQS9CLEVBQW9DO0FBQ25DLE9BQUlKLE9BQU9LLFFBQVFELENBQVIsQ0FBWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBRyxPQUFPSixLQUFLLENBQUwsQ0FBUCxLQUFtQixRQUFuQixJQUErQixDQUFDTyx1QkFBdUJQLEtBQUssQ0FBTCxDQUF2QixDQUFuQyxFQUFvRTtBQUNuRSxRQUFHTSxjQUFjLENBQUNOLEtBQUssQ0FBTCxDQUFsQixFQUEyQjtBQUMxQkEsVUFBSyxDQUFMLElBQVVNLFVBQVY7QUFDQSxLQUZELE1BRU8sSUFBR0EsVUFBSCxFQUFlO0FBQ3JCTixVQUFLLENBQUwsSUFBVSxNQUFNQSxLQUFLLENBQUwsQ0FBTixHQUFnQixTQUFoQixHQUE0Qk0sVUFBNUIsR0FBeUMsR0FBbkQ7QUFDQTtBQUNEVCxTQUFLYSxJQUFMLENBQVVWLElBQVY7QUFDQTtBQUNEO0FBQ0QsRUF4QkQ7QUF5QkEsUUFBT0gsSUFBUDtBQUNBLENBMUNEOztBQTRDQSxTQUFTSyxzQkFBVCxDQUFnQ0YsSUFBaEMsRUFBc0NKLFlBQXRDLEVBQW9EO0FBQ25ELEtBQUlLLFVBQVVELEtBQUssQ0FBTCxLQUFXLEVBQXpCO0FBQ0EsS0FBSVcsYUFBYVgsS0FBSyxDQUFMLENBQWpCO0FBQ0EsS0FBSSxDQUFDVyxVQUFMLEVBQWlCO0FBQ2hCLFNBQU9WLE9BQVA7QUFDQTs7QUFFRCxLQUFJTCxZQUFKLEVBQWtCO0FBQ2pCLE1BQUlnQixnQkFBZ0JDLFVBQVVGLFVBQVYsQ0FBcEI7QUFDQSxNQUFJRyxhQUFhSCxXQUFXSSxPQUFYLENBQW1CaEIsR0FBbkIsQ0FBdUIsVUFBVWlCLE1BQVYsRUFBa0I7QUFDekQsVUFBTyxtQkFBbUJMLFdBQVdNLFVBQTlCLEdBQTJDRCxNQUEzQyxHQUFvRCxLQUEzRDtBQUNBLEdBRmdCLENBQWpCOztBQUlBLFNBQU8sQ0FBQ2YsT0FBRCxFQUFVaUIsTUFBVixDQUFpQkosVUFBakIsRUFBNkJJLE1BQTdCLENBQW9DLENBQUNOLGFBQUQsQ0FBcEMsRUFBcURULElBQXJELENBQTBELElBQTFELENBQVA7QUFDQTs7QUFFRCxRQUFPLENBQUNGLE9BQUQsRUFBVUUsSUFBVixDQUFlLElBQWYsQ0FBUDtBQUNBOztBQUVEO0FBQ0EsU0FBU1UsU0FBVCxDQUFtQk0sU0FBbkIsRUFBOEI7QUFDNUIsS0FBSUMsU0FBUyxJQUFJQyxNQUFKLENBQVdDLEtBQUtDLFNBQUwsQ0FBZUosU0FBZixDQUFYLEVBQXNDckIsUUFBdEMsQ0FBK0MsUUFBL0MsQ0FBYjtBQUNBLEtBQUkwQixPQUFPLGlFQUFpRUosTUFBNUU7O0FBRUEsUUFBTyxTQUFTSSxJQUFULEdBQWdCLEtBQXZCO0FBQ0QsQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXApIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIHZhciBiYXNlNjQgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC4yOC4wQGNzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5jb21wdXRlZCB8fCBudWxsKVxuICAgIE9iamVjdC5rZXlzKGNzc01vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG1vZHVsZSA9IGNzc01vZHVsZXNba2V5XVxuICAgICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZSB9XG4gICAgfSlcbiAgICBvcHRpb25zLmNvbXB1dGVkID0gY29tcHV0ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(21)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanM/YzBiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsQ0FBSjs7QUFFQTtBQUNBQSxJQUFLLFlBQVc7QUFDZixRQUFPLElBQVA7QUFDQSxDQUZHLEVBQUo7O0FBSUEsSUFBSTtBQUNIO0FBQ0FBLEtBQUlBLEtBQUtDLFNBQVMsYUFBVCxHQUFMLElBQWtDLENBQUMsR0FBRUMsSUFBSCxFQUFTLE1BQVQsQ0FBdEM7QUFDQSxDQUhELENBR0UsT0FBTUMsQ0FBTixFQUFTO0FBQ1Y7QUFDQSxLQUFHLFFBQU9DLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBckIsRUFDQ0osSUFBSUksTUFBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQk4sQ0FBakIiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * vue-resource v1.3.1\n * https://github.com/pagekit/vue-resource\n * Released under the MIT License.\n */\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nvar RESOLVED = 0;\nvar REJECTED = 1;\nvar PENDING = 2;\n\nfunction Promise$1(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    var promise = this;\n\n    try {\n        executor(function (x) {\n            promise.resolve(x);\n        }, function (r) {\n            promise.reject(r);\n        });\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromise$1.reject = function (r) {\n    return new Promise$1(function (resolve, reject) {\n        reject(r);\n    });\n};\n\nPromise$1.resolve = function (x) {\n    return new Promise$1(function (resolve, reject) {\n        resolve(x);\n    });\n};\n\nPromise$1.all = function all(iterable) {\n    return new Promise$1(function (resolve, reject) {\n        var count = 0,\n            result = [];\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$1.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromise$1.race = function race(iterable) {\n    return new Promise$1(function (resolve, reject) {\n        for (var i = 0; i < iterable.length; i += 1) {\n            Promise$1.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nvar p$1 = Promise$1.prototype;\n\np$1.resolve = function resolve(x) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        var called = false;\n\n        try {\n            var then = x && x['then'];\n\n            if (x !== null && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && typeof then === 'function') {\n                then.call(x, function (x) {\n                    if (!called) {\n                        promise.resolve(x);\n                    }\n                    called = true;\n                }, function (r) {\n                    if (!called) {\n                        promise.reject(r);\n                    }\n                    called = true;\n                });\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np$1.reject = function reject(reason) {\n    var promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np$1.notify = function notify() {\n    var promise = this;\n\n    nextTick(function () {\n        if (promise.state !== PENDING) {\n            while (promise.deferred.length) {\n                var deferred = promise.deferred.shift(),\n                    onResolved = deferred[0],\n                    onRejected = deferred[1],\n                    resolve = deferred[2],\n                    reject = deferred[3];\n\n                try {\n                    if (promise.state === RESOLVED) {\n                        if (typeof onResolved === 'function') {\n                            resolve(onResolved.call(undefined, promise.value));\n                        } else {\n                            resolve(promise.value);\n                        }\n                    } else if (promise.state === REJECTED) {\n                        if (typeof onRejected === 'function') {\n                            resolve(onRejected.call(undefined, promise.value));\n                        } else {\n                            reject(promise.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np$1.then = function then(onResolved, onRejected) {\n    var promise = this;\n\n    return new Promise$1(function (resolve, reject) {\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\n        promise.notify();\n    });\n};\n\np$1.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/**\n * Promise adapter.\n */\n\nif (typeof Promise === 'undefined') {\n    window.Promise = Promise$1;\n}\n\nfunction PromiseObj(executor, context) {\n\n    if (executor instanceof Promise) {\n        this.promise = executor;\n    } else {\n        this.promise = new Promise(executor.bind(context));\n    }\n\n    this.context = context;\n}\n\nPromiseObj.all = function (iterable, context) {\n    return new PromiseObj(Promise.all(iterable), context);\n};\n\nPromiseObj.resolve = function (value, context) {\n    return new PromiseObj(Promise.resolve(value), context);\n};\n\nPromiseObj.reject = function (reason, context) {\n    return new PromiseObj(Promise.reject(reason), context);\n};\n\nPromiseObj.race = function (iterable, context) {\n    return new PromiseObj(Promise.race(iterable), context);\n};\n\nvar p = PromiseObj.prototype;\n\np.bind = function (context) {\n    this.context = context;\n    return this;\n};\n\np.then = function (fulfilled, rejected) {\n\n    if (fulfilled && fulfilled.bind && this.context) {\n        fulfilled = fulfilled.bind(this.context);\n    }\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);\n};\n\np.catch = function (rejected) {\n\n    if (rejected && rejected.bind && this.context) {\n        rejected = rejected.bind(this.context);\n    }\n\n    return new PromiseObj(this.promise.catch(rejected), this.context);\n};\n\np.finally = function (callback) {\n\n    return this.then(function (value) {\n        callback.call(this);\n        return value;\n    }, function (reason) {\n        callback.call(this);\n        return Promise.reject(reason);\n    });\n};\n\n/**\n * Utility functions.\n */\n\nvar ref = {};\nvar hasOwnProperty = ref.hasOwnProperty;\n\nvar ref$1 = [];\nvar slice = ref$1.slice;\nvar debug = false;\nvar ntick;\n\nvar inBrowser = typeof window !== 'undefined';\n\nvar Util = function Util(ref) {\n    var config = ref.config;\n    var nextTick = ref.nextTick;\n\n    ntick = nextTick;\n    debug = config.debug || !config.silent;\n};\n\nfunction warn(msg) {\n    if (typeof console !== 'undefined' && debug) {\n        console.warn('[VueResource warn]: ' + msg);\n    }\n}\n\nfunction error(msg) {\n    if (typeof console !== 'undefined') {\n        console.error(msg);\n    }\n}\n\nfunction nextTick(cb, ctx) {\n    return ntick(cb, ctx);\n}\n\nfunction trim(str) {\n    return str ? str.replace(/^\\s*|\\s*$/g, '') : '';\n}\n\nfunction toLower(str) {\n    return str ? str.toLowerCase() : '';\n}\n\nfunction toUpper(str) {\n    return str ? str.toUpperCase() : '';\n}\n\nvar isArray = Array.isArray;\n\nfunction isString(val) {\n    return typeof val === 'string';\n}\n\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n}\n\nfunction isBlob(obj) {\n    return typeof Blob !== 'undefined' && obj instanceof Blob;\n}\n\nfunction isFormData(obj) {\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\n}\n\nfunction when(value, fulfilled, rejected) {\n\n    var promise = PromiseObj.resolve(value);\n\n    if (arguments.length < 2) {\n        return promise;\n    }\n\n    return promise.then(fulfilled, rejected);\n}\n\nfunction options(fn, obj, opts) {\n\n    opts = opts || {};\n\n    if (isFunction(opts)) {\n        opts = opts.call(obj);\n    }\n\n    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\n}\n\nfunction each(obj, iterator) {\n\n    var i, key;\n\n    if (isArray(obj)) {\n        for (i = 0; i < obj.length; i++) {\n            iterator.call(obj[i], obj[i], i);\n        }\n    } else if (isObject(obj)) {\n        for (key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                iterator.call(obj[key], obj[key], key);\n            }\n        }\n    }\n\n    return obj;\n}\n\nvar assign = Object.assign || _assign;\n\nfunction merge(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source, true);\n    });\n\n    return target;\n}\n\nfunction defaults(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n\n        for (var key in source) {\n            if (target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n    });\n\n    return target;\n}\n\nfunction _assign(target) {\n\n    var args = slice.call(arguments, 1);\n\n    args.forEach(function (source) {\n        _merge(target, source);\n    });\n\n    return target;\n}\n\nfunction _merge(target, source, deep) {\n    for (var key in source) {\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n                target[key] = {};\n            }\n            if (isArray(source[key]) && !isArray(target[key])) {\n                target[key] = [];\n            }\n            _merge(target[key], source[key], deep);\n        } else if (source[key] !== undefined) {\n            target[key] = source[key];\n        }\n    }\n}\n\n/**\n * Root Prefix Transform.\n */\n\nvar root = function root(options$$1, next) {\n\n    var url = next(options$$1);\n\n    if (isString(options$$1.root) && !url.match(/^(https?:)?\\//)) {\n        url = options$$1.root + '/' + url;\n    }\n\n    return url;\n};\n\n/**\n * Query Parameter Transform.\n */\n\nvar query = function query(options$$1, next) {\n\n    var urlParams = Object.keys(Url.options.params),\n        query = {},\n        url = next(options$$1);\n\n    each(options$$1.params, function (value, key) {\n        if (urlParams.indexOf(key) === -1) {\n            query[key] = value;\n        }\n    });\n\n    query = Url.params(query);\n\n    if (query) {\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\n    }\n\n    return url;\n};\n\n/**\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\n */\n\nfunction expand(url, params, variables) {\n\n    var tmpl = parse(url),\n        expanded = tmpl.expand(params);\n\n    if (variables) {\n        variables.push.apply(variables, tmpl.vars);\n    }\n\n    return expanded;\n}\n\nfunction parse(template) {\n\n    var operators = ['+', '#', '.', '/', ';', '?', '&'],\n        variables = [];\n\n    return {\n        vars: variables,\n        expand: function expand(context) {\n            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n                if (expression) {\n\n                    var operator = null,\n                        values = [];\n\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\n                        operator = expression.charAt(0);\n                        expression = expression.substr(1);\n                    }\n\n                    expression.split(/,/g).forEach(function (variable) {\n                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n                        variables.push(tmp[1]);\n                    });\n\n                    if (operator && operator !== '+') {\n\n                        var separator = ',';\n\n                        if (operator === '?') {\n                            separator = '&';\n                        } else if (operator !== '#') {\n                            separator = operator;\n                        }\n\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\n                    } else {\n                        return values.join(',');\n                    }\n                } else {\n                    return encodeReserved(literal);\n                }\n            });\n        }\n    };\n}\n\nfunction getValues(context, operator, key, modifier) {\n\n    var value = context[key],\n        result = [];\n\n    if (isDefined(value) && value !== '') {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n            value = value.toString();\n\n            if (modifier && modifier !== '*') {\n                value = value.substring(0, parseInt(modifier, 10));\n            }\n\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n        } else {\n            if (modifier === '*') {\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            result.push(encodeValue(operator, value[k], k));\n                        }\n                    });\n                }\n            } else {\n                var tmp = [];\n\n                if (Array.isArray(value)) {\n                    value.filter(isDefined).forEach(function (value) {\n                        tmp.push(encodeValue(operator, value));\n                    });\n                } else {\n                    Object.keys(value).forEach(function (k) {\n                        if (isDefined(value[k])) {\n                            tmp.push(encodeURIComponent(k));\n                            tmp.push(encodeValue(operator, value[k].toString()));\n                        }\n                    });\n                }\n\n                if (isKeyOperator(operator)) {\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\n                } else if (tmp.length !== 0) {\n                    result.push(tmp.join(','));\n                }\n            }\n        }\n    } else {\n        if (operator === ';') {\n            result.push(encodeURIComponent(key));\n        } else if (value === '' && (operator === '&' || operator === '?')) {\n            result.push(encodeURIComponent(key) + '=');\n        } else if (value === '') {\n            result.push('');\n        }\n    }\n\n    return result;\n}\n\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n    return operator === ';' || operator === '&' || operator === '?';\n}\n\nfunction encodeValue(operator, value, key) {\n\n    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\n\n    if (key) {\n        return encodeURIComponent(key) + '=' + value;\n    } else {\n        return value;\n    }\n}\n\nfunction encodeReserved(str) {\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n        if (!/%[0-9A-Fa-f]/.test(part)) {\n            part = encodeURI(part);\n        }\n        return part;\n    }).join('');\n}\n\n/**\n * URL Template (RFC 6570) Transform.\n */\n\nvar template = function template(options) {\n\n    var variables = [],\n        url = expand(options.url, options.params, variables);\n\n    variables.forEach(function (key) {\n        delete options.params[key];\n    });\n\n    return url;\n};\n\n/**\n * Service for URL templating.\n */\n\nfunction Url(url, params) {\n\n    var self = this || {},\n        options$$1 = url,\n        transform;\n\n    if (isString(url)) {\n        options$$1 = { url: url, params: params };\n    }\n\n    options$$1 = merge({}, Url.options, self.$options, options$$1);\n\n    Url.transforms.forEach(function (handler) {\n\n        if (isString(handler)) {\n            handler = Url.transform[handler];\n        }\n\n        if (isFunction(handler)) {\n            transform = factory(handler, transform, self.$vm);\n        }\n    });\n\n    return transform(options$$1);\n}\n\n/**\n * Url options.\n */\n\nUrl.options = {\n    url: '',\n    root: null,\n    params: {}\n};\n\n/**\n * Url transforms.\n */\n\nUrl.transform = { template: template, query: query, root: root };\nUrl.transforms = ['template', 'query', 'root'];\n\n/**\n * Encodes a Url parameter string.\n *\n * @param {Object} obj\n */\n\nUrl.params = function (obj) {\n\n    var params = [],\n        escape = encodeURIComponent;\n\n    params.add = function (key, value) {\n\n        if (isFunction(value)) {\n            value = value();\n        }\n\n        if (value === null) {\n            value = '';\n        }\n\n        this.push(escape(key) + '=' + escape(value));\n    };\n\n    serialize(params, obj);\n\n    return params.join('&').replace(/%20/g, '+');\n};\n\n/**\n * Parse a URL and return its components.\n *\n * @param {String} url\n */\n\nUrl.parse = function (url) {\n\n    var el = document.createElement('a');\n\n    if (document.documentMode) {\n        el.href = url;\n        url = el.href;\n    }\n\n    el.href = url;\n\n    return {\n        href: el.href,\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\n        port: el.port,\n        host: el.host,\n        hostname: el.hostname,\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\n        search: el.search ? el.search.replace(/^\\?/, '') : '',\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\n    };\n};\n\nfunction factory(handler, next, vm) {\n    return function (options$$1) {\n        return handler.call(vm, options$$1, next);\n    };\n}\n\nfunction serialize(params, obj, scope) {\n\n    var array = isArray(obj),\n        plain = isPlainObject(obj),\n        hash;\n\n    each(obj, function (value, key) {\n\n        hash = isObject(value) || isArray(value);\n\n        if (scope) {\n            key = scope + '[' + (plain || hash ? key : '') + ']';\n        }\n\n        if (!scope && array) {\n            params.add(value.name, value.value);\n        } else if (hash) {\n            serialize(params, value, key);\n        } else {\n            params.add(key, value);\n        }\n    });\n}\n\n/**\n * XDomain client (Internet Explorer).\n */\n\nvar xdrClient = function xdrClient(request) {\n    return new PromiseObj(function (resolve) {\n\n        var xdr = new XDomainRequest(),\n            handler = function handler(ref) {\n            var type = ref.type;\n\n            var status = 0;\n\n            if (type === 'load') {\n                status = 200;\n            } else if (type === 'error') {\n                status = 500;\n            }\n\n            resolve(request.respondWith(xdr.responseText, { status: status }));\n        };\n\n        request.abort = function () {\n            return xdr.abort();\n        };\n\n        xdr.open(request.method, request.getUrl());\n\n        if (request.timeout) {\n            xdr.timeout = request.timeout;\n        }\n\n        xdr.onload = handler;\n        xdr.onabort = handler;\n        xdr.onerror = handler;\n        xdr.ontimeout = handler;\n        xdr.onprogress = function () {};\n        xdr.send(request.getBody());\n    });\n};\n\n/**\n * CORS Interceptor.\n */\n\nvar SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();\n\nvar cors = function cors(request, next) {\n\n    if (inBrowser) {\n\n        var orgUrl = Url.parse(location.href);\n        var reqUrl = Url.parse(request.getUrl());\n\n        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {\n\n            request.crossOrigin = true;\n            request.emulateHTTP = false;\n\n            if (!SUPPORTS_CORS) {\n                request.client = xdrClient;\n            }\n        }\n    }\n\n    next();\n};\n\n/**\n * Body Interceptor.\n */\n\nvar body = function body(request, next) {\n\n    if (isFormData(request.body)) {\n\n        request.headers.delete('Content-Type');\n    } else if (isObject(request.body) || isArray(request.body)) {\n\n        if (request.emulateJSON) {\n            request.body = Url.params(request.body);\n            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');\n        } else {\n            request.body = JSON.stringify(request.body);\n        }\n    }\n\n    next(function (response) {\n\n        Object.defineProperty(response, 'data', {\n\n            get: function get() {\n                return this.body;\n            },\n\n            set: function set(body) {\n                this.body = body;\n            }\n\n        });\n\n        return response.bodyText ? when(response.text(), function (text) {\n\n            var type = response.headers.get('Content-Type') || '';\n\n            if (type.indexOf('application/json') === 0 || isJson(text)) {\n\n                try {\n                    response.body = JSON.parse(text);\n                } catch (e) {\n                    response.body = null;\n                }\n            } else {\n                response.body = text;\n            }\n\n            return response;\n        }) : response;\n    });\n};\n\nfunction isJson(str) {\n\n    var start = str.match(/^\\[|^\\{(?!\\{)/),\n        end = { '[': /]$/, '{': /}$/ };\n\n    return start && end[start[0]].test(str);\n}\n\n/**\n * JSONP client (Browser).\n */\n\nvar jsonpClient = function jsonpClient(request) {\n    return new PromiseObj(function (resolve) {\n\n        var name = request.jsonp || 'callback',\n            callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2),\n            body = null,\n            handler,\n            script;\n\n        handler = function handler(ref) {\n            var type = ref.type;\n\n            var status = 0;\n\n            if (type === 'load' && body !== null) {\n                status = 200;\n            } else if (type === 'error') {\n                status = 500;\n            }\n\n            if (status && window[callback]) {\n                delete window[callback];\n                document.body.removeChild(script);\n            }\n\n            resolve(request.respondWith(body, { status: status }));\n        };\n\n        window[callback] = function (result) {\n            body = JSON.stringify(result);\n        };\n\n        request.abort = function () {\n            handler({ type: 'abort' });\n        };\n\n        request.params[name] = callback;\n\n        if (request.timeout) {\n            setTimeout(request.abort, request.timeout);\n        }\n\n        script = document.createElement('script');\n        script.src = request.getUrl();\n        script.type = 'text/javascript';\n        script.async = true;\n        script.onload = handler;\n        script.onerror = handler;\n\n        document.body.appendChild(script);\n    });\n};\n\n/**\n * JSONP Interceptor.\n */\n\nvar jsonp = function jsonp(request, next) {\n\n    if (request.method == 'JSONP') {\n        request.client = jsonpClient;\n    }\n\n    next();\n};\n\n/**\n * Before Interceptor.\n */\n\nvar before = function before(request, next) {\n\n    if (isFunction(request.before)) {\n        request.before.call(this, request);\n    }\n\n    next();\n};\n\n/**\n * HTTP method override Interceptor.\n */\n\nvar method = function method(request, next) {\n\n    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\n        request.headers.set('X-HTTP-Method-Override', request.method);\n        request.method = 'POST';\n    }\n\n    next();\n};\n\n/**\n * Header Interceptor.\n */\n\nvar header = function header(request, next) {\n\n    var headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[toLower(request.method)]);\n\n    each(headers, function (value, name) {\n        if (!request.headers.has(name)) {\n            request.headers.set(name, value);\n        }\n    });\n\n    next();\n};\n\n/**\n * XMLHttp client (Browser).\n */\n\nvar xhrClient = function xhrClient(request) {\n    return new PromiseObj(function (resolve) {\n\n        var xhr = new XMLHttpRequest(),\n            handler = function handler(event) {\n\n            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\n                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\n                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)\n            });\n\n            each(trim(xhr.getAllResponseHeaders()).split('\\n'), function (row) {\n                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));\n            });\n\n            resolve(response);\n        };\n\n        request.abort = function () {\n            return xhr.abort();\n        };\n\n        if (request.progress) {\n            if (request.method === 'GET') {\n                xhr.addEventListener('progress', request.progress);\n            } else if (/^(POST|PUT)$/i.test(request.method)) {\n                xhr.upload.addEventListener('progress', request.progress);\n            }\n        }\n\n        xhr.open(request.method, request.getUrl(), true);\n\n        if (request.timeout) {\n            xhr.timeout = request.timeout;\n        }\n\n        if (request.responseType && 'responseType' in xhr) {\n            xhr.responseType = request.responseType;\n        }\n\n        if (request.withCredentials || request.credentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (!request.crossOrigin) {\n            request.headers.set('X-Requested-With', 'XMLHttpRequest');\n        }\n\n        request.headers.forEach(function (value, name) {\n            xhr.setRequestHeader(name, value);\n        });\n\n        xhr.onload = handler;\n        xhr.onabort = handler;\n        xhr.onerror = handler;\n        xhr.ontimeout = handler;\n        xhr.send(request.getBody());\n    });\n};\n\n/**\n * Http client (Node).\n */\n\nvar nodeClient = function nodeClient(request) {\n\n    var client = __webpack_require__(37);\n\n    return new PromiseObj(function (resolve) {\n\n        var url = request.getUrl();\n        var body = request.getBody();\n        var method = request.method;\n        var headers = {},\n            handler;\n\n        request.headers.forEach(function (value, name) {\n            headers[name] = value;\n        });\n\n        client(url, { body: body, method: method, headers: headers }).then(handler = function handler(resp) {\n\n            var response = request.respondWith(resp.body, {\n                status: resp.statusCode,\n                statusText: trim(resp.statusMessage)\n            });\n\n            each(resp.headers, function (value, name) {\n                response.headers.set(name, value);\n            });\n\n            resolve(response);\n        }, function (error$$1) {\n            return handler(error$$1.response);\n        });\n    });\n};\n\n/**\n * Base client.\n */\n\nvar Client = function Client(context) {\n\n    var reqHandlers = [sendRequest],\n        resHandlers = [],\n        handler;\n\n    if (!isObject(context)) {\n        context = null;\n    }\n\n    function Client(request) {\n        return new PromiseObj(function (resolve) {\n\n            function exec() {\n\n                handler = reqHandlers.pop();\n\n                if (isFunction(handler)) {\n                    handler.call(context, request, next);\n                } else {\n                    warn(\"Invalid interceptor of type \" + (typeof handler === 'undefined' ? 'undefined' : _typeof(handler)) + \", must be a function\");\n                    next();\n                }\n            }\n\n            function next(response) {\n\n                if (isFunction(response)) {\n\n                    resHandlers.unshift(response);\n                } else if (isObject(response)) {\n\n                    resHandlers.forEach(function (handler) {\n                        response = when(response, function (response) {\n                            return handler.call(context, response) || response;\n                        });\n                    });\n\n                    when(response, resolve);\n\n                    return;\n                }\n\n                exec();\n            }\n\n            exec();\n        }, context);\n    }\n\n    Client.use = function (handler) {\n        reqHandlers.push(handler);\n    };\n\n    return Client;\n};\n\nfunction sendRequest(request, resolve) {\n\n    var client = request.client || (inBrowser ? xhrClient : nodeClient);\n\n    resolve(client(request));\n}\n\n/**\n * HTTP Headers.\n */\n\nvar Headers = function Headers(headers) {\n    var this$1 = this;\n\n    this.map = {};\n\n    each(headers, function (value, name) {\n        return this$1.append(name, value);\n    });\n};\n\nHeaders.prototype.has = function has(name) {\n    return getName(this.map, name) !== null;\n};\n\nHeaders.prototype.get = function get(name) {\n\n    var list = this.map[getName(this.map, name)];\n\n    return list ? list.join() : null;\n};\n\nHeaders.prototype.getAll = function getAll(name) {\n    return this.map[getName(this.map, name)] || [];\n};\n\nHeaders.prototype.set = function set(name, value) {\n    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];\n};\n\nHeaders.prototype.append = function append(name, value) {\n\n    var list = this.map[getName(this.map, name)];\n\n    if (list) {\n        list.push(trim(value));\n    } else {\n        this.set(name, value);\n    }\n};\n\nHeaders.prototype.delete = function delete$1(name) {\n    delete this.map[getName(this.map, name)];\n};\n\nHeaders.prototype.deleteAll = function deleteAll() {\n    this.map = {};\n};\n\nHeaders.prototype.forEach = function forEach(callback, thisArg) {\n    var this$1 = this;\n\n    each(this.map, function (list, name) {\n        each(list, function (value) {\n            return callback.call(thisArg, value, name, this$1);\n        });\n    });\n};\n\nfunction getName(map, name) {\n    return Object.keys(map).reduce(function (prev, curr) {\n        return toLower(name) === toLower(curr) ? curr : prev;\n    }, null);\n}\n\nfunction normalizeName(name) {\n\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n        throw new TypeError('Invalid character in header field name');\n    }\n\n    return trim(name);\n}\n\n/**\n * HTTP Response.\n */\n\nvar Response = function Response(body, ref) {\n    var url = ref.url;\n    var headers = ref.headers;\n    var status = ref.status;\n    var statusText = ref.statusText;\n\n    this.url = url;\n    this.ok = status >= 200 && status < 300;\n    this.status = status || 0;\n    this.statusText = statusText || '';\n    this.headers = new Headers(headers);\n    this.body = body;\n\n    if (isString(body)) {\n\n        this.bodyText = body;\n    } else if (isBlob(body)) {\n\n        this.bodyBlob = body;\n\n        if (isBlobText(body)) {\n            this.bodyText = blobText(body);\n        }\n    }\n};\n\nResponse.prototype.blob = function blob() {\n    return when(this.bodyBlob);\n};\n\nResponse.prototype.text = function text() {\n    return when(this.bodyText);\n};\n\nResponse.prototype.json = function json() {\n    return when(this.text(), function (text) {\n        return JSON.parse(text);\n    });\n};\n\nfunction blobText(body) {\n    return new PromiseObj(function (resolve) {\n\n        var reader = new FileReader();\n\n        reader.readAsText(body);\n        reader.onload = function () {\n            resolve(reader.result);\n        };\n    });\n}\n\nfunction isBlobText(body) {\n    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;\n}\n\n/**\n * HTTP Request.\n */\n\nvar Request = function Request(options$$1) {\n\n    this.body = null;\n    this.params = {};\n\n    assign(this, options$$1, {\n        method: toUpper(options$$1.method || 'GET')\n    });\n\n    if (!(this.headers instanceof Headers)) {\n        this.headers = new Headers(this.headers);\n    }\n};\n\nRequest.prototype.getUrl = function getUrl() {\n    return Url(this);\n};\n\nRequest.prototype.getBody = function getBody() {\n    return this.body;\n};\n\nRequest.prototype.respondWith = function respondWith(body, options$$1) {\n    return new Response(body, assign(options$$1 || {}, { url: this.getUrl() }));\n};\n\n/**\n * Service for sending network requests.\n */\n\nvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\nvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\n\nfunction Http(options$$1) {\n\n    var self = this || {},\n        client = Client(self.$vm);\n\n    defaults(options$$1 || {}, self.$options, Http.options);\n\n    Http.interceptors.forEach(function (handler) {\n\n        if (isString(handler)) {\n            handler = Http.interceptor[handler];\n        }\n\n        if (isFunction(handler)) {\n            client.use(handler);\n        }\n    });\n\n    return client(new Request(options$$1)).then(function (response) {\n\n        return response.ok ? response : PromiseObj.reject(response);\n    }, function (response) {\n\n        if (response instanceof Error) {\n            error(response);\n        }\n\n        return PromiseObj.reject(response);\n    });\n}\n\nHttp.options = {};\n\nHttp.headers = {\n    put: JSON_CONTENT_TYPE,\n    post: JSON_CONTENT_TYPE,\n    patch: JSON_CONTENT_TYPE,\n    delete: JSON_CONTENT_TYPE,\n    common: COMMON_HEADERS,\n    custom: {}\n};\n\nHttp.interceptor = { before: before, method: method, body: body, jsonp: jsonp, header: header, cors: cors };\nHttp.interceptors = ['before', 'method', 'body', 'jsonp', 'header', 'cors'];\n\n['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {\n\n    Http[method$$1] = function (url, options$$1) {\n        return this(assign(options$$1 || {}, { url: url, method: method$$1 }));\n    };\n});\n\n['post', 'put', 'patch'].forEach(function (method$$1) {\n\n    Http[method$$1] = function (url, body$$1, options$$1) {\n        return this(assign(options$$1 || {}, { url: url, method: method$$1, body: body$$1 }));\n    };\n});\n\n/**\n * Service for interacting with RESTful services.\n */\n\nfunction Resource(url, params, actions, options$$1) {\n\n    var self = this || {},\n        resource = {};\n\n    actions = assign({}, Resource.actions, actions);\n\n    each(actions, function (action, name) {\n\n        action = merge({ url: url, params: assign({}, params) }, options$$1, action);\n\n        resource[name] = function () {\n            return (self.$http || Http)(opts(action, arguments));\n        };\n    });\n\n    return resource;\n}\n\nfunction opts(action, args) {\n\n    var options$$1 = assign({}, action),\n        params = {},\n        body;\n\n    switch (args.length) {\n\n        case 2:\n\n            params = args[0];\n            body = args[1];\n\n            break;\n\n        case 1:\n\n            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {\n                body = args[0];\n            } else {\n                params = args[0];\n            }\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';\n    }\n\n    options$$1.body = body;\n    options$$1.params = assign({}, options$$1.params, params);\n\n    return options$$1;\n}\n\nResource.actions = {\n\n    get: { method: 'GET' },\n    save: { method: 'POST' },\n    query: { method: 'GET' },\n    update: { method: 'PUT' },\n    remove: { method: 'DELETE' },\n    delete: { method: 'DELETE' }\n\n};\n\n/**\n * Install plugin.\n */\n\nfunction plugin(Vue) {\n\n    if (plugin.installed) {\n        return;\n    }\n\n    Util(Vue);\n\n    Vue.url = Url;\n    Vue.http = Http;\n    Vue.resource = Resource;\n    Vue.Promise = PromiseObj;\n\n    Object.defineProperties(Vue.prototype, {\n\n        $url: {\n            get: function get() {\n                return options(Vue.url, this, this.$options.url);\n            }\n        },\n\n        $http: {\n            get: function get() {\n                return options(Vue.http, this, this.$options.http);\n            }\n        },\n\n        $resource: {\n            get: function get() {\n                return Vue.resource.bind(this);\n            }\n        },\n\n        $promise: {\n            get: function get() {\n                var this$1 = this;\n\n                return function (executor) {\n                    return new Vue.Promise(executor, this$1);\n                };\n            }\n        }\n\n    });\n}\n\nif (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(plugin);\n}\n\nexports.default = plugin;\nexports.Url = Url;\nexports.Http = Http;\nexports.Resource = Resource;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4xLjMuMUB2dWUtcmVzb3VyY2UvZGlzdC92dWUtcmVzb3VyY2UuZXMyMDE1LmpzP2RlMGEiXSwibmFtZXMiOlsiUkVTT0xWRUQiLCJSRUpFQ1RFRCIsIlBFTkRJTkciLCJQcm9taXNlJDEiLCJleGVjdXRvciIsInN0YXRlIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJkZWZlcnJlZCIsInByb21pc2UiLCJ4IiwicmVzb2x2ZSIsInIiLCJyZWplY3QiLCJlIiwiYWxsIiwiaXRlcmFibGUiLCJjb3VudCIsInJlc3VsdCIsImxlbmd0aCIsInJlc29sdmVyIiwiaSIsInRoZW4iLCJyYWNlIiwicCQxIiwicHJvdG90eXBlIiwiVHlwZUVycm9yIiwiY2FsbGVkIiwiY2FsbCIsIm5vdGlmeSIsInJlYXNvbiIsIm5leHRUaWNrIiwic2hpZnQiLCJvblJlc29sdmVkIiwib25SZWplY3RlZCIsInB1c2giLCJjYXRjaCIsIlByb21pc2UiLCJ3aW5kb3ciLCJQcm9taXNlT2JqIiwiY29udGV4dCIsImJpbmQiLCJwIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJmaW5hbGx5IiwiY2FsbGJhY2siLCJyZWYiLCJoYXNPd25Qcm9wZXJ0eSIsInJlZiQxIiwic2xpY2UiLCJkZWJ1ZyIsIm50aWNrIiwiaW5Ccm93c2VyIiwiVXRpbCIsImNvbmZpZyIsInNpbGVudCIsIndhcm4iLCJtc2ciLCJjb25zb2xlIiwiZXJyb3IiLCJjYiIsImN0eCIsInRyaW0iLCJzdHIiLCJyZXBsYWNlIiwidG9Mb3dlciIsInRvTG93ZXJDYXNlIiwidG9VcHBlciIsInRvVXBwZXJDYXNlIiwiaXNBcnJheSIsIkFycmF5IiwiaXNTdHJpbmciLCJ2YWwiLCJpc0Z1bmN0aW9uIiwiaXNPYmplY3QiLCJvYmoiLCJpc1BsYWluT2JqZWN0IiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJpc0Jsb2IiLCJCbG9iIiwiaXNGb3JtRGF0YSIsIkZvcm1EYXRhIiwid2hlbiIsImFyZ3VtZW50cyIsIm9wdGlvbnMiLCJmbiIsIm9wdHMiLCJtZXJnZSIsIiR2bSIsIiRvcHRpb25zIiwiZWFjaCIsIml0ZXJhdG9yIiwia2V5IiwiYXNzaWduIiwiX2Fzc2lnbiIsInRhcmdldCIsImFyZ3MiLCJmb3JFYWNoIiwic291cmNlIiwiX21lcmdlIiwiZGVmYXVsdHMiLCJkZWVwIiwicm9vdCIsIm9wdGlvbnMkJDEiLCJuZXh0IiwidXJsIiwibWF0Y2giLCJxdWVyeSIsInVybFBhcmFtcyIsImtleXMiLCJVcmwiLCJwYXJhbXMiLCJpbmRleE9mIiwiZXhwYW5kIiwidmFyaWFibGVzIiwidG1wbCIsInBhcnNlIiwiZXhwYW5kZWQiLCJhcHBseSIsInZhcnMiLCJ0ZW1wbGF0ZSIsIm9wZXJhdG9ycyIsIl8iLCJleHByZXNzaW9uIiwibGl0ZXJhbCIsIm9wZXJhdG9yIiwidmFsdWVzIiwiY2hhckF0Iiwic3Vic3RyIiwic3BsaXQiLCJ2YXJpYWJsZSIsInRtcCIsImV4ZWMiLCJnZXRWYWx1ZXMiLCJzZXBhcmF0b3IiLCJqb2luIiwiZW5jb2RlUmVzZXJ2ZWQiLCJtb2RpZmllciIsImlzRGVmaW5lZCIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwicGFyc2VJbnQiLCJlbmNvZGVWYWx1ZSIsImlzS2V5T3BlcmF0b3IiLCJmaWx0ZXIiLCJrIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWFwIiwicGFydCIsInRlc3QiLCJlbmNvZGVVUkkiLCJzZWxmIiwidHJhbnNmb3JtIiwidHJhbnNmb3JtcyIsImhhbmRsZXIiLCJmYWN0b3J5IiwiZXNjYXBlIiwiYWRkIiwic2VyaWFsaXplIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkb2N1bWVudE1vZGUiLCJocmVmIiwicHJvdG9jb2wiLCJwb3J0IiwiaG9zdCIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwidm0iLCJzY29wZSIsImFycmF5IiwicGxhaW4iLCJuYW1lIiwieGRyQ2xpZW50IiwicmVxdWVzdCIsInhkciIsIlhEb21haW5SZXF1ZXN0IiwidHlwZSIsInN0YXR1cyIsInJlc3BvbmRXaXRoIiwicmVzcG9uc2VUZXh0IiwiYWJvcnQiLCJvcGVuIiwibWV0aG9kIiwiZ2V0VXJsIiwidGltZW91dCIsIm9ubG9hZCIsIm9uYWJvcnQiLCJvbmVycm9yIiwib250aW1lb3V0Iiwib25wcm9ncmVzcyIsInNlbmQiLCJnZXRCb2R5IiwiU1VQUE9SVFNfQ09SUyIsIlhNTEh0dHBSZXF1ZXN0IiwiY29ycyIsIm9yZ1VybCIsImxvY2F0aW9uIiwicmVxVXJsIiwiY3Jvc3NPcmlnaW4iLCJlbXVsYXRlSFRUUCIsImNsaWVudCIsImJvZHkiLCJoZWFkZXJzIiwiZGVsZXRlIiwiZW11bGF0ZUpTT04iLCJzZXQiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImJvZHlUZXh0IiwidGV4dCIsImlzSnNvbiIsInN0YXJ0IiwiZW5kIiwianNvbnBDbGllbnQiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJNYXRoIiwicmFuZG9tIiwic2NyaXB0IiwicmVtb3ZlQ2hpbGQiLCJzZXRUaW1lb3V0Iiwic3JjIiwiYXN5bmMiLCJhcHBlbmRDaGlsZCIsImJlZm9yZSIsImhlYWRlciIsIkh0dHAiLCJjb21tb24iLCJjdXN0b20iLCJoYXMiLCJ4aHJDbGllbnQiLCJ4aHIiLCJldmVudCIsInN0YXR1c1RleHQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyb3ciLCJhcHBlbmQiLCJwcm9ncmVzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1cGxvYWQiLCJyZXNwb25zZVR5cGUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsInNldFJlcXVlc3RIZWFkZXIiLCJub2RlQ2xpZW50IiwicmVxdWlyZSIsInJlc3AiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImVycm9yJCQxIiwiQ2xpZW50IiwicmVxSGFuZGxlcnMiLCJzZW5kUmVxdWVzdCIsInJlc0hhbmRsZXJzIiwicG9wIiwidW5zaGlmdCIsInVzZSIsIkhlYWRlcnMiLCJ0aGlzJDEiLCJnZXROYW1lIiwibGlzdCIsImdldEFsbCIsIm5vcm1hbGl6ZU5hbWUiLCJkZWxldGUkMSIsImRlbGV0ZUFsbCIsInRoaXNBcmciLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsIlJlc3BvbnNlIiwib2siLCJib2R5QmxvYiIsImlzQmxvYlRleHQiLCJibG9iVGV4dCIsImJsb2IiLCJqc29uIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc1RleHQiLCJSZXF1ZXN0IiwiQ09NTU9OX0hFQURFUlMiLCJKU09OX0NPTlRFTlRfVFlQRSIsImludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwiRXJyb3IiLCJwdXQiLCJwb3N0IiwicGF0Y2giLCJtZXRob2QkJDEiLCJib2R5JCQxIiwiUmVzb3VyY2UiLCJhY3Rpb25zIiwicmVzb3VyY2UiLCJhY3Rpb24iLCIkaHR0cCIsInNhdmUiLCJ1cGRhdGUiLCJyZW1vdmUiLCJwbHVnaW4iLCJWdWUiLCJpbnN0YWxsZWQiLCJodHRwIiwiZGVmaW5lUHJvcGVydGllcyIsIiR1cmwiLCIkcmVzb3VyY2UiLCIkcHJvbWlzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7O0FBTUE7Ozs7QUFJQSxJQUFJQSxXQUFXLENBQWY7QUFDQSxJQUFJQyxXQUFXLENBQWY7QUFDQSxJQUFJQyxVQUFXLENBQWY7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkI7O0FBRXpCLFNBQUtDLEtBQUwsR0FBYUgsT0FBYjtBQUNBLFNBQUtJLEtBQUwsR0FBYUMsU0FBYjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7O0FBRUEsUUFBSUMsVUFBVSxJQUFkOztBQUVBLFFBQUk7QUFDQUwsaUJBQVMsVUFBVU0sQ0FBVixFQUFhO0FBQ2xCRCxvQkFBUUUsT0FBUixDQUFnQkQsQ0FBaEI7QUFDSCxTQUZELEVBRUcsVUFBVUUsQ0FBVixFQUFhO0FBQ1pILG9CQUFRSSxNQUFSLENBQWVELENBQWY7QUFDSCxTQUpEO0FBS0gsS0FORCxDQU1FLE9BQU9FLENBQVAsRUFBVTtBQUNSTCxnQkFBUUksTUFBUixDQUFlQyxDQUFmO0FBQ0g7QUFDSjs7QUFFRFgsVUFBVVUsTUFBVixHQUFtQixVQUFVRCxDQUFWLEVBQWE7QUFDNUIsV0FBTyxJQUFJVCxTQUFKLENBQWMsVUFBVVEsT0FBVixFQUFtQkUsTUFBbkIsRUFBMkI7QUFDNUNBLGVBQU9ELENBQVA7QUFDSCxLQUZNLENBQVA7QUFHSCxDQUpEOztBQU1BVCxVQUFVUSxPQUFWLEdBQW9CLFVBQVVELENBQVYsRUFBYTtBQUM3QixXQUFPLElBQUlQLFNBQUosQ0FBYyxVQUFVUSxPQUFWLEVBQW1CRSxNQUFuQixFQUEyQjtBQUM1Q0YsZ0JBQVFELENBQVI7QUFDSCxLQUZNLENBQVA7QUFHSCxDQUpEOztBQU1BUCxVQUFVWSxHQUFWLEdBQWdCLFNBQVNBLEdBQVQsQ0FBYUMsUUFBYixFQUF1QjtBQUNuQyxXQUFPLElBQUliLFNBQUosQ0FBYyxVQUFVUSxPQUFWLEVBQW1CRSxNQUFuQixFQUEyQjtBQUM1QyxZQUFJSSxRQUFRLENBQVo7QUFBQSxZQUFlQyxTQUFTLEVBQXhCOztBQUVBLFlBQUlGLFNBQVNHLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkJSLG9CQUFRTyxNQUFSO0FBQ0g7O0FBRUQsaUJBQVNFLFFBQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ2pCLG1CQUFPLFVBQVVYLENBQVYsRUFBYTtBQUNoQlEsdUJBQU9HLENBQVAsSUFBWVgsQ0FBWjtBQUNBTyx5QkFBUyxDQUFUOztBQUVBLG9CQUFJQSxVQUFVRCxTQUFTRyxNQUF2QixFQUErQjtBQUMzQlIsNEJBQVFPLE1BQVI7QUFDSDtBQUNKLGFBUEQ7QUFRSDs7QUFFRCxhQUFLLElBQUlHLElBQUksQ0FBYixFQUFnQkEsSUFBSUwsU0FBU0csTUFBN0IsRUFBcUNFLEtBQUssQ0FBMUMsRUFBNkM7QUFDekNsQixzQkFBVVEsT0FBVixDQUFrQkssU0FBU0ssQ0FBVCxDQUFsQixFQUErQkMsSUFBL0IsQ0FBb0NGLFNBQVNDLENBQVQsQ0FBcEMsRUFBaURSLE1BQWpEO0FBQ0g7QUFDSixLQXJCTSxDQUFQO0FBc0JILENBdkJEOztBQXlCQVYsVUFBVW9CLElBQVYsR0FBaUIsU0FBU0EsSUFBVCxDQUFjUCxRQUFkLEVBQXdCO0FBQ3JDLFdBQU8sSUFBSWIsU0FBSixDQUFjLFVBQVVRLE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0FBQzVDLGFBQUssSUFBSVEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJTCxTQUFTRyxNQUE3QixFQUFxQ0UsS0FBSyxDQUExQyxFQUE2QztBQUN6Q2xCLHNCQUFVUSxPQUFWLENBQWtCSyxTQUFTSyxDQUFULENBQWxCLEVBQStCQyxJQUEvQixDQUFvQ1gsT0FBcEMsRUFBNkNFLE1BQTdDO0FBQ0g7QUFDSixLQUpNLENBQVA7QUFLSCxDQU5EOztBQVFBLElBQUlXLE1BQU1yQixVQUFVc0IsU0FBcEI7O0FBRUFELElBQUliLE9BQUosR0FBYyxTQUFTQSxPQUFULENBQWlCRCxDQUFqQixFQUFvQjtBQUM5QixRQUFJRCxVQUFVLElBQWQ7O0FBRUEsUUFBSUEsUUFBUUosS0FBUixLQUFrQkgsT0FBdEIsRUFBK0I7QUFDM0IsWUFBSVEsTUFBTUQsT0FBVixFQUFtQjtBQUNmLGtCQUFNLElBQUlpQixTQUFKLENBQWMsOEJBQWQsQ0FBTjtBQUNIOztBQUVELFlBQUlDLFNBQVMsS0FBYjs7QUFFQSxZQUFJO0FBQ0EsZ0JBQUlMLE9BQU9aLEtBQUtBLEVBQUUsTUFBRixDQUFoQjs7QUFFQSxnQkFBSUEsTUFBTSxJQUFOLElBQWMsUUFBT0EsQ0FBUCx5Q0FBT0EsQ0FBUCxPQUFhLFFBQTNCLElBQXVDLE9BQU9ZLElBQVAsS0FBZ0IsVUFBM0QsRUFBdUU7QUFDbkVBLHFCQUFLTSxJQUFMLENBQVVsQixDQUFWLEVBQWEsVUFBVUEsQ0FBVixFQUFhO0FBQ3RCLHdCQUFJLENBQUNpQixNQUFMLEVBQWE7QUFDVGxCLGdDQUFRRSxPQUFSLENBQWdCRCxDQUFoQjtBQUNIO0FBQ0RpQiw2QkFBUyxJQUFUO0FBRUgsaUJBTkQsRUFNRyxVQUFVZixDQUFWLEVBQWE7QUFDWix3QkFBSSxDQUFDZSxNQUFMLEVBQWE7QUFDVGxCLGdDQUFRSSxNQUFSLENBQWVELENBQWY7QUFDSDtBQUNEZSw2QkFBUyxJQUFUO0FBQ0gsaUJBWEQ7QUFZQTtBQUNIO0FBQ0osU0FsQkQsQ0FrQkUsT0FBT2IsQ0FBUCxFQUFVO0FBQ1IsZ0JBQUksQ0FBQ2EsTUFBTCxFQUFhO0FBQ1RsQix3QkFBUUksTUFBUixDQUFlQyxDQUFmO0FBQ0g7QUFDRDtBQUNIOztBQUVETCxnQkFBUUosS0FBUixHQUFnQkwsUUFBaEI7QUFDQVMsZ0JBQVFILEtBQVIsR0FBZ0JJLENBQWhCO0FBQ0FELGdCQUFRb0IsTUFBUjtBQUNIO0FBQ0osQ0F2Q0Q7O0FBeUNBTCxJQUFJWCxNQUFKLEdBQWEsU0FBU0EsTUFBVCxDQUFnQmlCLE1BQWhCLEVBQXdCO0FBQ2pDLFFBQUlyQixVQUFVLElBQWQ7O0FBRUEsUUFBSUEsUUFBUUosS0FBUixLQUFrQkgsT0FBdEIsRUFBK0I7QUFDM0IsWUFBSTRCLFdBQVdyQixPQUFmLEVBQXdCO0FBQ3BCLGtCQUFNLElBQUlpQixTQUFKLENBQWMsOEJBQWQsQ0FBTjtBQUNIOztBQUVEakIsZ0JBQVFKLEtBQVIsR0FBZ0JKLFFBQWhCO0FBQ0FRLGdCQUFRSCxLQUFSLEdBQWdCd0IsTUFBaEI7QUFDQXJCLGdCQUFRb0IsTUFBUjtBQUNIO0FBQ0osQ0FaRDs7QUFjQUwsSUFBSUssTUFBSixHQUFhLFNBQVNBLE1BQVQsR0FBa0I7QUFDM0IsUUFBSXBCLFVBQVUsSUFBZDs7QUFFQXNCLGFBQVMsWUFBWTtBQUNqQixZQUFJdEIsUUFBUUosS0FBUixLQUFrQkgsT0FBdEIsRUFBK0I7QUFDM0IsbUJBQU9PLFFBQVFELFFBQVIsQ0FBaUJXLE1BQXhCLEVBQWdDO0FBQzVCLG9CQUFJWCxXQUFXQyxRQUFRRCxRQUFSLENBQWlCd0IsS0FBakIsRUFBZjtBQUFBLG9CQUNJQyxhQUFhekIsU0FBUyxDQUFULENBRGpCO0FBQUEsb0JBRUkwQixhQUFhMUIsU0FBUyxDQUFULENBRmpCO0FBQUEsb0JBR0lHLFVBQVVILFNBQVMsQ0FBVCxDQUhkO0FBQUEsb0JBSUlLLFNBQVNMLFNBQVMsQ0FBVCxDQUpiOztBQU1BLG9CQUFJO0FBQ0Esd0JBQUlDLFFBQVFKLEtBQVIsS0FBa0JMLFFBQXRCLEVBQWdDO0FBQzVCLDRCQUFJLE9BQU9pQyxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ2xDdEIsb0NBQVFzQixXQUFXTCxJQUFYLENBQWdCckIsU0FBaEIsRUFBMkJFLFFBQVFILEtBQW5DLENBQVI7QUFDSCx5QkFGRCxNQUVPO0FBQ0hLLG9DQUFRRixRQUFRSCxLQUFoQjtBQUNIO0FBQ0oscUJBTkQsTUFNTyxJQUFJRyxRQUFRSixLQUFSLEtBQWtCSixRQUF0QixFQUFnQztBQUNuQyw0QkFBSSxPQUFPaUMsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQ3ZCLG9DQUFRdUIsV0FBV04sSUFBWCxDQUFnQnJCLFNBQWhCLEVBQTJCRSxRQUFRSCxLQUFuQyxDQUFSO0FBQ0gseUJBRkQsTUFFTztBQUNITyxtQ0FBT0osUUFBUUgsS0FBZjtBQUNIO0FBQ0o7QUFDSixpQkFkRCxDQWNFLE9BQU9RLENBQVAsRUFBVTtBQUNSRCwyQkFBT0MsQ0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNKLEtBNUJEO0FBNkJILENBaENEOztBQWtDQVUsSUFBSUYsSUFBSixHQUFXLFNBQVNBLElBQVQsQ0FBY1csVUFBZCxFQUEwQkMsVUFBMUIsRUFBc0M7QUFDN0MsUUFBSXpCLFVBQVUsSUFBZDs7QUFFQSxXQUFPLElBQUlOLFNBQUosQ0FBYyxVQUFVUSxPQUFWLEVBQW1CRSxNQUFuQixFQUEyQjtBQUM1Q0osZ0JBQVFELFFBQVIsQ0FBaUIyQixJQUFqQixDQUFzQixDQUFDRixVQUFELEVBQWFDLFVBQWIsRUFBeUJ2QixPQUF6QixFQUFrQ0UsTUFBbEMsQ0FBdEI7QUFDQUosZ0JBQVFvQixNQUFSO0FBQ0gsS0FITSxDQUFQO0FBSUgsQ0FQRDs7QUFTQUwsSUFBSVksS0FBSixHQUFZLFVBQVVGLFVBQVYsRUFBc0I7QUFDOUIsV0FBTyxLQUFLWixJQUFMLENBQVVmLFNBQVYsRUFBcUIyQixVQUFyQixDQUFQO0FBQ0gsQ0FGRDs7QUFJQTs7OztBQUlBLElBQUksT0FBT0csT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNoQ0MsV0FBT0QsT0FBUCxHQUFpQmxDLFNBQWpCO0FBQ0g7O0FBRUQsU0FBU29DLFVBQVQsQ0FBb0JuQyxRQUFwQixFQUE4Qm9DLE9BQTlCLEVBQXVDOztBQUVuQyxRQUFJcEMsb0JBQW9CaUMsT0FBeEIsRUFBaUM7QUFDN0IsYUFBSzVCLE9BQUwsR0FBZUwsUUFBZjtBQUNILEtBRkQsTUFFTztBQUNILGFBQUtLLE9BQUwsR0FBZSxJQUFJNEIsT0FBSixDQUFZakMsU0FBU3FDLElBQVQsQ0FBY0QsT0FBZCxDQUFaLENBQWY7QUFDSDs7QUFFRCxTQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDs7QUFFREQsV0FBV3hCLEdBQVgsR0FBaUIsVUFBVUMsUUFBVixFQUFvQndCLE9BQXBCLEVBQTZCO0FBQzFDLFdBQU8sSUFBSUQsVUFBSixDQUFlRixRQUFRdEIsR0FBUixDQUFZQyxRQUFaLENBQWYsRUFBc0N3QixPQUF0QyxDQUFQO0FBQ0gsQ0FGRDs7QUFJQUQsV0FBVzVCLE9BQVgsR0FBcUIsVUFBVUwsS0FBVixFQUFpQmtDLE9BQWpCLEVBQTBCO0FBQzNDLFdBQU8sSUFBSUQsVUFBSixDQUFlRixRQUFRMUIsT0FBUixDQUFnQkwsS0FBaEIsQ0FBZixFQUF1Q2tDLE9BQXZDLENBQVA7QUFDSCxDQUZEOztBQUlBRCxXQUFXMUIsTUFBWCxHQUFvQixVQUFVaUIsTUFBVixFQUFrQlUsT0FBbEIsRUFBMkI7QUFDM0MsV0FBTyxJQUFJRCxVQUFKLENBQWVGLFFBQVF4QixNQUFSLENBQWVpQixNQUFmLENBQWYsRUFBdUNVLE9BQXZDLENBQVA7QUFDSCxDQUZEOztBQUlBRCxXQUFXaEIsSUFBWCxHQUFrQixVQUFVUCxRQUFWLEVBQW9Cd0IsT0FBcEIsRUFBNkI7QUFDM0MsV0FBTyxJQUFJRCxVQUFKLENBQWVGLFFBQVFkLElBQVIsQ0FBYVAsUUFBYixDQUFmLEVBQXVDd0IsT0FBdkMsQ0FBUDtBQUNILENBRkQ7O0FBSUEsSUFBSUUsSUFBSUgsV0FBV2QsU0FBbkI7O0FBRUFpQixFQUFFRCxJQUFGLEdBQVMsVUFBVUQsT0FBVixFQUFtQjtBQUN4QixTQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxXQUFPLElBQVA7QUFDSCxDQUhEOztBQUtBRSxFQUFFcEIsSUFBRixHQUFTLFVBQVVxQixTQUFWLEVBQXFCQyxRQUFyQixFQUErQjs7QUFFcEMsUUFBSUQsYUFBYUEsVUFBVUYsSUFBdkIsSUFBK0IsS0FBS0QsT0FBeEMsRUFBaUQ7QUFDN0NHLG9CQUFZQSxVQUFVRixJQUFWLENBQWUsS0FBS0QsT0FBcEIsQ0FBWjtBQUNIOztBQUVELFFBQUlJLFlBQVlBLFNBQVNILElBQXJCLElBQTZCLEtBQUtELE9BQXRDLEVBQStDO0FBQzNDSSxtQkFBV0EsU0FBU0gsSUFBVCxDQUFjLEtBQUtELE9BQW5CLENBQVg7QUFDSDs7QUFFRCxXQUFPLElBQUlELFVBQUosQ0FBZSxLQUFLOUIsT0FBTCxDQUFhYSxJQUFiLENBQWtCcUIsU0FBbEIsRUFBNkJDLFFBQTdCLENBQWYsRUFBdUQsS0FBS0osT0FBNUQsQ0FBUDtBQUNILENBWEQ7O0FBYUFFLEVBQUVOLEtBQUYsR0FBVSxVQUFVUSxRQUFWLEVBQW9COztBQUUxQixRQUFJQSxZQUFZQSxTQUFTSCxJQUFyQixJQUE2QixLQUFLRCxPQUF0QyxFQUErQztBQUMzQ0ksbUJBQVdBLFNBQVNILElBQVQsQ0FBYyxLQUFLRCxPQUFuQixDQUFYO0FBQ0g7O0FBRUQsV0FBTyxJQUFJRCxVQUFKLENBQWUsS0FBSzlCLE9BQUwsQ0FBYTJCLEtBQWIsQ0FBbUJRLFFBQW5CLENBQWYsRUFBNkMsS0FBS0osT0FBbEQsQ0FBUDtBQUNILENBUEQ7O0FBU0FFLEVBQUVHLE9BQUYsR0FBWSxVQUFVQyxRQUFWLEVBQW9COztBQUU1QixXQUFPLEtBQUt4QixJQUFMLENBQVUsVUFBVWhCLEtBQVYsRUFBaUI7QUFDMUJ3QyxpQkFBU2xCLElBQVQsQ0FBYyxJQUFkO0FBQ0EsZUFBT3RCLEtBQVA7QUFDSCxLQUhFLEVBR0EsVUFBVXdCLE1BQVYsRUFBa0I7QUFDakJnQixpQkFBU2xCLElBQVQsQ0FBYyxJQUFkO0FBQ0EsZUFBT1MsUUFBUXhCLE1BQVIsQ0FBZWlCLE1BQWYsQ0FBUDtBQUNILEtBTkUsQ0FBUDtBQVFILENBVkQ7O0FBWUE7Ozs7QUFJQSxJQUFJaUIsTUFBTSxFQUFWO0FBQ0EsSUFBSUMsaUJBQWlCRCxJQUFJQyxjQUF6Qjs7QUFFQSxJQUFJQyxRQUFRLEVBQVo7QUFDQSxJQUFJQyxRQUFRRCxNQUFNQyxLQUFsQjtBQUNBLElBQUlDLFFBQVEsS0FBWjtBQUNBLElBQUlDLEtBQUo7O0FBRUEsSUFBSUMsWUFBWSxPQUFPZixNQUFQLEtBQWtCLFdBQWxDOztBQUVBLElBQUlnQixPQUFPLFNBQVBBLElBQU8sQ0FBVVAsR0FBVixFQUFlO0FBQ3RCLFFBQUlRLFNBQVNSLElBQUlRLE1BQWpCO0FBQ0EsUUFBSXhCLFdBQVdnQixJQUFJaEIsUUFBbkI7O0FBRUFxQixZQUFRckIsUUFBUjtBQUNBb0IsWUFBUUksT0FBT0osS0FBUCxJQUFnQixDQUFDSSxPQUFPQyxNQUFoQztBQUNILENBTkQ7O0FBUUEsU0FBU0MsSUFBVCxDQUFjQyxHQUFkLEVBQW1CO0FBQ2YsUUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDUixLQUF0QyxFQUE2QztBQUN6Q1EsZ0JBQVFGLElBQVIsQ0FBYSx5QkFBeUJDLEdBQXRDO0FBQ0g7QUFDSjs7QUFFRCxTQUFTRSxLQUFULENBQWVGLEdBQWYsRUFBb0I7QUFDaEIsUUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2hDQSxnQkFBUUMsS0FBUixDQUFjRixHQUFkO0FBQ0g7QUFDSjs7QUFFRCxTQUFTM0IsUUFBVCxDQUFrQjhCLEVBQWxCLEVBQXNCQyxHQUF0QixFQUEyQjtBQUN2QixXQUFPVixNQUFNUyxFQUFOLEVBQVVDLEdBQVYsQ0FBUDtBQUNIOztBQUVELFNBQVNDLElBQVQsQ0FBY0MsR0FBZCxFQUFtQjtBQUNmLFdBQU9BLE1BQU1BLElBQUlDLE9BQUosQ0FBWSxZQUFaLEVBQTBCLEVBQTFCLENBQU4sR0FBc0MsRUFBN0M7QUFDSDs7QUFFRCxTQUFTQyxPQUFULENBQWlCRixHQUFqQixFQUFzQjtBQUNsQixXQUFPQSxNQUFNQSxJQUFJRyxXQUFKLEVBQU4sR0FBMEIsRUFBakM7QUFDSDs7QUFFRCxTQUFTQyxPQUFULENBQWlCSixHQUFqQixFQUFzQjtBQUNsQixXQUFPQSxNQUFNQSxJQUFJSyxXQUFKLEVBQU4sR0FBMEIsRUFBakM7QUFDSDs7QUFFRCxJQUFJQyxVQUFVQyxNQUFNRCxPQUFwQjs7QUFFQSxTQUFTRSxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNuQixXQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUF0QjtBQUNIOztBQUlELFNBQVNDLFVBQVQsQ0FBb0JELEdBQXBCLEVBQXlCO0FBQ3JCLFdBQU8sT0FBT0EsR0FBUCxLQUFlLFVBQXRCO0FBQ0g7O0FBRUQsU0FBU0UsUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDbkIsV0FBT0EsUUFBUSxJQUFSLElBQWdCLFFBQU9BLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUF0QztBQUNIOztBQUVELFNBQVNDLGFBQVQsQ0FBdUJELEdBQXZCLEVBQTRCO0FBQ3hCLFdBQU9ELFNBQVNDLEdBQVQsS0FBaUJFLE9BQU9DLGNBQVAsQ0FBc0JILEdBQXRCLEtBQThCRSxPQUFPckQsU0FBN0Q7QUFDSDs7QUFFRCxTQUFTdUQsTUFBVCxDQUFnQkosR0FBaEIsRUFBcUI7QUFDakIsV0FBTyxPQUFPSyxJQUFQLEtBQWdCLFdBQWhCLElBQStCTCxlQUFlSyxJQUFyRDtBQUNIOztBQUVELFNBQVNDLFVBQVQsQ0FBb0JOLEdBQXBCLEVBQXlCO0FBQ3JCLFdBQU8sT0FBT08sUUFBUCxLQUFvQixXQUFwQixJQUFtQ1AsZUFBZU8sUUFBekQ7QUFDSDs7QUFFRCxTQUFTQyxJQUFULENBQWM5RSxLQUFkLEVBQXFCcUMsU0FBckIsRUFBZ0NDLFFBQWhDLEVBQTBDOztBQUV0QyxRQUFJbkMsVUFBVThCLFdBQVc1QixPQUFYLENBQW1CTCxLQUFuQixDQUFkOztBQUVBLFFBQUkrRSxVQUFVbEUsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixlQUFPVixPQUFQO0FBQ0g7O0FBRUQsV0FBT0EsUUFBUWEsSUFBUixDQUFhcUIsU0FBYixFQUF3QkMsUUFBeEIsQ0FBUDtBQUNIOztBQUVELFNBQVMwQyxPQUFULENBQWlCQyxFQUFqQixFQUFxQlgsR0FBckIsRUFBMEJZLElBQTFCLEVBQWdDOztBQUU1QkEsV0FBT0EsUUFBUSxFQUFmOztBQUVBLFFBQUlkLFdBQVdjLElBQVgsQ0FBSixFQUFzQjtBQUNsQkEsZUFBT0EsS0FBSzVELElBQUwsQ0FBVWdELEdBQVYsQ0FBUDtBQUNIOztBQUVELFdBQU9hLE1BQU1GLEdBQUc5QyxJQUFILENBQVEsRUFBQ2lELEtBQUtkLEdBQU4sRUFBV2UsVUFBVUgsSUFBckIsRUFBUixDQUFOLEVBQTJDRCxFQUEzQyxFQUErQyxFQUFDSSxVQUFVSCxJQUFYLEVBQS9DLENBQVA7QUFDSDs7QUFFRCxTQUFTSSxJQUFULENBQWNoQixHQUFkLEVBQW1CaUIsUUFBbkIsRUFBNkI7O0FBRXpCLFFBQUl4RSxDQUFKLEVBQU95RSxHQUFQOztBQUVBLFFBQUl4QixRQUFRTSxHQUFSLENBQUosRUFBa0I7QUFDZCxhQUFLdkQsSUFBSSxDQUFULEVBQVlBLElBQUl1RCxJQUFJekQsTUFBcEIsRUFBNEJFLEdBQTVCLEVBQWlDO0FBQzdCd0UscUJBQVNqRSxJQUFULENBQWNnRCxJQUFJdkQsQ0FBSixDQUFkLEVBQXNCdUQsSUFBSXZELENBQUosQ0FBdEIsRUFBOEJBLENBQTlCO0FBQ0g7QUFDSixLQUpELE1BSU8sSUFBSXNELFNBQVNDLEdBQVQsQ0FBSixFQUFtQjtBQUN0QixhQUFLa0IsR0FBTCxJQUFZbEIsR0FBWixFQUFpQjtBQUNiLGdCQUFJNUIsZUFBZXBCLElBQWYsQ0FBb0JnRCxHQUFwQixFQUF5QmtCLEdBQXpCLENBQUosRUFBbUM7QUFDL0JELHlCQUFTakUsSUFBVCxDQUFjZ0QsSUFBSWtCLEdBQUosQ0FBZCxFQUF3QmxCLElBQUlrQixHQUFKLENBQXhCLEVBQWtDQSxHQUFsQztBQUNIO0FBQ0o7QUFDSjs7QUFFRCxXQUFPbEIsR0FBUDtBQUNIOztBQUVELElBQUltQixTQUFTakIsT0FBT2lCLE1BQVAsSUFBaUJDLE9BQTlCOztBQUVBLFNBQVNQLEtBQVQsQ0FBZVEsTUFBZixFQUF1Qjs7QUFFbkIsUUFBSUMsT0FBT2hELE1BQU10QixJQUFOLENBQVd5RCxTQUFYLEVBQXNCLENBQXRCLENBQVg7O0FBRUFhLFNBQUtDLE9BQUwsQ0FBYSxVQUFVQyxNQUFWLEVBQWtCO0FBQzNCQyxlQUFPSixNQUFQLEVBQWVHLE1BQWYsRUFBdUIsSUFBdkI7QUFDSCxLQUZEOztBQUlBLFdBQU9ILE1BQVA7QUFDSDs7QUFFRCxTQUFTSyxRQUFULENBQWtCTCxNQUFsQixFQUEwQjs7QUFFdEIsUUFBSUMsT0FBT2hELE1BQU10QixJQUFOLENBQVd5RCxTQUFYLEVBQXNCLENBQXRCLENBQVg7O0FBRUFhLFNBQUtDLE9BQUwsQ0FBYSxVQUFVQyxNQUFWLEVBQWtCOztBQUUzQixhQUFLLElBQUlOLEdBQVQsSUFBZ0JNLE1BQWhCLEVBQXdCO0FBQ3BCLGdCQUFJSCxPQUFPSCxHQUFQLE1BQWdCdkYsU0FBcEIsRUFBK0I7QUFDM0IwRix1QkFBT0gsR0FBUCxJQUFjTSxPQUFPTixHQUFQLENBQWQ7QUFDSDtBQUNKO0FBRUosS0FSRDs7QUFVQSxXQUFPRyxNQUFQO0FBQ0g7O0FBRUQsU0FBU0QsT0FBVCxDQUFpQkMsTUFBakIsRUFBeUI7O0FBRXJCLFFBQUlDLE9BQU9oRCxNQUFNdEIsSUFBTixDQUFXeUQsU0FBWCxFQUFzQixDQUF0QixDQUFYOztBQUVBYSxTQUFLQyxPQUFMLENBQWEsVUFBVUMsTUFBVixFQUFrQjtBQUMzQkMsZUFBT0osTUFBUCxFQUFlRyxNQUFmO0FBQ0gsS0FGRDs7QUFJQSxXQUFPSCxNQUFQO0FBQ0g7O0FBRUQsU0FBU0ksTUFBVCxDQUFnQkosTUFBaEIsRUFBd0JHLE1BQXhCLEVBQWdDRyxJQUFoQyxFQUFzQztBQUNsQyxTQUFLLElBQUlULEdBQVQsSUFBZ0JNLE1BQWhCLEVBQXdCO0FBQ3BCLFlBQUlHLFNBQVMxQixjQUFjdUIsT0FBT04sR0FBUCxDQUFkLEtBQThCeEIsUUFBUThCLE9BQU9OLEdBQVAsQ0FBUixDQUF2QyxDQUFKLEVBQWtFO0FBQzlELGdCQUFJakIsY0FBY3VCLE9BQU9OLEdBQVAsQ0FBZCxLQUE4QixDQUFDakIsY0FBY29CLE9BQU9ILEdBQVAsQ0FBZCxDQUFuQyxFQUErRDtBQUMzREcsdUJBQU9ILEdBQVAsSUFBYyxFQUFkO0FBQ0g7QUFDRCxnQkFBSXhCLFFBQVE4QixPQUFPTixHQUFQLENBQVIsS0FBd0IsQ0FBQ3hCLFFBQVEyQixPQUFPSCxHQUFQLENBQVIsQ0FBN0IsRUFBbUQ7QUFDL0NHLHVCQUFPSCxHQUFQLElBQWMsRUFBZDtBQUNIO0FBQ0RPLG1CQUFPSixPQUFPSCxHQUFQLENBQVAsRUFBb0JNLE9BQU9OLEdBQVAsQ0FBcEIsRUFBaUNTLElBQWpDO0FBQ0gsU0FSRCxNQVFPLElBQUlILE9BQU9OLEdBQVAsTUFBZ0J2RixTQUFwQixFQUErQjtBQUNsQzBGLG1CQUFPSCxHQUFQLElBQWNNLE9BQU9OLEdBQVAsQ0FBZDtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7OztBQUlBLElBQUlVLE9BQU8sU0FBUEEsSUFBTyxDQUFVQyxVQUFWLEVBQXNCQyxJQUF0QixFQUE0Qjs7QUFFbkMsUUFBSUMsTUFBTUQsS0FBS0QsVUFBTCxDQUFWOztBQUVBLFFBQUlqQyxTQUFTaUMsV0FBV0QsSUFBcEIsS0FBNkIsQ0FBQ0csSUFBSUMsS0FBSixDQUFVLGVBQVYsQ0FBbEMsRUFBOEQ7QUFDMURELGNBQU1GLFdBQVdELElBQVgsR0FBa0IsR0FBbEIsR0FBd0JHLEdBQTlCO0FBQ0g7O0FBRUQsV0FBT0EsR0FBUDtBQUNILENBVEQ7O0FBV0E7Ozs7QUFJQSxJQUFJRSxRQUFRLGVBQVVKLFVBQVYsRUFBc0JDLElBQXRCLEVBQTRCOztBQUVwQyxRQUFJSSxZQUFZaEMsT0FBT2lDLElBQVAsQ0FBWUMsSUFBSTFCLE9BQUosQ0FBWTJCLE1BQXhCLENBQWhCO0FBQUEsUUFBaURKLFFBQVEsRUFBekQ7QUFBQSxRQUE2REYsTUFBTUQsS0FBS0QsVUFBTCxDQUFuRTs7QUFFQWIsU0FBS2EsV0FBV1EsTUFBaEIsRUFBd0IsVUFBVTNHLEtBQVYsRUFBaUJ3RixHQUFqQixFQUFzQjtBQUMxQyxZQUFJZ0IsVUFBVUksT0FBVixDQUFrQnBCLEdBQWxCLE1BQTJCLENBQUMsQ0FBaEMsRUFBbUM7QUFDL0JlLGtCQUFNZixHQUFOLElBQWF4RixLQUFiO0FBQ0g7QUFDSixLQUpEOztBQU1BdUcsWUFBUUcsSUFBSUMsTUFBSixDQUFXSixLQUFYLENBQVI7O0FBRUEsUUFBSUEsS0FBSixFQUFXO0FBQ1BGLGVBQU8sQ0FBQ0EsSUFBSU8sT0FBSixDQUFZLEdBQVosS0FBb0IsQ0FBQyxDQUFyQixHQUF5QixHQUF6QixHQUErQixHQUFoQyxJQUF1Q0wsS0FBOUM7QUFDSDs7QUFFRCxXQUFPRixHQUFQO0FBQ0gsQ0FqQkQ7O0FBbUJBOzs7O0FBSUEsU0FBU1EsTUFBVCxDQUFnQlIsR0FBaEIsRUFBcUJNLE1BQXJCLEVBQTZCRyxTQUE3QixFQUF3Qzs7QUFFcEMsUUFBSUMsT0FBT0MsTUFBTVgsR0FBTixDQUFYO0FBQUEsUUFBdUJZLFdBQVdGLEtBQUtGLE1BQUwsQ0FBWUYsTUFBWixDQUFsQzs7QUFFQSxRQUFJRyxTQUFKLEVBQWU7QUFDWEEsa0JBQVVqRixJQUFWLENBQWVxRixLQUFmLENBQXFCSixTQUFyQixFQUFnQ0MsS0FBS0ksSUFBckM7QUFDSDs7QUFFRCxXQUFPRixRQUFQO0FBQ0g7O0FBRUQsU0FBU0QsS0FBVCxDQUFlSSxRQUFmLEVBQXlCOztBQUVyQixRQUFJQyxZQUFZLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCLEdBQTFCLEVBQStCLEdBQS9CLENBQWhCO0FBQUEsUUFBcURQLFlBQVksRUFBakU7O0FBRUEsV0FBTztBQUNISyxjQUFNTCxTQURIO0FBRUhELGdCQUFRLFNBQVNBLE1BQVQsQ0FBZ0IzRSxPQUFoQixFQUF5QjtBQUM3QixtQkFBT2tGLFNBQVN6RCxPQUFULENBQWlCLDRCQUFqQixFQUErQyxVQUFVMkQsQ0FBVixFQUFhQyxVQUFiLEVBQXlCQyxPQUF6QixFQUFrQztBQUNwRixvQkFBSUQsVUFBSixFQUFnQjs7QUFFWix3QkFBSUUsV0FBVyxJQUFmO0FBQUEsd0JBQXFCQyxTQUFTLEVBQTlCOztBQUVBLHdCQUFJTCxVQUFVVCxPQUFWLENBQWtCVyxXQUFXSSxNQUFYLENBQWtCLENBQWxCLENBQWxCLE1BQTRDLENBQUMsQ0FBakQsRUFBb0Q7QUFDaERGLG1DQUFXRixXQUFXSSxNQUFYLENBQWtCLENBQWxCLENBQVg7QUFDQUoscUNBQWFBLFdBQVdLLE1BQVgsQ0FBa0IsQ0FBbEIsQ0FBYjtBQUNIOztBQUVETCwrQkFBV00sS0FBWCxDQUFpQixJQUFqQixFQUF1QmhDLE9BQXZCLENBQStCLFVBQVVpQyxRQUFWLEVBQW9CO0FBQy9DLDRCQUFJQyxNQUFNLDRCQUE0QkMsSUFBNUIsQ0FBaUNGLFFBQWpDLENBQVY7QUFDQUosK0JBQU83RixJQUFQLENBQVlxRixLQUFaLENBQWtCUSxNQUFsQixFQUEwQk8sVUFBVS9GLE9BQVYsRUFBbUJ1RixRQUFuQixFQUE2Qk0sSUFBSSxDQUFKLENBQTdCLEVBQXFDQSxJQUFJLENBQUosS0FBVUEsSUFBSSxDQUFKLENBQS9DLENBQTFCO0FBQ0FqQixrQ0FBVWpGLElBQVYsQ0FBZWtHLElBQUksQ0FBSixDQUFmO0FBQ0gscUJBSkQ7O0FBTUEsd0JBQUlOLFlBQVlBLGFBQWEsR0FBN0IsRUFBa0M7O0FBRTlCLDRCQUFJUyxZQUFZLEdBQWhCOztBQUVBLDRCQUFJVCxhQUFhLEdBQWpCLEVBQXNCO0FBQ2xCUyx3Q0FBWSxHQUFaO0FBQ0gseUJBRkQsTUFFTyxJQUFJVCxhQUFhLEdBQWpCLEVBQXNCO0FBQ3pCUyx3Q0FBWVQsUUFBWjtBQUNIOztBQUVELCtCQUFPLENBQUNDLE9BQU83RyxNQUFQLEtBQWtCLENBQWxCLEdBQXNCNEcsUUFBdEIsR0FBaUMsRUFBbEMsSUFBd0NDLE9BQU9TLElBQVAsQ0FBWUQsU0FBWixDQUEvQztBQUNILHFCQVhELE1BV087QUFDSCwrQkFBT1IsT0FBT1MsSUFBUCxDQUFZLEdBQVosQ0FBUDtBQUNIO0FBRUosaUJBOUJELE1BOEJPO0FBQ0gsMkJBQU9DLGVBQWVaLE9BQWYsQ0FBUDtBQUNIO0FBQ0osYUFsQ00sQ0FBUDtBQW1DSDtBQXRDRSxLQUFQO0FBd0NIOztBQUVELFNBQVNTLFNBQVQsQ0FBbUIvRixPQUFuQixFQUE0QnVGLFFBQTVCLEVBQXNDakMsR0FBdEMsRUFBMkM2QyxRQUEzQyxFQUFxRDs7QUFFakQsUUFBSXJJLFFBQVFrQyxRQUFRc0QsR0FBUixDQUFaO0FBQUEsUUFBMEI1RSxTQUFTLEVBQW5DOztBQUVBLFFBQUkwSCxVQUFVdEksS0FBVixLQUFvQkEsVUFBVSxFQUFsQyxFQUFzQztBQUNsQyxZQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsT0FBT0EsS0FBUCxLQUFpQixRQUE5QyxJQUEwRCxPQUFPQSxLQUFQLEtBQWlCLFNBQS9FLEVBQTBGO0FBQ3RGQSxvQkFBUUEsTUFBTXVJLFFBQU4sRUFBUjs7QUFFQSxnQkFBSUYsWUFBWUEsYUFBYSxHQUE3QixFQUFrQztBQUM5QnJJLHdCQUFRQSxNQUFNd0ksU0FBTixDQUFnQixDQUFoQixFQUFtQkMsU0FBU0osUUFBVCxFQUFtQixFQUFuQixDQUFuQixDQUFSO0FBQ0g7O0FBRUR6SCxtQkFBT2lCLElBQVAsQ0FBWTZHLFlBQVlqQixRQUFaLEVBQXNCekgsS0FBdEIsRUFBNkIySSxjQUFjbEIsUUFBZCxJQUEwQmpDLEdBQTFCLEdBQWdDLElBQTdELENBQVo7QUFDSCxTQVJELE1BUU87QUFDSCxnQkFBSTZDLGFBQWEsR0FBakIsRUFBc0I7QUFDbEIsb0JBQUlwRSxNQUFNRCxPQUFOLENBQWNoRSxLQUFkLENBQUosRUFBMEI7QUFDdEJBLDBCQUFNNEksTUFBTixDQUFhTixTQUFiLEVBQXdCekMsT0FBeEIsQ0FBZ0MsVUFBVTdGLEtBQVYsRUFBaUI7QUFDN0NZLCtCQUFPaUIsSUFBUCxDQUFZNkcsWUFBWWpCLFFBQVosRUFBc0J6SCxLQUF0QixFQUE2QjJJLGNBQWNsQixRQUFkLElBQTBCakMsR0FBMUIsR0FBZ0MsSUFBN0QsQ0FBWjtBQUNILHFCQUZEO0FBR0gsaUJBSkQsTUFJTztBQUNIaEIsMkJBQU9pQyxJQUFQLENBQVl6RyxLQUFaLEVBQW1CNkYsT0FBbkIsQ0FBMkIsVUFBVWdELENBQVYsRUFBYTtBQUNwQyw0QkFBSVAsVUFBVXRJLE1BQU02SSxDQUFOLENBQVYsQ0FBSixFQUF5QjtBQUNyQmpJLG1DQUFPaUIsSUFBUCxDQUFZNkcsWUFBWWpCLFFBQVosRUFBc0J6SCxNQUFNNkksQ0FBTixDQUF0QixFQUFnQ0EsQ0FBaEMsQ0FBWjtBQUNIO0FBQ0oscUJBSkQ7QUFLSDtBQUNKLGFBWkQsTUFZTztBQUNILG9CQUFJZCxNQUFNLEVBQVY7O0FBRUEsb0JBQUk5RCxNQUFNRCxPQUFOLENBQWNoRSxLQUFkLENBQUosRUFBMEI7QUFDdEJBLDBCQUFNNEksTUFBTixDQUFhTixTQUFiLEVBQXdCekMsT0FBeEIsQ0FBZ0MsVUFBVTdGLEtBQVYsRUFBaUI7QUFDN0MrSCw0QkFBSWxHLElBQUosQ0FBUzZHLFlBQVlqQixRQUFaLEVBQXNCekgsS0FBdEIsQ0FBVDtBQUNILHFCQUZEO0FBR0gsaUJBSkQsTUFJTztBQUNId0UsMkJBQU9pQyxJQUFQLENBQVl6RyxLQUFaLEVBQW1CNkYsT0FBbkIsQ0FBMkIsVUFBVWdELENBQVYsRUFBYTtBQUNwQyw0QkFBSVAsVUFBVXRJLE1BQU02SSxDQUFOLENBQVYsQ0FBSixFQUF5QjtBQUNyQmQsZ0NBQUlsRyxJQUFKLENBQVNpSCxtQkFBbUJELENBQW5CLENBQVQ7QUFDQWQsZ0NBQUlsRyxJQUFKLENBQVM2RyxZQUFZakIsUUFBWixFQUFzQnpILE1BQU02SSxDQUFOLEVBQVNOLFFBQVQsRUFBdEIsQ0FBVDtBQUNIO0FBQ0oscUJBTEQ7QUFNSDs7QUFFRCxvQkFBSUksY0FBY2xCLFFBQWQsQ0FBSixFQUE2QjtBQUN6QjdHLDJCQUFPaUIsSUFBUCxDQUFZaUgsbUJBQW1CdEQsR0FBbkIsSUFBMEIsR0FBMUIsR0FBZ0N1QyxJQUFJSSxJQUFKLENBQVMsR0FBVCxDQUE1QztBQUNILGlCQUZELE1BRU8sSUFBSUosSUFBSWxILE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUN6QkQsMkJBQU9pQixJQUFQLENBQVlrRyxJQUFJSSxJQUFKLENBQVMsR0FBVCxDQUFaO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0E3Q0QsTUE2Q087QUFDSCxZQUFJVixhQUFhLEdBQWpCLEVBQXNCO0FBQ2xCN0csbUJBQU9pQixJQUFQLENBQVlpSCxtQkFBbUJ0RCxHQUFuQixDQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUl4RixVQUFVLEVBQVYsS0FBaUJ5SCxhQUFhLEdBQWIsSUFBb0JBLGFBQWEsR0FBbEQsQ0FBSixFQUE0RDtBQUMvRDdHLG1CQUFPaUIsSUFBUCxDQUFZaUgsbUJBQW1CdEQsR0FBbkIsSUFBMEIsR0FBdEM7QUFDSCxTQUZNLE1BRUEsSUFBSXhGLFVBQVUsRUFBZCxFQUFrQjtBQUNyQlksbUJBQU9pQixJQUFQLENBQVksRUFBWjtBQUNIO0FBQ0o7O0FBRUQsV0FBT2pCLE1BQVA7QUFDSDs7QUFFRCxTQUFTMEgsU0FBVCxDQUFtQnRJLEtBQW5CLEVBQTBCO0FBQ3RCLFdBQU9BLFVBQVVDLFNBQVYsSUFBdUJELFVBQVUsSUFBeEM7QUFDSDs7QUFFRCxTQUFTMkksYUFBVCxDQUF1QmxCLFFBQXZCLEVBQWlDO0FBQzdCLFdBQU9BLGFBQWEsR0FBYixJQUFvQkEsYUFBYSxHQUFqQyxJQUF3Q0EsYUFBYSxHQUE1RDtBQUNIOztBQUVELFNBQVNpQixXQUFULENBQXFCakIsUUFBckIsRUFBK0J6SCxLQUEvQixFQUFzQ3dGLEdBQXRDLEVBQTJDOztBQUV2Q3hGLFlBQVN5SCxhQUFhLEdBQWIsSUFBb0JBLGFBQWEsR0FBbEMsR0FBeUNXLGVBQWVwSSxLQUFmLENBQXpDLEdBQWlFOEksbUJBQW1COUksS0FBbkIsQ0FBekU7O0FBRUEsUUFBSXdGLEdBQUosRUFBUztBQUNMLGVBQU9zRCxtQkFBbUJ0RCxHQUFuQixJQUEwQixHQUExQixHQUFnQ3hGLEtBQXZDO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBT0EsS0FBUDtBQUNIO0FBQ0o7O0FBRUQsU0FBU29JLGNBQVQsQ0FBd0IxRSxHQUF4QixFQUE2QjtBQUN6QixXQUFPQSxJQUFJbUUsS0FBSixDQUFVLG9CQUFWLEVBQWdDa0IsR0FBaEMsQ0FBb0MsVUFBVUMsSUFBVixFQUFnQjtBQUN2RCxZQUFJLENBQUMsZUFBZUMsSUFBZixDQUFvQkQsSUFBcEIsQ0FBTCxFQUFnQztBQUM1QkEsbUJBQU9FLFVBQVVGLElBQVYsQ0FBUDtBQUNIO0FBQ0QsZUFBT0EsSUFBUDtBQUNILEtBTE0sRUFLSmIsSUFMSSxDQUtDLEVBTEQsQ0FBUDtBQU1IOztBQUVEOzs7O0FBSUEsSUFBSWYsV0FBVyxTQUFYQSxRQUFXLENBQVVwQyxPQUFWLEVBQW1COztBQUU5QixRQUFJOEIsWUFBWSxFQUFoQjtBQUFBLFFBQW9CVCxNQUFNUSxPQUFPN0IsUUFBUXFCLEdBQWYsRUFBb0JyQixRQUFRMkIsTUFBNUIsRUFBb0NHLFNBQXBDLENBQTFCOztBQUVBQSxjQUFVakIsT0FBVixDQUFrQixVQUFVTCxHQUFWLEVBQWU7QUFDN0IsZUFBT1IsUUFBUTJCLE1BQVIsQ0FBZW5CLEdBQWYsQ0FBUDtBQUNILEtBRkQ7O0FBSUEsV0FBT2EsR0FBUDtBQUNILENBVEQ7O0FBV0E7Ozs7QUFJQSxTQUFTSyxHQUFULENBQWFMLEdBQWIsRUFBa0JNLE1BQWxCLEVBQTBCOztBQUV0QixRQUFJd0MsT0FBTyxRQUFRLEVBQW5CO0FBQUEsUUFBdUJoRCxhQUFhRSxHQUFwQztBQUFBLFFBQXlDK0MsU0FBekM7O0FBRUEsUUFBSWxGLFNBQVNtQyxHQUFULENBQUosRUFBbUI7QUFDZkYscUJBQWEsRUFBQ0UsS0FBS0EsR0FBTixFQUFXTSxRQUFRQSxNQUFuQixFQUFiO0FBQ0g7O0FBRURSLGlCQUFhaEIsTUFBTSxFQUFOLEVBQVV1QixJQUFJMUIsT0FBZCxFQUF1Qm1FLEtBQUs5RCxRQUE1QixFQUFzQ2MsVUFBdEMsQ0FBYjs7QUFFQU8sUUFBSTJDLFVBQUosQ0FBZXhELE9BQWYsQ0FBdUIsVUFBVXlELE9BQVYsRUFBbUI7O0FBRXRDLFlBQUlwRixTQUFTb0YsT0FBVCxDQUFKLEVBQXVCO0FBQ25CQSxzQkFBVTVDLElBQUkwQyxTQUFKLENBQWNFLE9BQWQsQ0FBVjtBQUNIOztBQUVELFlBQUlsRixXQUFXa0YsT0FBWCxDQUFKLEVBQXlCO0FBQ3JCRix3QkFBWUcsUUFBUUQsT0FBUixFQUFpQkYsU0FBakIsRUFBNEJELEtBQUsvRCxHQUFqQyxDQUFaO0FBQ0g7QUFFSixLQVZEOztBQVlBLFdBQU9nRSxVQUFVakQsVUFBVixDQUFQO0FBQ0g7O0FBRUQ7Ozs7QUFJQU8sSUFBSTFCLE9BQUosR0FBYztBQUNWcUIsU0FBSyxFQURLO0FBRVZILFVBQU0sSUFGSTtBQUdWUyxZQUFRO0FBSEUsQ0FBZDs7QUFNQTs7OztBQUlBRCxJQUFJMEMsU0FBSixHQUFnQixFQUFDaEMsVUFBVUEsUUFBWCxFQUFxQmIsT0FBT0EsS0FBNUIsRUFBbUNMLE1BQU1BLElBQXpDLEVBQWhCO0FBQ0FRLElBQUkyQyxVQUFKLEdBQWlCLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsTUFBdEIsQ0FBakI7O0FBRUE7Ozs7OztBQU1BM0MsSUFBSUMsTUFBSixHQUFhLFVBQVVyQyxHQUFWLEVBQWU7O0FBRXhCLFFBQUlxQyxTQUFTLEVBQWI7QUFBQSxRQUFpQjZDLFNBQVNWLGtCQUExQjs7QUFFQW5DLFdBQU84QyxHQUFQLEdBQWEsVUFBVWpFLEdBQVYsRUFBZXhGLEtBQWYsRUFBc0I7O0FBRS9CLFlBQUlvRSxXQUFXcEUsS0FBWCxDQUFKLEVBQXVCO0FBQ25CQSxvQkFBUUEsT0FBUjtBQUNIOztBQUVELFlBQUlBLFVBQVUsSUFBZCxFQUFvQjtBQUNoQkEsb0JBQVEsRUFBUjtBQUNIOztBQUVELGFBQUs2QixJQUFMLENBQVUySCxPQUFPaEUsR0FBUCxJQUFjLEdBQWQsR0FBb0JnRSxPQUFPeEosS0FBUCxDQUE5QjtBQUNILEtBWEQ7O0FBYUEwSixjQUFVL0MsTUFBVixFQUFrQnJDLEdBQWxCOztBQUVBLFdBQU9xQyxPQUFPd0IsSUFBUCxDQUFZLEdBQVosRUFBaUJ4RSxPQUFqQixDQUF5QixNQUF6QixFQUFpQyxHQUFqQyxDQUFQO0FBQ0gsQ0FwQkQ7O0FBc0JBOzs7Ozs7QUFNQStDLElBQUlNLEtBQUosR0FBWSxVQUFVWCxHQUFWLEVBQWU7O0FBRXZCLFFBQUlzRCxLQUFLQyxTQUFTQyxhQUFULENBQXVCLEdBQXZCLENBQVQ7O0FBRUEsUUFBSUQsU0FBU0UsWUFBYixFQUEyQjtBQUN2QkgsV0FBR0ksSUFBSCxHQUFVMUQsR0FBVjtBQUNBQSxjQUFNc0QsR0FBR0ksSUFBVDtBQUNIOztBQUVESixPQUFHSSxJQUFILEdBQVUxRCxHQUFWOztBQUVBLFdBQU87QUFDSDBELGNBQU1KLEdBQUdJLElBRE47QUFFSEMsa0JBQVVMLEdBQUdLLFFBQUgsR0FBY0wsR0FBR0ssUUFBSCxDQUFZckcsT0FBWixDQUFvQixJQUFwQixFQUEwQixFQUExQixDQUFkLEdBQThDLEVBRnJEO0FBR0hzRyxjQUFNTixHQUFHTSxJQUhOO0FBSUhDLGNBQU1QLEdBQUdPLElBSk47QUFLSEMsa0JBQVVSLEdBQUdRLFFBTFY7QUFNSEMsa0JBQVVULEdBQUdTLFFBQUgsQ0FBWXpDLE1BQVosQ0FBbUIsQ0FBbkIsTUFBMEIsR0FBMUIsR0FBZ0NnQyxHQUFHUyxRQUFuQyxHQUE4QyxNQUFNVCxHQUFHUyxRQU45RDtBQU9IQyxnQkFBUVYsR0FBR1UsTUFBSCxHQUFZVixHQUFHVSxNQUFILENBQVUxRyxPQUFWLENBQWtCLEtBQWxCLEVBQXlCLEVBQXpCLENBQVosR0FBMkMsRUFQaEQ7QUFRSDJHLGNBQU1YLEdBQUdXLElBQUgsR0FBVVgsR0FBR1csSUFBSCxDQUFRM0csT0FBUixDQUFnQixJQUFoQixFQUFzQixFQUF0QixDQUFWLEdBQXNDO0FBUnpDLEtBQVA7QUFVSCxDQXJCRDs7QUF1QkEsU0FBUzRGLE9BQVQsQ0FBaUJELE9BQWpCLEVBQTBCbEQsSUFBMUIsRUFBZ0NtRSxFQUFoQyxFQUFvQztBQUNoQyxXQUFPLFVBQVVwRSxVQUFWLEVBQXNCO0FBQ3pCLGVBQU9tRCxRQUFRaEksSUFBUixDQUFhaUosRUFBYixFQUFpQnBFLFVBQWpCLEVBQTZCQyxJQUE3QixDQUFQO0FBQ0gsS0FGRDtBQUdIOztBQUVELFNBQVNzRCxTQUFULENBQW1CL0MsTUFBbkIsRUFBMkJyQyxHQUEzQixFQUFnQ2tHLEtBQWhDLEVBQXVDOztBQUVuQyxRQUFJQyxRQUFRekcsUUFBUU0sR0FBUixDQUFaO0FBQUEsUUFBMEJvRyxRQUFRbkcsY0FBY0QsR0FBZCxDQUFsQztBQUFBLFFBQXNEZ0csSUFBdEQ7O0FBRUFoRixTQUFLaEIsR0FBTCxFQUFVLFVBQVV0RSxLQUFWLEVBQWlCd0YsR0FBakIsRUFBc0I7O0FBRTVCOEUsZUFBT2pHLFNBQVNyRSxLQUFULEtBQW1CZ0UsUUFBUWhFLEtBQVIsQ0FBMUI7O0FBRUEsWUFBSXdLLEtBQUosRUFBVztBQUNQaEYsa0JBQU1nRixRQUFRLEdBQVIsSUFBZUUsU0FBU0osSUFBVCxHQUFnQjlFLEdBQWhCLEdBQXNCLEVBQXJDLElBQTJDLEdBQWpEO0FBQ0g7O0FBRUQsWUFBSSxDQUFDZ0YsS0FBRCxJQUFVQyxLQUFkLEVBQXFCO0FBQ2pCOUQsbUJBQU84QyxHQUFQLENBQVd6SixNQUFNMkssSUFBakIsRUFBdUIzSyxNQUFNQSxLQUE3QjtBQUNILFNBRkQsTUFFTyxJQUFJc0ssSUFBSixFQUFVO0FBQ2JaLHNCQUFVL0MsTUFBVixFQUFrQjNHLEtBQWxCLEVBQXlCd0YsR0FBekI7QUFDSCxTQUZNLE1BRUE7QUFDSG1CLG1CQUFPOEMsR0FBUCxDQUFXakUsR0FBWCxFQUFnQnhGLEtBQWhCO0FBQ0g7QUFDSixLQWZEO0FBZ0JIOztBQUVEOzs7O0FBSUEsSUFBSTRLLFlBQVksU0FBWkEsU0FBWSxDQUFVQyxPQUFWLEVBQW1CO0FBQy9CLFdBQU8sSUFBSTVJLFVBQUosQ0FBZSxVQUFVNUIsT0FBVixFQUFtQjs7QUFFckMsWUFBSXlLLE1BQU0sSUFBSUMsY0FBSixFQUFWO0FBQUEsWUFBZ0N6QixVQUFVLFNBQVZBLE9BQVUsQ0FBVTdHLEdBQVYsRUFBZTtBQUNyRCxnQkFBSXVJLE9BQU92SSxJQUFJdUksSUFBZjs7QUFHQSxnQkFBSUMsU0FBUyxDQUFiOztBQUVBLGdCQUFJRCxTQUFTLE1BQWIsRUFBcUI7QUFDakJDLHlCQUFTLEdBQVQ7QUFDSCxhQUZELE1BRU8sSUFBSUQsU0FBUyxPQUFiLEVBQXNCO0FBQ3pCQyx5QkFBUyxHQUFUO0FBQ0g7O0FBRUQ1SyxvQkFBUXdLLFFBQVFLLFdBQVIsQ0FBb0JKLElBQUlLLFlBQXhCLEVBQXNDLEVBQUNGLFFBQVFBLE1BQVQsRUFBdEMsQ0FBUjtBQUNILFNBYkQ7O0FBZUFKLGdCQUFRTyxLQUFSLEdBQWdCLFlBQVk7QUFBRSxtQkFBT04sSUFBSU0sS0FBSixFQUFQO0FBQXFCLFNBQW5EOztBQUVBTixZQUFJTyxJQUFKLENBQVNSLFFBQVFTLE1BQWpCLEVBQXlCVCxRQUFRVSxNQUFSLEVBQXpCOztBQUVBLFlBQUlWLFFBQVFXLE9BQVosRUFBcUI7QUFDakJWLGdCQUFJVSxPQUFKLEdBQWNYLFFBQVFXLE9BQXRCO0FBQ0g7O0FBRURWLFlBQUlXLE1BQUosR0FBYW5DLE9BQWI7QUFDQXdCLFlBQUlZLE9BQUosR0FBY3BDLE9BQWQ7QUFDQXdCLFlBQUlhLE9BQUosR0FBY3JDLE9BQWQ7QUFDQXdCLFlBQUljLFNBQUosR0FBZ0J0QyxPQUFoQjtBQUNBd0IsWUFBSWUsVUFBSixHQUFpQixZQUFZLENBQUUsQ0FBL0I7QUFDQWYsWUFBSWdCLElBQUosQ0FBU2pCLFFBQVFrQixPQUFSLEVBQVQ7QUFDSCxLQS9CTSxDQUFQO0FBZ0NILENBakNEOztBQW1DQTs7OztBQUlBLElBQUlDLGdCQUFnQmpKLGFBQWEscUJBQXFCLElBQUlrSixjQUFKLEVBQXREOztBQUVBLElBQUlDLE9BQU8sU0FBUEEsSUFBTyxDQUFVckIsT0FBVixFQUFtQnpFLElBQW5CLEVBQXlCOztBQUVoQyxRQUFJckQsU0FBSixFQUFlOztBQUVYLFlBQUlvSixTQUFTekYsSUFBSU0sS0FBSixDQUFVb0YsU0FBU3JDLElBQW5CLENBQWI7QUFDQSxZQUFJc0MsU0FBUzNGLElBQUlNLEtBQUosQ0FBVTZELFFBQVFVLE1BQVIsRUFBVixDQUFiOztBQUVBLFlBQUljLE9BQU9yQyxRQUFQLEtBQW9CbUMsT0FBT25DLFFBQTNCLElBQXVDcUMsT0FBT25DLElBQVAsS0FBZ0JpQyxPQUFPakMsSUFBbEUsRUFBd0U7O0FBRXBFVyxvQkFBUXlCLFdBQVIsR0FBc0IsSUFBdEI7QUFDQXpCLG9CQUFRMEIsV0FBUixHQUFzQixLQUF0Qjs7QUFFQSxnQkFBSSxDQUFDUCxhQUFMLEVBQW9CO0FBQ2hCbkIsd0JBQVEyQixNQUFSLEdBQWlCNUIsU0FBakI7QUFDSDtBQUNKO0FBQ0o7O0FBRUR4RTtBQUNILENBbkJEOztBQXFCQTs7OztBQUlBLElBQUlxRyxPQUFPLFNBQVBBLElBQU8sQ0FBVTVCLE9BQVYsRUFBbUJ6RSxJQUFuQixFQUF5Qjs7QUFFaEMsUUFBSXhCLFdBQVdpRyxRQUFRNEIsSUFBbkIsQ0FBSixFQUE4Qjs7QUFFMUI1QixnQkFBUTZCLE9BQVIsQ0FBZ0JDLE1BQWhCLENBQXVCLGNBQXZCO0FBRUgsS0FKRCxNQUlPLElBQUl0SSxTQUFTd0csUUFBUTRCLElBQWpCLEtBQTBCekksUUFBUTZHLFFBQVE0QixJQUFoQixDQUE5QixFQUFxRDs7QUFFeEQsWUFBSTVCLFFBQVErQixXQUFaLEVBQXlCO0FBQ3JCL0Isb0JBQVE0QixJQUFSLEdBQWUvRixJQUFJQyxNQUFKLENBQVdrRSxRQUFRNEIsSUFBbkIsQ0FBZjtBQUNBNUIsb0JBQVE2QixPQUFSLENBQWdCRyxHQUFoQixDQUFvQixjQUFwQixFQUFvQyxtQ0FBcEM7QUFDSCxTQUhELE1BR087QUFDSGhDLG9CQUFRNEIsSUFBUixHQUFlSyxLQUFLQyxTQUFMLENBQWVsQyxRQUFRNEIsSUFBdkIsQ0FBZjtBQUNIO0FBQ0o7O0FBRURyRyxTQUFLLFVBQVU0RyxRQUFWLEVBQW9COztBQUVyQnhJLGVBQU95SSxjQUFQLENBQXNCRCxRQUF0QixFQUFnQyxNQUFoQyxFQUF3Qzs7QUFFcENFLGlCQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNoQix1QkFBTyxLQUFLVCxJQUFaO0FBQ0gsYUFKbUM7O0FBTXBDSSxpQkFBSyxTQUFTQSxHQUFULENBQWFKLElBQWIsRUFBbUI7QUFDcEIscUJBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNIOztBQVJtQyxTQUF4Qzs7QUFZQSxlQUFPTyxTQUFTRyxRQUFULEdBQW9CckksS0FBS2tJLFNBQVNJLElBQVQsRUFBTCxFQUFzQixVQUFVQSxJQUFWLEVBQWdCOztBQUU3RCxnQkFBSXBDLE9BQU9nQyxTQUFTTixPQUFULENBQWlCUSxHQUFqQixDQUFxQixjQUFyQixLQUF3QyxFQUFuRDs7QUFFQSxnQkFBSWxDLEtBQUtwRSxPQUFMLENBQWEsa0JBQWIsTUFBcUMsQ0FBckMsSUFBMEN5RyxPQUFPRCxJQUFQLENBQTlDLEVBQTREOztBQUV4RCxvQkFBSTtBQUNBSiw2QkFBU1AsSUFBVCxHQUFnQkssS0FBSzlGLEtBQUwsQ0FBV29HLElBQVgsQ0FBaEI7QUFDSCxpQkFGRCxDQUVFLE9BQU81TSxDQUFQLEVBQVU7QUFDUndNLDZCQUFTUCxJQUFULEdBQWdCLElBQWhCO0FBQ0g7QUFFSixhQVJELE1BUU87QUFDSE8seUJBQVNQLElBQVQsR0FBZ0JXLElBQWhCO0FBQ0g7O0FBRUQsbUJBQU9KLFFBQVA7QUFFSCxTQWxCMEIsQ0FBcEIsR0FrQkZBLFFBbEJMO0FBb0JILEtBbENEO0FBbUNILENBbkREOztBQXFEQSxTQUFTSyxNQUFULENBQWdCM0osR0FBaEIsRUFBcUI7O0FBRWpCLFFBQUk0SixRQUFRNUosSUFBSTRDLEtBQUosQ0FBVSxlQUFWLENBQVo7QUFBQSxRQUF3Q2lILE1BQU0sRUFBQyxLQUFLLElBQU4sRUFBWSxLQUFLLElBQWpCLEVBQTlDOztBQUVBLFdBQU9ELFNBQVNDLElBQUlELE1BQU0sQ0FBTixDQUFKLEVBQWNyRSxJQUFkLENBQW1CdkYsR0FBbkIsQ0FBaEI7QUFDSDs7QUFFRDs7OztBQUlBLElBQUk4SixjQUFjLFNBQWRBLFdBQWMsQ0FBVTNDLE9BQVYsRUFBbUI7QUFDakMsV0FBTyxJQUFJNUksVUFBSixDQUFlLFVBQVU1QixPQUFWLEVBQW1COztBQUVyQyxZQUFJc0ssT0FBT0UsUUFBUTRDLEtBQVIsSUFBaUIsVUFBNUI7QUFBQSxZQUF3Q2pMLFdBQVdxSSxRQUFRNkMsYUFBUixJQUF5QixXQUFXQyxLQUFLQyxNQUFMLEdBQWNyRixRQUFkLENBQXVCLEVBQXZCLEVBQTJCWCxNQUEzQixDQUFrQyxDQUFsQyxDQUF2RjtBQUFBLFlBQTZINkUsT0FBTyxJQUFwSTtBQUFBLFlBQTBJbkQsT0FBMUk7QUFBQSxZQUFtSnVFLE1BQW5KOztBQUVBdkUsa0JBQVUsaUJBQVU3RyxHQUFWLEVBQWU7QUFDckIsZ0JBQUl1SSxPQUFPdkksSUFBSXVJLElBQWY7O0FBR0EsZ0JBQUlDLFNBQVMsQ0FBYjs7QUFFQSxnQkFBSUQsU0FBUyxNQUFULElBQW1CeUIsU0FBUyxJQUFoQyxFQUFzQztBQUNsQ3hCLHlCQUFTLEdBQVQ7QUFDSCxhQUZELE1BRU8sSUFBSUQsU0FBUyxPQUFiLEVBQXNCO0FBQ3pCQyx5QkFBUyxHQUFUO0FBQ0g7O0FBRUQsZ0JBQUlBLFVBQVVqSixPQUFPUSxRQUFQLENBQWQsRUFBZ0M7QUFDNUIsdUJBQU9SLE9BQU9RLFFBQVAsQ0FBUDtBQUNBb0gseUJBQVM2QyxJQUFULENBQWNxQixXQUFkLENBQTBCRCxNQUExQjtBQUNIOztBQUVEeE4sb0JBQVF3SyxRQUFRSyxXQUFSLENBQW9CdUIsSUFBcEIsRUFBMEIsRUFBQ3hCLFFBQVFBLE1BQVQsRUFBMUIsQ0FBUjtBQUNILFNBbEJEOztBQW9CQWpKLGVBQU9RLFFBQVAsSUFBbUIsVUFBVTVCLE1BQVYsRUFBa0I7QUFDakM2TCxtQkFBT0ssS0FBS0MsU0FBTCxDQUFlbk0sTUFBZixDQUFQO0FBQ0gsU0FGRDs7QUFJQWlLLGdCQUFRTyxLQUFSLEdBQWdCLFlBQVk7QUFDeEI5QixvQkFBUSxFQUFDMEIsTUFBTSxPQUFQLEVBQVI7QUFDSCxTQUZEOztBQUlBSCxnQkFBUWxFLE1BQVIsQ0FBZWdFLElBQWYsSUFBdUJuSSxRQUF2Qjs7QUFFQSxZQUFJcUksUUFBUVcsT0FBWixFQUFxQjtBQUNqQnVDLHVCQUFXbEQsUUFBUU8sS0FBbkIsRUFBMEJQLFFBQVFXLE9BQWxDO0FBQ0g7O0FBRURxQyxpQkFBU2pFLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBVDtBQUNBZ0UsZUFBT0csR0FBUCxHQUFhbkQsUUFBUVUsTUFBUixFQUFiO0FBQ0FzQyxlQUFPN0MsSUFBUCxHQUFjLGlCQUFkO0FBQ0E2QyxlQUFPSSxLQUFQLEdBQWUsSUFBZjtBQUNBSixlQUFPcEMsTUFBUCxHQUFnQm5DLE9BQWhCO0FBQ0F1RSxlQUFPbEMsT0FBUCxHQUFpQnJDLE9BQWpCOztBQUVBTSxpQkFBUzZDLElBQVQsQ0FBY3lCLFdBQWQsQ0FBMEJMLE1BQTFCO0FBQ0gsS0E5Q00sQ0FBUDtBQStDSCxDQWhERDs7QUFrREE7Ozs7QUFJQSxJQUFJSixRQUFRLFNBQVJBLEtBQVEsQ0FBVTVDLE9BQVYsRUFBbUJ6RSxJQUFuQixFQUF5Qjs7QUFFakMsUUFBSXlFLFFBQVFTLE1BQVIsSUFBa0IsT0FBdEIsRUFBK0I7QUFDM0JULGdCQUFRMkIsTUFBUixHQUFpQmdCLFdBQWpCO0FBQ0g7O0FBRURwSDtBQUNILENBUEQ7O0FBU0E7Ozs7QUFJQSxJQUFJK0gsU0FBUyxTQUFUQSxNQUFTLENBQVV0RCxPQUFWLEVBQW1CekUsSUFBbkIsRUFBeUI7O0FBRWxDLFFBQUloQyxXQUFXeUcsUUFBUXNELE1BQW5CLENBQUosRUFBZ0M7QUFDNUJ0RCxnQkFBUXNELE1BQVIsQ0FBZTdNLElBQWYsQ0FBb0IsSUFBcEIsRUFBMEJ1SixPQUExQjtBQUNIOztBQUVEekU7QUFDSCxDQVBEOztBQVNBOzs7O0FBSUEsSUFBSWtGLFNBQVMsU0FBVEEsTUFBUyxDQUFVVCxPQUFWLEVBQW1CekUsSUFBbkIsRUFBeUI7O0FBRWxDLFFBQUl5RSxRQUFRMEIsV0FBUixJQUF1Qix3QkFBd0J0RCxJQUF4QixDQUE2QjRCLFFBQVFTLE1BQXJDLENBQTNCLEVBQXlFO0FBQ3JFVCxnQkFBUTZCLE9BQVIsQ0FBZ0JHLEdBQWhCLENBQW9CLHdCQUFwQixFQUE4Q2hDLFFBQVFTLE1BQXREO0FBQ0FULGdCQUFRUyxNQUFSLEdBQWlCLE1BQWpCO0FBQ0g7O0FBRURsRjtBQUNILENBUkQ7O0FBVUE7Ozs7QUFJQSxJQUFJZ0ksU0FBUyxTQUFUQSxNQUFTLENBQVV2RCxPQUFWLEVBQW1CekUsSUFBbkIsRUFBeUI7O0FBRWxDLFFBQUlzRyxVQUFVakgsT0FBTyxFQUFQLEVBQVc0SSxLQUFLM0IsT0FBTCxDQUFhNEIsTUFBeEIsRUFDVixDQUFDekQsUUFBUXlCLFdBQVQsR0FBdUIrQixLQUFLM0IsT0FBTCxDQUFhNkIsTUFBcEMsR0FBNkMsRUFEbkMsRUFFVkYsS0FBSzNCLE9BQUwsQ0FBYTlJLFFBQVFpSCxRQUFRUyxNQUFoQixDQUFiLENBRlUsQ0FBZDs7QUFLQWhHLFNBQUtvSCxPQUFMLEVBQWMsVUFBVTFNLEtBQVYsRUFBaUIySyxJQUFqQixFQUF1QjtBQUNqQyxZQUFJLENBQUNFLFFBQVE2QixPQUFSLENBQWdCOEIsR0FBaEIsQ0FBb0I3RCxJQUFwQixDQUFMLEVBQWdDO0FBQzVCRSxvQkFBUTZCLE9BQVIsQ0FBZ0JHLEdBQWhCLENBQW9CbEMsSUFBcEIsRUFBMEIzSyxLQUExQjtBQUNIO0FBQ0osS0FKRDs7QUFNQW9HO0FBQ0gsQ0FkRDs7QUFnQkE7Ozs7QUFJQSxJQUFJcUksWUFBWSxTQUFaQSxTQUFZLENBQVU1RCxPQUFWLEVBQW1CO0FBQy9CLFdBQU8sSUFBSTVJLFVBQUosQ0FBZSxVQUFVNUIsT0FBVixFQUFtQjs7QUFFckMsWUFBSXFPLE1BQU0sSUFBSXpDLGNBQUosRUFBVjtBQUFBLFlBQWdDM0MsVUFBVSxTQUFWQSxPQUFVLENBQVVxRixLQUFWLEVBQWlCOztBQUV2RCxnQkFBSTNCLFdBQVduQyxRQUFRSyxXQUFSLENBQ1gsY0FBY3dELEdBQWQsR0FBb0JBLElBQUkxQixRQUF4QixHQUFtQzBCLElBQUl2RCxZQUQ1QixFQUMwQztBQUNqREYsd0JBQVF5RCxJQUFJekQsTUFBSixLQUFlLElBQWYsR0FBc0IsR0FBdEIsR0FBNEJ5RCxJQUFJekQsTUFEUyxFQUNEO0FBQ2hEMkQsNEJBQVlGLElBQUl6RCxNQUFKLEtBQWUsSUFBZixHQUFzQixZQUF0QixHQUFxQ3hILEtBQUtpTCxJQUFJRSxVQUFUO0FBRkEsYUFEMUMsQ0FBZjs7QUFPQXRKLGlCQUFLN0IsS0FBS2lMLElBQUlHLHFCQUFKLEVBQUwsRUFBa0NoSCxLQUFsQyxDQUF3QyxJQUF4QyxDQUFMLEVBQW9ELFVBQVVpSCxHQUFWLEVBQWU7QUFDL0Q5Qix5QkFBU04sT0FBVCxDQUFpQnFDLE1BQWpCLENBQXdCRCxJQUFJbE0sS0FBSixDQUFVLENBQVYsRUFBYWtNLElBQUlsSSxPQUFKLENBQVksR0FBWixDQUFiLENBQXhCLEVBQXdEa0ksSUFBSWxNLEtBQUosQ0FBVWtNLElBQUlsSSxPQUFKLENBQVksR0FBWixJQUFtQixDQUE3QixDQUF4RDtBQUNILGFBRkQ7O0FBSUF2RyxvQkFBUTJNLFFBQVI7QUFDSCxTQWREOztBQWdCQW5DLGdCQUFRTyxLQUFSLEdBQWdCLFlBQVk7QUFBRSxtQkFBT3NELElBQUl0RCxLQUFKLEVBQVA7QUFBcUIsU0FBbkQ7O0FBRUEsWUFBSVAsUUFBUW1FLFFBQVosRUFBc0I7QUFDbEIsZ0JBQUluRSxRQUFRUyxNQUFSLEtBQW1CLEtBQXZCLEVBQThCO0FBQzFCb0Qsb0JBQUlPLGdCQUFKLENBQXFCLFVBQXJCLEVBQWlDcEUsUUFBUW1FLFFBQXpDO0FBQ0gsYUFGRCxNQUVPLElBQUksZ0JBQWdCL0YsSUFBaEIsQ0FBcUI0QixRQUFRUyxNQUE3QixDQUFKLEVBQTBDO0FBQzdDb0Qsb0JBQUlRLE1BQUosQ0FBV0QsZ0JBQVgsQ0FBNEIsVUFBNUIsRUFBd0NwRSxRQUFRbUUsUUFBaEQ7QUFDSDtBQUNKOztBQUVETixZQUFJckQsSUFBSixDQUFTUixRQUFRUyxNQUFqQixFQUF5QlQsUUFBUVUsTUFBUixFQUF6QixFQUEyQyxJQUEzQzs7QUFFQSxZQUFJVixRQUFRVyxPQUFaLEVBQXFCO0FBQ2pCa0QsZ0JBQUlsRCxPQUFKLEdBQWNYLFFBQVFXLE9BQXRCO0FBQ0g7O0FBRUQsWUFBSVgsUUFBUXNFLFlBQVIsSUFBd0Isa0JBQWtCVCxHQUE5QyxFQUFtRDtBQUMvQ0EsZ0JBQUlTLFlBQUosR0FBbUJ0RSxRQUFRc0UsWUFBM0I7QUFDSDs7QUFFRCxZQUFJdEUsUUFBUXVFLGVBQVIsSUFBMkJ2RSxRQUFRd0UsV0FBdkMsRUFBb0Q7QUFDaERYLGdCQUFJVSxlQUFKLEdBQXNCLElBQXRCO0FBQ0g7O0FBRUQsWUFBSSxDQUFDdkUsUUFBUXlCLFdBQWIsRUFBMEI7QUFDdEJ6QixvQkFBUTZCLE9BQVIsQ0FBZ0JHLEdBQWhCLENBQW9CLGtCQUFwQixFQUF3QyxnQkFBeEM7QUFDSDs7QUFFRGhDLGdCQUFRNkIsT0FBUixDQUFnQjdHLE9BQWhCLENBQXdCLFVBQVU3RixLQUFWLEVBQWlCMkssSUFBakIsRUFBdUI7QUFDM0MrRCxnQkFBSVksZ0JBQUosQ0FBcUIzRSxJQUFyQixFQUEyQjNLLEtBQTNCO0FBQ0gsU0FGRDs7QUFJQTBPLFlBQUlqRCxNQUFKLEdBQWFuQyxPQUFiO0FBQ0FvRixZQUFJaEQsT0FBSixHQUFjcEMsT0FBZDtBQUNBb0YsWUFBSS9DLE9BQUosR0FBY3JDLE9BQWQ7QUFDQW9GLFlBQUk5QyxTQUFKLEdBQWdCdEMsT0FBaEI7QUFDQW9GLFlBQUk1QyxJQUFKLENBQVNqQixRQUFRa0IsT0FBUixFQUFUO0FBQ0gsS0F2RE0sQ0FBUDtBQXdESCxDQXpERDs7QUEyREE7Ozs7QUFJQSxJQUFJd0QsYUFBYSxTQUFiQSxVQUFhLENBQVUxRSxPQUFWLEVBQW1COztBQUVoQyxRQUFJMkIsU0FBUyxtQkFBQWdELENBQVEsRUFBUixDQUFiOztBQUVBLFdBQU8sSUFBSXZOLFVBQUosQ0FBZSxVQUFVNUIsT0FBVixFQUFtQjs7QUFFckMsWUFBSWdHLE1BQU13RSxRQUFRVSxNQUFSLEVBQVY7QUFDQSxZQUFJa0IsT0FBTzVCLFFBQVFrQixPQUFSLEVBQVg7QUFDQSxZQUFJVCxTQUFTVCxRQUFRUyxNQUFyQjtBQUNBLFlBQUlvQixVQUFVLEVBQWQ7QUFBQSxZQUFrQnBELE9BQWxCOztBQUVBdUIsZ0JBQVE2QixPQUFSLENBQWdCN0csT0FBaEIsQ0FBd0IsVUFBVTdGLEtBQVYsRUFBaUIySyxJQUFqQixFQUF1QjtBQUMzQytCLG9CQUFRL0IsSUFBUixJQUFnQjNLLEtBQWhCO0FBQ0gsU0FGRDs7QUFJQXdNLGVBQU9uRyxHQUFQLEVBQVksRUFBQ29HLE1BQU1BLElBQVAsRUFBYW5CLFFBQVFBLE1BQXJCLEVBQTZCb0IsU0FBU0EsT0FBdEMsRUFBWixFQUE0RDFMLElBQTVELENBQWlFc0ksVUFBVSxpQkFBVW1HLElBQVYsRUFBZ0I7O0FBRXZGLGdCQUFJekMsV0FBV25DLFFBQVFLLFdBQVIsQ0FBb0J1RSxLQUFLaEQsSUFBekIsRUFBK0I7QUFDdEN4Qix3QkFBUXdFLEtBQUtDLFVBRHlCO0FBRXRDZCw0QkFBWW5MLEtBQUtnTSxLQUFLRSxhQUFWO0FBRjBCLGFBQS9CLENBQWY7O0FBTUFySyxpQkFBS21LLEtBQUsvQyxPQUFWLEVBQW1CLFVBQVUxTSxLQUFWLEVBQWlCMkssSUFBakIsRUFBdUI7QUFDdENxQyx5QkFBU04sT0FBVCxDQUFpQkcsR0FBakIsQ0FBcUJsQyxJQUFyQixFQUEyQjNLLEtBQTNCO0FBQ0gsYUFGRDs7QUFJQUssb0JBQVEyTSxRQUFSO0FBRUgsU0FkRCxFQWNHLFVBQVU0QyxRQUFWLEVBQW9CO0FBQUUsbUJBQU90RyxRQUFRc0csU0FBUzVDLFFBQWpCLENBQVA7QUFBb0MsU0FkN0Q7QUFlSCxLQTFCTSxDQUFQO0FBMkJILENBL0JEOztBQWlDQTs7OztBQUlBLElBQUk2QyxTQUFTLGdCQUFVM04sT0FBVixFQUFtQjs7QUFFNUIsUUFBSTROLGNBQWMsQ0FBQ0MsV0FBRCxDQUFsQjtBQUFBLFFBQWlDQyxjQUFjLEVBQS9DO0FBQUEsUUFBbUQxRyxPQUFuRDs7QUFFQSxRQUFJLENBQUNqRixTQUFTbkMsT0FBVCxDQUFMLEVBQXdCO0FBQ3BCQSxrQkFBVSxJQUFWO0FBQ0g7O0FBRUQsYUFBUzJOLE1BQVQsQ0FBZ0JoRixPQUFoQixFQUF5QjtBQUNyQixlQUFPLElBQUk1SSxVQUFKLENBQWUsVUFBVTVCLE9BQVYsRUFBbUI7O0FBRXJDLHFCQUFTMkgsSUFBVCxHQUFnQjs7QUFFWnNCLDBCQUFVd0csWUFBWUcsR0FBWixFQUFWOztBQUVBLG9CQUFJN0wsV0FBV2tGLE9BQVgsQ0FBSixFQUF5QjtBQUNyQkEsNEJBQVFoSSxJQUFSLENBQWFZLE9BQWIsRUFBc0IySSxPQUF0QixFQUErQnpFLElBQS9CO0FBQ0gsaUJBRkQsTUFFTztBQUNIakQseUJBQU0seUNBQXlDbUcsT0FBekMseUNBQXlDQSxPQUF6QyxLQUFvRCxzQkFBMUQ7QUFDQWxEO0FBQ0g7QUFDSjs7QUFFRCxxQkFBU0EsSUFBVCxDQUFjNEcsUUFBZCxFQUF3Qjs7QUFFcEIsb0JBQUk1SSxXQUFXNEksUUFBWCxDQUFKLEVBQTBCOztBQUV0QmdELGdDQUFZRSxPQUFaLENBQW9CbEQsUUFBcEI7QUFFSCxpQkFKRCxNQUlPLElBQUkzSSxTQUFTMkksUUFBVCxDQUFKLEVBQXdCOztBQUUzQmdELGdDQUFZbkssT0FBWixDQUFvQixVQUFVeUQsT0FBVixFQUFtQjtBQUNuQzBELG1DQUFXbEksS0FBS2tJLFFBQUwsRUFBZSxVQUFVQSxRQUFWLEVBQW9CO0FBQzFDLG1DQUFPMUQsUUFBUWhJLElBQVIsQ0FBYVksT0FBYixFQUFzQjhLLFFBQXRCLEtBQW1DQSxRQUExQztBQUNILHlCQUZVLENBQVg7QUFHSCxxQkFKRDs7QUFNQWxJLHlCQUFLa0ksUUFBTCxFQUFlM00sT0FBZjs7QUFFQTtBQUNIOztBQUVEMkg7QUFDSDs7QUFFREE7QUFFSCxTQXRDTSxFQXNDSjlGLE9BdENJLENBQVA7QUF1Q0g7O0FBRUQyTixXQUFPTSxHQUFQLEdBQWEsVUFBVTdHLE9BQVYsRUFBbUI7QUFDNUJ3RyxvQkFBWWpPLElBQVosQ0FBaUJ5SCxPQUFqQjtBQUNILEtBRkQ7O0FBSUEsV0FBT3VHLE1BQVA7QUFDSCxDQXZERDs7QUF5REEsU0FBU0UsV0FBVCxDQUFxQmxGLE9BQXJCLEVBQThCeEssT0FBOUIsRUFBdUM7O0FBRW5DLFFBQUltTSxTQUFTM0IsUUFBUTJCLE1BQVIsS0FBbUJ6SixZQUFZMEwsU0FBWixHQUF3QmMsVUFBM0MsQ0FBYjs7QUFFQWxQLFlBQVFtTSxPQUFPM0IsT0FBUCxDQUFSO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxJQUFJdUYsVUFBVSxTQUFTQSxPQUFULENBQWlCMUQsT0FBakIsRUFBMEI7QUFDcEMsUUFBSTJELFNBQVMsSUFBYjs7QUFHQSxTQUFLdEgsR0FBTCxHQUFXLEVBQVg7O0FBRUF6RCxTQUFLb0gsT0FBTCxFQUFjLFVBQVUxTSxLQUFWLEVBQWlCMkssSUFBakIsRUFBdUI7QUFBRSxlQUFPMEYsT0FBT3RCLE1BQVAsQ0FBY3BFLElBQWQsRUFBb0IzSyxLQUFwQixDQUFQO0FBQW9DLEtBQTNFO0FBQ0gsQ0FQRDs7QUFTQW9RLFFBQVFqUCxTQUFSLENBQWtCcU4sR0FBbEIsR0FBd0IsU0FBU0EsR0FBVCxDQUFjN0QsSUFBZCxFQUFvQjtBQUN4QyxXQUFPMkYsUUFBUSxLQUFLdkgsR0FBYixFQUFrQjRCLElBQWxCLE1BQTRCLElBQW5DO0FBQ0gsQ0FGRDs7QUFJQXlGLFFBQVFqUCxTQUFSLENBQWtCK0wsR0FBbEIsR0FBd0IsU0FBU0EsR0FBVCxDQUFjdkMsSUFBZCxFQUFvQjs7QUFFeEMsUUFBSTRGLE9BQU8sS0FBS3hILEdBQUwsQ0FBU3VILFFBQVEsS0FBS3ZILEdBQWIsRUFBa0I0QixJQUFsQixDQUFULENBQVg7O0FBRUEsV0FBTzRGLE9BQU9BLEtBQUtwSSxJQUFMLEVBQVAsR0FBcUIsSUFBNUI7QUFDSCxDQUxEOztBQU9BaUksUUFBUWpQLFNBQVIsQ0FBa0JxUCxNQUFsQixHQUEyQixTQUFTQSxNQUFULENBQWlCN0YsSUFBakIsRUFBdUI7QUFDOUMsV0FBTyxLQUFLNUIsR0FBTCxDQUFTdUgsUUFBUSxLQUFLdkgsR0FBYixFQUFrQjRCLElBQWxCLENBQVQsS0FBcUMsRUFBNUM7QUFDSCxDQUZEOztBQUlBeUYsUUFBUWpQLFNBQVIsQ0FBa0IwTCxHQUFsQixHQUF3QixTQUFTQSxHQUFULENBQWNsQyxJQUFkLEVBQW9CM0ssS0FBcEIsRUFBMkI7QUFDL0MsU0FBSytJLEdBQUwsQ0FBUzBILGNBQWNILFFBQVEsS0FBS3ZILEdBQWIsRUFBa0I0QixJQUFsQixLQUEyQkEsSUFBekMsQ0FBVCxJQUEyRCxDQUFDbEgsS0FBS3pELEtBQUwsQ0FBRCxDQUEzRDtBQUNILENBRkQ7O0FBSUFvUSxRQUFRalAsU0FBUixDQUFrQjROLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsQ0FBaUJwRSxJQUFqQixFQUF1QjNLLEtBQXZCLEVBQTZCOztBQUVwRCxRQUFJdVEsT0FBTyxLQUFLeEgsR0FBTCxDQUFTdUgsUUFBUSxLQUFLdkgsR0FBYixFQUFrQjRCLElBQWxCLENBQVQsQ0FBWDs7QUFFQSxRQUFJNEYsSUFBSixFQUFVO0FBQ05BLGFBQUsxTyxJQUFMLENBQVU0QixLQUFLekQsS0FBTCxDQUFWO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBSzZNLEdBQUwsQ0FBU2xDLElBQVQsRUFBZTNLLEtBQWY7QUFDSDtBQUNKLENBVEQ7O0FBV0FvUSxRQUFRalAsU0FBUixDQUFrQndMLE1BQWxCLEdBQTJCLFNBQVMrRCxRQUFULENBQW1CL0YsSUFBbkIsRUFBd0I7QUFDL0MsV0FBTyxLQUFLNUIsR0FBTCxDQUFTdUgsUUFBUSxLQUFLdkgsR0FBYixFQUFrQjRCLElBQWxCLENBQVQsQ0FBUDtBQUNILENBRkQ7O0FBSUF5RixRQUFRalAsU0FBUixDQUFrQndQLFNBQWxCLEdBQThCLFNBQVNBLFNBQVQsR0FBcUI7QUFDL0MsU0FBSzVILEdBQUwsR0FBVyxFQUFYO0FBQ0gsQ0FGRDs7QUFJQXFILFFBQVFqUCxTQUFSLENBQWtCMEUsT0FBbEIsR0FBNEIsU0FBU0EsT0FBVCxDQUFrQnJELFFBQWxCLEVBQTRCb08sT0FBNUIsRUFBcUM7QUFDekQsUUFBSVAsU0FBUyxJQUFiOztBQUVKL0ssU0FBSyxLQUFLeUQsR0FBVixFQUFlLFVBQVV3SCxJQUFWLEVBQWdCNUYsSUFBaEIsRUFBc0I7QUFDakNyRixhQUFLaUwsSUFBTCxFQUFXLFVBQVV2USxLQUFWLEVBQWlCO0FBQUUsbUJBQU93QyxTQUFTbEIsSUFBVCxDQUFjc1AsT0FBZCxFQUF1QjVRLEtBQXZCLEVBQThCMkssSUFBOUIsRUFBb0MwRixNQUFwQyxDQUFQO0FBQXFELFNBQW5GO0FBQ0gsS0FGRDtBQUdILENBTkQ7O0FBUUEsU0FBU0MsT0FBVCxDQUFpQnZILEdBQWpCLEVBQXNCNEIsSUFBdEIsRUFBNEI7QUFDeEIsV0FBT25HLE9BQU9pQyxJQUFQLENBQVlzQyxHQUFaLEVBQWlCOEgsTUFBakIsQ0FBd0IsVUFBVUMsSUFBVixFQUFnQkMsSUFBaEIsRUFBc0I7QUFDakQsZUFBT25OLFFBQVErRyxJQUFSLE1BQWtCL0csUUFBUW1OLElBQVIsQ0FBbEIsR0FBa0NBLElBQWxDLEdBQXlDRCxJQUFoRDtBQUNILEtBRk0sRUFFSixJQUZJLENBQVA7QUFHSDs7QUFFRCxTQUFTTCxhQUFULENBQXVCOUYsSUFBdkIsRUFBNkI7O0FBRXpCLFFBQUksNkJBQTZCMUIsSUFBN0IsQ0FBa0MwQixJQUFsQyxDQUFKLEVBQTZDO0FBQ3pDLGNBQU0sSUFBSXZKLFNBQUosQ0FBYyx3Q0FBZCxDQUFOO0FBQ0g7O0FBRUQsV0FBT3FDLEtBQUtrSCxJQUFMLENBQVA7QUFDSDs7QUFFRDs7OztBQUlBLElBQUlxRyxXQUFXLFNBQVNBLFFBQVQsQ0FBa0J2RSxJQUFsQixFQUF3QmhLLEdBQXhCLEVBQTZCO0FBQ3hDLFFBQUk0RCxNQUFNNUQsSUFBSTRELEdBQWQ7QUFDQSxRQUFJcUcsVUFBVWpLLElBQUlpSyxPQUFsQjtBQUNBLFFBQUl6QixTQUFTeEksSUFBSXdJLE1BQWpCO0FBQ0EsUUFBSTJELGFBQWFuTSxJQUFJbU0sVUFBckI7O0FBR0EsU0FBS3ZJLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUs0SyxFQUFMLEdBQVVoRyxVQUFVLEdBQVYsSUFBaUJBLFNBQVMsR0FBcEM7QUFDQSxTQUFLQSxNQUFMLEdBQWNBLFVBQVUsQ0FBeEI7QUFDQSxTQUFLMkQsVUFBTCxHQUFrQkEsY0FBYyxFQUFoQztBQUNBLFNBQUtsQyxPQUFMLEdBQWUsSUFBSTBELE9BQUosQ0FBWTFELE9BQVosQ0FBZjtBQUNBLFNBQUtELElBQUwsR0FBWUEsSUFBWjs7QUFFQSxRQUFJdkksU0FBU3VJLElBQVQsQ0FBSixFQUFvQjs7QUFFaEIsYUFBS1UsUUFBTCxHQUFnQlYsSUFBaEI7QUFFSCxLQUpELE1BSU8sSUFBSS9ILE9BQU8rSCxJQUFQLENBQUosRUFBa0I7O0FBRXJCLGFBQUt5RSxRQUFMLEdBQWdCekUsSUFBaEI7O0FBRUEsWUFBSTBFLFdBQVcxRSxJQUFYLENBQUosRUFBc0I7QUFDbEIsaUJBQUtVLFFBQUwsR0FBZ0JpRSxTQUFTM0UsSUFBVCxDQUFoQjtBQUNIO0FBQ0o7QUFDSixDQTFCRDs7QUE0QkF1RSxTQUFTN1AsU0FBVCxDQUFtQmtRLElBQW5CLEdBQTBCLFNBQVNBLElBQVQsR0FBaUI7QUFDdkMsV0FBT3ZNLEtBQUssS0FBS29NLFFBQVYsQ0FBUDtBQUNILENBRkQ7O0FBSUFGLFNBQVM3UCxTQUFULENBQW1CaU0sSUFBbkIsR0FBMEIsU0FBU0EsSUFBVCxHQUFpQjtBQUN2QyxXQUFPdEksS0FBSyxLQUFLcUksUUFBVixDQUFQO0FBQ0gsQ0FGRDs7QUFJQTZELFNBQVM3UCxTQUFULENBQW1CbVEsSUFBbkIsR0FBMEIsU0FBU0EsSUFBVCxHQUFpQjtBQUN2QyxXQUFPeE0sS0FBSyxLQUFLc0ksSUFBTCxFQUFMLEVBQWtCLFVBQVVBLElBQVYsRUFBZ0I7QUFBRSxlQUFPTixLQUFLOUYsS0FBTCxDQUFXb0csSUFBWCxDQUFQO0FBQTBCLEtBQTlELENBQVA7QUFDSCxDQUZEOztBQUlBLFNBQVNnRSxRQUFULENBQWtCM0UsSUFBbEIsRUFBd0I7QUFDcEIsV0FBTyxJQUFJeEssVUFBSixDQUFlLFVBQVU1QixPQUFWLEVBQW1COztBQUVyQyxZQUFJa1IsU0FBUyxJQUFJQyxVQUFKLEVBQWI7O0FBRUFELGVBQU9FLFVBQVAsQ0FBa0JoRixJQUFsQjtBQUNBOEUsZUFBTzlGLE1BQVAsR0FBZ0IsWUFBWTtBQUN4QnBMLG9CQUFRa1IsT0FBTzNRLE1BQWY7QUFDSCxTQUZEO0FBSUgsS0FUTSxDQUFQO0FBVUg7O0FBRUQsU0FBU3VRLFVBQVQsQ0FBb0IxRSxJQUFwQixFQUEwQjtBQUN0QixXQUFPQSxLQUFLekIsSUFBTCxDQUFVcEUsT0FBVixDQUFrQixNQUFsQixNQUE4QixDQUE5QixJQUFtQzZGLEtBQUt6QixJQUFMLENBQVVwRSxPQUFWLENBQWtCLE1BQWxCLE1BQThCLENBQUMsQ0FBekU7QUFDSDs7QUFFRDs7OztBQUlBLElBQUk4SyxVQUFVLFNBQVNBLE9BQVQsQ0FBaUJ2TCxVQUFqQixFQUE2Qjs7QUFFdkMsU0FBS3NHLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBSzlGLE1BQUwsR0FBYyxFQUFkOztBQUVBbEIsV0FBTyxJQUFQLEVBQWFVLFVBQWIsRUFBeUI7QUFDckJtRixnQkFBUXhILFFBQVFxQyxXQUFXbUYsTUFBWCxJQUFxQixLQUE3QjtBQURhLEtBQXpCOztBQUlBLFFBQUksRUFBRSxLQUFLb0IsT0FBTCxZQUF3QjBELE9BQTFCLENBQUosRUFBd0M7QUFDcEMsYUFBSzFELE9BQUwsR0FBZSxJQUFJMEQsT0FBSixDQUFZLEtBQUsxRCxPQUFqQixDQUFmO0FBQ0g7QUFDSixDQVpEOztBQWNBZ0YsUUFBUXZRLFNBQVIsQ0FBa0JvSyxNQUFsQixHQUEyQixTQUFTQSxNQUFULEdBQWtCO0FBQ3pDLFdBQU83RSxJQUFJLElBQUosQ0FBUDtBQUNILENBRkQ7O0FBSUFnTCxRQUFRdlEsU0FBUixDQUFrQjRLLE9BQWxCLEdBQTRCLFNBQVNBLE9BQVQsR0FBbUI7QUFDM0MsV0FBTyxLQUFLVSxJQUFaO0FBQ0gsQ0FGRDs7QUFJQWlGLFFBQVF2USxTQUFSLENBQWtCK0osV0FBbEIsR0FBZ0MsU0FBU0EsV0FBVCxDQUFzQnVCLElBQXRCLEVBQTRCdEcsVUFBNUIsRUFBd0M7QUFDcEUsV0FBTyxJQUFJNkssUUFBSixDQUFhdkUsSUFBYixFQUFtQmhILE9BQU9VLGNBQWMsRUFBckIsRUFBeUIsRUFBQ0UsS0FBSyxLQUFLa0YsTUFBTCxFQUFOLEVBQXpCLENBQW5CLENBQVA7QUFDSCxDQUZEOztBQUlBOzs7O0FBSUEsSUFBSW9HLGlCQUFpQixFQUFDLFVBQVUsbUNBQVgsRUFBckI7QUFDQSxJQUFJQyxvQkFBb0IsRUFBQyxnQkFBZ0IsZ0NBQWpCLEVBQXhCOztBQUVBLFNBQVN2RCxJQUFULENBQWNsSSxVQUFkLEVBQTBCOztBQUV0QixRQUFJZ0QsT0FBTyxRQUFRLEVBQW5CO0FBQUEsUUFBdUJxRCxTQUFTcUQsT0FBTzFHLEtBQUsvRCxHQUFaLENBQWhDOztBQUVBWSxhQUFTRyxjQUFjLEVBQXZCLEVBQTJCZ0QsS0FBSzlELFFBQWhDLEVBQTBDZ0osS0FBS3JKLE9BQS9DOztBQUVBcUosU0FBS3dELFlBQUwsQ0FBa0JoTSxPQUFsQixDQUEwQixVQUFVeUQsT0FBVixFQUFtQjs7QUFFekMsWUFBSXBGLFNBQVNvRixPQUFULENBQUosRUFBdUI7QUFDbkJBLHNCQUFVK0UsS0FBS3lELFdBQUwsQ0FBaUJ4SSxPQUFqQixDQUFWO0FBQ0g7O0FBRUQsWUFBSWxGLFdBQVdrRixPQUFYLENBQUosRUFBeUI7QUFDckJrRCxtQkFBTzJELEdBQVAsQ0FBVzdHLE9BQVg7QUFDSDtBQUVKLEtBVkQ7O0FBWUEsV0FBT2tELE9BQU8sSUFBSWtGLE9BQUosQ0FBWXZMLFVBQVosQ0FBUCxFQUFnQ25GLElBQWhDLENBQXFDLFVBQVVnTSxRQUFWLEVBQW9COztBQUU1RCxlQUFPQSxTQUFTaUUsRUFBVCxHQUFjakUsUUFBZCxHQUF5Qi9LLFdBQVcxQixNQUFYLENBQWtCeU0sUUFBbEIsQ0FBaEM7QUFFSCxLQUpNLEVBSUosVUFBVUEsUUFBVixFQUFvQjs7QUFFbkIsWUFBSUEsb0JBQW9CK0UsS0FBeEIsRUFBK0I7QUFDM0J6TyxrQkFBTTBKLFFBQU47QUFDSDs7QUFFRCxlQUFPL0ssV0FBVzFCLE1BQVgsQ0FBa0J5TSxRQUFsQixDQUFQO0FBQ0gsS0FYTSxDQUFQO0FBWUg7O0FBRURxQixLQUFLckosT0FBTCxHQUFlLEVBQWY7O0FBRUFxSixLQUFLM0IsT0FBTCxHQUFlO0FBQ1hzRixTQUFLSixpQkFETTtBQUVYSyxVQUFNTCxpQkFGSztBQUdYTSxXQUFPTixpQkFISTtBQUlYakYsWUFBUWlGLGlCQUpHO0FBS1h0RCxZQUFRcUQsY0FMRztBQU1YcEQsWUFBUTtBQU5HLENBQWY7O0FBU0FGLEtBQUt5RCxXQUFMLEdBQW1CLEVBQUMzRCxRQUFRQSxNQUFULEVBQWlCN0MsUUFBUUEsTUFBekIsRUFBaUNtQixNQUFNQSxJQUF2QyxFQUE2Q2dCLE9BQU9BLEtBQXBELEVBQTJEVyxRQUFRQSxNQUFuRSxFQUEyRWxDLE1BQU1BLElBQWpGLEVBQW5CO0FBQ0FtQyxLQUFLd0QsWUFBTCxHQUFvQixDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCLE1BQXJCLEVBQTZCLE9BQTdCLEVBQXNDLFFBQXRDLEVBQWdELE1BQWhELENBQXBCOztBQUVBLENBQUMsS0FBRCxFQUFRLFFBQVIsRUFBa0IsTUFBbEIsRUFBMEIsT0FBMUIsRUFBbUNoTSxPQUFuQyxDQUEyQyxVQUFVc00sU0FBVixFQUFxQjs7QUFFNUQ5RCxTQUFLOEQsU0FBTCxJQUFrQixVQUFVOUwsR0FBVixFQUFlRixVQUFmLEVBQTJCO0FBQ3pDLGVBQU8sS0FBS1YsT0FBT1UsY0FBYyxFQUFyQixFQUF5QixFQUFDRSxLQUFLQSxHQUFOLEVBQVdpRixRQUFRNkcsU0FBbkIsRUFBekIsQ0FBTCxDQUFQO0FBQ0gsS0FGRDtBQUlILENBTkQ7O0FBUUEsQ0FBQyxNQUFELEVBQVMsS0FBVCxFQUFnQixPQUFoQixFQUF5QnRNLE9BQXpCLENBQWlDLFVBQVVzTSxTQUFWLEVBQXFCOztBQUVsRDlELFNBQUs4RCxTQUFMLElBQWtCLFVBQVU5TCxHQUFWLEVBQWUrTCxPQUFmLEVBQXdCak0sVUFBeEIsRUFBb0M7QUFDbEQsZUFBTyxLQUFLVixPQUFPVSxjQUFjLEVBQXJCLEVBQXlCLEVBQUNFLEtBQUtBLEdBQU4sRUFBV2lGLFFBQVE2RyxTQUFuQixFQUE4QjFGLE1BQU0yRixPQUFwQyxFQUF6QixDQUFMLENBQVA7QUFDSCxLQUZEO0FBSUgsQ0FORDs7QUFRQTs7OztBQUlBLFNBQVNDLFFBQVQsQ0FBa0JoTSxHQUFsQixFQUF1Qk0sTUFBdkIsRUFBK0IyTCxPQUEvQixFQUF3Q25NLFVBQXhDLEVBQW9EOztBQUVoRCxRQUFJZ0QsT0FBTyxRQUFRLEVBQW5CO0FBQUEsUUFBdUJvSixXQUFXLEVBQWxDOztBQUVBRCxjQUFVN00sT0FBTyxFQUFQLEVBQ040TSxTQUFTQyxPQURILEVBRU5BLE9BRk0sQ0FBVjs7QUFLQWhOLFNBQUtnTixPQUFMLEVBQWMsVUFBVUUsTUFBVixFQUFrQjdILElBQWxCLEVBQXdCOztBQUVsQzZILGlCQUFTck4sTUFBTSxFQUFDa0IsS0FBS0EsR0FBTixFQUFXTSxRQUFRbEIsT0FBTyxFQUFQLEVBQVdrQixNQUFYLENBQW5CLEVBQU4sRUFBOENSLFVBQTlDLEVBQTBEcU0sTUFBMUQsQ0FBVDs7QUFFQUQsaUJBQVM1SCxJQUFULElBQWlCLFlBQVk7QUFDekIsbUJBQU8sQ0FBQ3hCLEtBQUtzSixLQUFMLElBQWNwRSxJQUFmLEVBQXFCbkosS0FBS3NOLE1BQUwsRUFBYXpOLFNBQWIsQ0FBckIsQ0FBUDtBQUNILFNBRkQ7QUFHSCxLQVBEOztBQVNBLFdBQU93TixRQUFQO0FBQ0g7O0FBRUQsU0FBU3JOLElBQVQsQ0FBY3NOLE1BQWQsRUFBc0I1TSxJQUF0QixFQUE0Qjs7QUFFeEIsUUFBSU8sYUFBYVYsT0FBTyxFQUFQLEVBQVcrTSxNQUFYLENBQWpCO0FBQUEsUUFBcUM3TCxTQUFTLEVBQTlDO0FBQUEsUUFBa0Q4RixJQUFsRDs7QUFFQSxZQUFRN0csS0FBSy9FLE1BQWI7O0FBRUksYUFBSyxDQUFMOztBQUVJOEYscUJBQVNmLEtBQUssQ0FBTCxDQUFUO0FBQ0E2RyxtQkFBTzdHLEtBQUssQ0FBTCxDQUFQOztBQUVBOztBQUVKLGFBQUssQ0FBTDs7QUFFSSxnQkFBSSxzQkFBc0JxRCxJQUF0QixDQUEyQjlDLFdBQVdtRixNQUF0QyxDQUFKLEVBQW1EO0FBQy9DbUIsdUJBQU83RyxLQUFLLENBQUwsQ0FBUDtBQUNILGFBRkQsTUFFTztBQUNIZSx5QkFBU2YsS0FBSyxDQUFMLENBQVQ7QUFDSDs7QUFFRDs7QUFFSixhQUFLLENBQUw7O0FBRUk7O0FBRUo7O0FBRUksa0JBQU0sb0RBQW9EQSxLQUFLL0UsTUFBekQsR0FBa0UsWUFBeEU7QUF6QlI7O0FBNEJBc0YsZUFBV3NHLElBQVgsR0FBa0JBLElBQWxCO0FBQ0F0RyxlQUFXUSxNQUFYLEdBQW9CbEIsT0FBTyxFQUFQLEVBQVdVLFdBQVdRLE1BQXRCLEVBQThCQSxNQUE5QixDQUFwQjs7QUFFQSxXQUFPUixVQUFQO0FBQ0g7O0FBRURrTSxTQUFTQyxPQUFULEdBQW1COztBQUVmcEYsU0FBSyxFQUFDNUIsUUFBUSxLQUFULEVBRlU7QUFHZm9ILFVBQU0sRUFBQ3BILFFBQVEsTUFBVCxFQUhTO0FBSWYvRSxXQUFPLEVBQUMrRSxRQUFRLEtBQVQsRUFKUTtBQUtmcUgsWUFBUSxFQUFDckgsUUFBUSxLQUFULEVBTE87QUFNZnNILFlBQVEsRUFBQ3RILFFBQVEsUUFBVCxFQU5PO0FBT2ZxQixZQUFRLEVBQUNyQixRQUFRLFFBQVQ7O0FBUE8sQ0FBbkI7O0FBV0E7Ozs7QUFJQSxTQUFTdUgsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUI7O0FBRWpCLFFBQUlELE9BQU9FLFNBQVgsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRC9QLFNBQUs4UCxHQUFMOztBQUVBQSxRQUFJek0sR0FBSixHQUFVSyxHQUFWO0FBQ0FvTSxRQUFJRSxJQUFKLEdBQVczRSxJQUFYO0FBQ0F5RSxRQUFJUCxRQUFKLEdBQWVGLFFBQWY7QUFDQVMsUUFBSS9RLE9BQUosR0FBY0UsVUFBZDs7QUFFQXVDLFdBQU95TyxnQkFBUCxDQUF3QkgsSUFBSTNSLFNBQTVCLEVBQXVDOztBQUVuQytSLGNBQU07QUFDRmhHLGlCQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNoQix1QkFBT2xJLFFBQVE4TixJQUFJek0sR0FBWixFQUFpQixJQUFqQixFQUF1QixLQUFLaEIsUUFBTCxDQUFjZ0IsR0FBckMsQ0FBUDtBQUNIO0FBSEMsU0FGNkI7O0FBUW5Db00sZUFBTztBQUNIdkYsaUJBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2hCLHVCQUFPbEksUUFBUThOLElBQUlFLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsS0FBSzNOLFFBQUwsQ0FBYzJOLElBQXRDLENBQVA7QUFDSDtBQUhFLFNBUjRCOztBQWNuQ0csbUJBQVc7QUFDUGpHLGlCQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNoQix1QkFBTzRGLElBQUlQLFFBQUosQ0FBYXBRLElBQWIsQ0FBa0IsSUFBbEIsQ0FBUDtBQUNIO0FBSE0sU0Fkd0I7O0FBb0JuQ2lSLGtCQUFVO0FBQ05sRyxpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDaEIsb0JBQUltRCxTQUFTLElBQWI7O0FBRUEsdUJBQU8sVUFBVXZRLFFBQVYsRUFBb0I7QUFBRSwyQkFBTyxJQUFJZ1QsSUFBSS9RLE9BQVIsQ0FBZ0JqQyxRQUFoQixFQUEwQnVRLE1BQTFCLENBQVA7QUFBMkMsaUJBQXhFO0FBQ0g7QUFMSzs7QUFwQnlCLEtBQXZDO0FBNkJIOztBQUVELElBQUksT0FBT3JPLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE9BQU84USxHQUE1QyxFQUFpRDtBQUM3QzlRLFdBQU84USxHQUFQLENBQVczQyxHQUFYLENBQWUwQyxNQUFmO0FBQ0g7O2tCQUVjQSxNO1FBQ05uTSxHLEdBQUFBLEc7UUFBSzJILEksR0FBQUEsSTtRQUFNZ0UsUSxHQUFBQSxRIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHZ1ZS1yZXNvdXJjZSB2MS4zLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWdla2l0L3Z1ZS1yZXNvdXJjZVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUHJvbWlzZXMvQSsgcG9seWZpbGwgdjEuMS40IChodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL3Byb21pcylcbiAqL1xuXG52YXIgUkVTT0xWRUQgPSAwO1xudmFyIFJFSkVDVEVEID0gMTtcbnZhciBQRU5ESU5HICA9IDI7XG5cbmZ1bmN0aW9uIFByb21pc2UkMShleGVjdXRvcikge1xuXG4gICAgdGhpcy5zdGF0ZSA9IFBFTkRJTkc7XG4gICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlJDEucmVqZWN0ID0gZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChyKTtcbiAgICB9KTtcbn07XG5cblByb21pc2UkMS5yZXNvbHZlID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoeCk7XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDEuYWxsID0gZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY291bnQgPSAwLCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoaXRlcmFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlcihpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFByb21pc2UkMS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmVyKGkpLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5Qcm9taXNlJDEucmFjZSA9IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFByb21pc2UkMS5yZXNvbHZlKGl0ZXJhYmxlW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnZhciBwJDEgPSBQcm9taXNlJDEucHJvdG90eXBlO1xuXG5wJDEucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICAgIGlmICh4ID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlIHNldHRsZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0aGVuID0geCAmJiB4Wyd0aGVuJ107XG5cbiAgICAgICAgICAgIGlmICh4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoZW4uY2FsbCh4LCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnN0YXRlID0gUkVTT0xWRUQ7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB4O1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5yZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgaWYgKHByb21pc2Uuc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZSBzZXR0bGVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gcmVhc29uO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH1cbn07XG5cbnAkMS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvbWlzZS5zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICAgICAgd2hpbGUgKHByb21pc2UuZGVmZXJyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcHJvbWlzZS5kZWZlcnJlZC5zaGlmdCgpLFxuICAgICAgICAgICAgICAgICAgICBvblJlc29sdmVkID0gZGVmZXJyZWRbMF0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgPSBkZWZlcnJlZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IGRlZmVycmVkWzJdLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QgPSBkZWZlcnJlZFszXTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnN0YXRlID09PSBSRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvblJlc29sdmVkLmNhbGwodW5kZWZpbmVkLCBwcm9taXNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob25SZWplY3RlZC5jYWxsKHVuZGVmaW5lZCwgcHJvbWlzZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHJvbWlzZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnAkMS50aGVuID0gZnVuY3Rpb24gdGhlbihvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9taXNlLmRlZmVycmVkLnB1c2goW29uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICBwcm9taXNlLm5vdGlmeSgpO1xuICAgIH0pO1xufTtcblxucCQxLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFByb21pc2UgYWRhcHRlci5cbiAqL1xuXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VPYmooZXhlY3V0b3IsIGNvbnRleHQpIHtcblxuICAgIGlmIChleGVjdXRvciBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gZXhlY3V0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZXhlY3V0b3IuYmluZChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUHJvbWlzZU9iai5hbGwgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooUHJvbWlzZS5hbGwoaXRlcmFibGUpLCBjb250ZXh0KTtcbn07XG5cblByb21pc2VPYmoucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJlc29sdmUodmFsdWUpLCBjb250ZXh0KTtcbn07XG5cblByb21pc2VPYmoucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbiwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJlamVjdChyZWFzb24pLCBjb250ZXh0KTtcbn07XG5cblByb21pc2VPYmoucmFjZSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihQcm9taXNlLnJhY2UoaXRlcmFibGUpLCBjb250ZXh0KTtcbn07XG5cbnZhciBwID0gUHJvbWlzZU9iai5wcm90b3R5cGU7XG5cbnAuYmluZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnAudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG5cbiAgICBpZiAoZnVsZmlsbGVkICYmIGZ1bGZpbGxlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICBmdWxmaWxsZWQgPSBmdWxmaWxsZWQuYmluZCh0aGlzLmNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChyZWplY3RlZCAmJiByZWplY3RlZC5iaW5kICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICByZWplY3RlZCA9IHJlamVjdGVkLmJpbmQodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmoodGhpcy5wcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCksIHRoaXMuY29udGV4dCk7XG59O1xuXG5wLmNhdGNoID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG5cbiAgICBpZiAocmVqZWN0ZWQgJiYgcmVqZWN0ZWQuYmluZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSByZWplY3RlZC5iaW5kKHRoaXMuY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKHRoaXMucHJvbWlzZS5jYXRjaChyZWplY3RlZCksIHRoaXMuY29udGV4dCk7XG59O1xuXG5wLmZpbmFsbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgcmVmID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG5cbnZhciByZWYkMSA9IFtdO1xudmFyIHNsaWNlID0gcmVmJDEuc2xpY2U7XG52YXIgZGVidWcgPSBmYWxzZTtcbnZhciBudGljaztcblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgVXRpbCA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgY29uZmlnID0gcmVmLmNvbmZpZztcbiAgICB2YXIgbmV4dFRpY2sgPSByZWYubmV4dFRpY2s7XG5cbiAgICBudGljayA9IG5leHRUaWNrO1xuICAgIGRlYnVnID0gY29uZmlnLmRlYnVnIHx8ICFjb25maWcuc2lsZW50O1xufTtcblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW1Z1ZVJlc291cmNlIHdhcm5dOiAnICsgbXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soY2IsIGN0eCkge1xuICAgIHJldHVybiBudGljayhjYiwgY3R4KTtcbn1cblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKSA6ICcnO1xufVxuXG5mdW5jdGlvbiB0b0xvd2VyKHN0cikge1xuICAgIHJldHVybiBzdHIgPyBzdHIudG9Mb3dlckNhc2UoKSA6ICcnO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKHN0cikge1xuICAgIHJldHVybiBzdHIgPyBzdHIudG9VcHBlckNhc2UoKSA6ICcnO1xufVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gaXNCbG9iKG9iaikge1xuICAgIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQmxvYjtcbn1cblxuZnVuY3Rpb24gaXNGb3JtRGF0YShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cblxuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlT2JqLnJlc29sdmUodmFsdWUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbnMoZm4sIG9iaiwgb3B0cykge1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBvcHRzID0gb3B0cy5jYWxsKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlKGZuLmJpbmQoeyR2bTogb2JqLCAkb3B0aW9uczogb3B0c30pLCBmbiwgeyRvcHRpb25zOiBvcHRzfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvcikge1xuXG4gICAgdmFyIGksIGtleTtcblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChvYmpbaV0sIG9ialtpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKG9ialtrZXldLCBvYmpba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IF9hc3NpZ247XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xuXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NpZ24odGFyZ2V0KSB7XG5cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIGRlZXApIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChkZWVwICYmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBpc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiAhaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFJvb3QgUHJlZml4IFRyYW5zZm9ybS5cbiAqL1xuXG52YXIgcm9vdCA9IGZ1bmN0aW9uIChvcHRpb25zJCQxLCBuZXh0KSB7XG5cbiAgICB2YXIgdXJsID0gbmV4dChvcHRpb25zJCQxKTtcblxuICAgIGlmIChpc1N0cmluZyhvcHRpb25zJCQxLnJvb3QpICYmICF1cmwubWF0Y2goL14oaHR0cHM/Oik/XFwvLykpIHtcbiAgICAgICAgdXJsID0gb3B0aW9ucyQkMS5yb290ICsgJy8nICsgdXJsO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IFBhcmFtZXRlciBUcmFuc2Zvcm0uXG4gKi9cblxudmFyIHF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMkJDEsIG5leHQpIHtcblxuICAgIHZhciB1cmxQYXJhbXMgPSBPYmplY3Qua2V5cyhVcmwub3B0aW9ucy5wYXJhbXMpLCBxdWVyeSA9IHt9LCB1cmwgPSBuZXh0KG9wdGlvbnMkJDEpO1xuXG4gICAgZWFjaChvcHRpb25zJCQxLnBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHVybFBhcmFtcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHF1ZXJ5ID0gVXJsLnBhcmFtcyhxdWVyeSk7XG5cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09IC0xID8gJz8nIDogJyYnKSArIHF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFVSTCBUZW1wbGF0ZSB2Mi4wLjYgKGh0dHBzOi8vZ2l0aHViLmNvbS9icmFtc3RlaW4vdXJsLXRlbXBsYXRlKVxuICovXG5cbmZ1bmN0aW9uIGV4cGFuZCh1cmwsIHBhcmFtcywgdmFyaWFibGVzKSB7XG5cbiAgICB2YXIgdG1wbCA9IHBhcnNlKHVybCksIGV4cGFuZGVkID0gdG1wbC5leHBhbmQocGFyYW1zKTtcblxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyaWFibGVzLnB1c2guYXBwbHkodmFyaWFibGVzLCB0bXBsLnZhcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUpIHtcblxuICAgIHZhciBvcGVyYXRvcnMgPSBbJysnLCAnIycsICcuJywgJy8nLCAnOycsICc/JywgJyYnXSwgdmFyaWFibGVzID0gW107XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YXJzOiB2YXJpYWJsZXMsXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW15cXHtcXH1dKylcXH18KFteXFx7XFx9XSspL2csIGZ1bmN0aW9uIChfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBudWxsLCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZXhwcmVzc2lvbi5jaGFyQXQoMCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBleHByZXNzaW9uLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uc3BsaXQoLywvZykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSAvKFteOlxcKl0qKSg/OjooXFxkKyl8KFxcKikpPy8uZXhlYyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMucHVzaCh0bXBbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgJiYgb3BlcmF0b3IgIT09ICcrJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJywnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9ICcmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5sZW5ndGggIT09IDAgPyBvcGVyYXRvciA6ICcnKSArIHZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IG51bGwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIHRtcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbignLCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc7Jykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyAmJiAob3BlcmF0b3IgPT09ICcmJyB8fCBvcGVyYXRvciA9PT0gJz8nKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgICByZXR1cm4gb3BlcmF0b3IgPT09ICc7JyB8fCBvcGVyYXRvciA9PT0gJyYnIHx8IG9wZXJhdG9yID09PSAnPyc7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG5cbiAgICB2YWx1ZSA9IChvcGVyYXRvciA9PT0gJysnIHx8IG9wZXJhdG9yID09PSAnIycpID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGlmICghLyVbMC05QS1GYS1mXS8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydDtcbiAgICB9KS5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBVUkwgVGVtcGxhdGUgKFJGQyA2NTcwKSBUcmFuc2Zvcm0uXG4gKi9cblxudmFyIHRlbXBsYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIHZhciB2YXJpYWJsZXMgPSBbXSwgdXJsID0gZXhwYW5kKG9wdGlvbnMudXJsLCBvcHRpb25zLnBhcmFtcywgdmFyaWFibGVzKTtcblxuICAgIHZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zW2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBVUkwgdGVtcGxhdGluZy5cbiAqL1xuXG5mdW5jdGlvbiBVcmwodXJsLCBwYXJhbXMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCB7fSwgb3B0aW9ucyQkMSA9IHVybCwgdHJhbnNmb3JtO1xuXG4gICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgb3B0aW9ucyQkMSA9IHt1cmw6IHVybCwgcGFyYW1zOiBwYXJhbXN9O1xuICAgIH1cblxuICAgIG9wdGlvbnMkJDEgPSBtZXJnZSh7fSwgVXJsLm9wdGlvbnMsIHNlbGYuJG9wdGlvbnMsIG9wdGlvbnMkJDEpO1xuXG4gICAgVXJsLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuXG4gICAgICAgIGlmIChpc1N0cmluZyhoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IFVybC50cmFuc2Zvcm1baGFuZGxlcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gZmFjdG9yeShoYW5kbGVyLCB0cmFuc2Zvcm0sIHNlbGYuJHZtKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtKG9wdGlvbnMkJDEpO1xufVxuXG4vKipcbiAqIFVybCBvcHRpb25zLlxuICovXG5cblVybC5vcHRpb25zID0ge1xuICAgIHVybDogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwYXJhbXM6IHt9XG59O1xuXG4vKipcbiAqIFVybCB0cmFuc2Zvcm1zLlxuICovXG5cblVybC50cmFuc2Zvcm0gPSB7dGVtcGxhdGU6IHRlbXBsYXRlLCBxdWVyeTogcXVlcnksIHJvb3Q6IHJvb3R9O1xuVXJsLnRyYW5zZm9ybXMgPSBbJ3RlbXBsYXRlJywgJ3F1ZXJ5JywgJ3Jvb3QnXTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVXJsIHBhcmFtZXRlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cblVybC5wYXJhbXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICB2YXIgcGFyYW1zID0gW10sIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaik7XG5cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBVUkwgYW5kIHJldHVybiBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKi9cblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgaWYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSkge1xuICAgICAgICBlbC5ocmVmID0gdXJsO1xuICAgICAgICB1cmwgPSBlbC5ocmVmO1xuICAgIH1cblxuICAgIGVsLmhyZWYgPSB1cmw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiBlbC5ocmVmLFxuICAgICAgICBwcm90b2NvbDogZWwucHJvdG9jb2wgPyBlbC5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBwb3J0OiBlbC5wb3J0LFxuICAgICAgICBob3N0OiBlbC5ob3N0LFxuICAgICAgICBob3N0bmFtZTogZWwuaG9zdG5hbWUsXG4gICAgICAgIHBhdGhuYW1lOiBlbC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IGVsLnBhdGhuYW1lIDogJy8nICsgZWwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogZWwuc2VhcmNoID8gZWwuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogZWwuaGFzaCA/IGVsLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJ1xuICAgIH07XG59O1xuXG5mdW5jdGlvbiBmYWN0b3J5KGhhbmRsZXIsIG5leHQsIHZtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zJCQxKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodm0sIG9wdGlvbnMkJDEsIG5leHQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgc2NvcGUpIHtcblxuICAgIHZhciBhcnJheSA9IGlzQXJyYXkob2JqKSwgcGxhaW4gPSBpc1BsYWluT2JqZWN0KG9iaiksIGhhc2g7XG5cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblxuICAgICAgICBoYXNoID0gaXNPYmplY3QodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAga2V5ID0gc2NvcGUgKyAnWycgKyAocGxhaW4gfHwgaGFzaCA/IGtleSA6ICcnKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc2gpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIFhEb21haW4gY2xpZW50IChJbnRlcm5ldCBFeHBsb3JlcikuXG4gKi9cblxudmFyIHhkckNsaWVudCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLCBoYW5kbGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcblxuXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsb2FkJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IDUwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbmRXaXRoKHhkci5yZXNwb25zZVRleHQsIHtzdGF0dXM6IHN0YXR1c30pKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LmFib3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geGRyLmFib3J0KCk7IH07XG5cbiAgICAgICAgeGRyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCkpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHhkci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgeGRyLm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHhkci5vbmFib3J0ID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9uZXJyb3IgPSBoYW5kbGVyO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gaGFuZGxlcjtcbiAgICAgICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgeGRyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDT1JTIEludGVyY2VwdG9yLlxuICovXG5cbnZhciBTVVBQT1JUU19DT1JTID0gaW5Ccm93c2VyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG52YXIgY29ycyA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoaW5Ccm93c2VyKSB7XG5cbiAgICAgICAgdmFyIG9yZ1VybCA9IFVybC5wYXJzZShsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgdmFyIHJlcVVybCA9IFVybC5wYXJzZShyZXF1ZXN0LmdldFVybCgpKTtcblxuICAgICAgICBpZiAocmVxVXJsLnByb3RvY29sICE9PSBvcmdVcmwucHJvdG9jb2wgfHwgcmVxVXJsLmhvc3QgIT09IG9yZ1VybC5ob3N0KSB7XG5cbiAgICAgICAgICAgIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdC5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIVNVUFBPUlRTX0NPUlMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNsaWVudCA9IHhkckNsaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHQoKTtcbn07XG5cbi8qKlxuICogQm9keSBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIgYm9keSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAoaXNGb3JtRGF0YShyZXF1ZXN0LmJvZHkpKSB7XG5cbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmRlbGV0ZSgnQ29udGVudC1UeXBlJyk7XG5cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlcXVlc3QuYm9keSkgfHwgaXNBcnJheShyZXF1ZXN0LmJvZHkpKSB7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuZW11bGF0ZUpTT04pIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IFVybC5wYXJhbXMocmVxdWVzdC5ib2R5KTtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuYm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2RhdGEnLCB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keVRleHQgPyB3aGVuKHJlc3BvbnNlLnRleHQoKSwgZnVuY3Rpb24gKHRleHQpIHtcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgfHwgJyc7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA9PT0gMCB8fCBpc0pzb24odGV4dCkpIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICAgICAgfSkgOiByZXNwb25zZTtcblxuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gaXNKc29uKHN0cikge1xuXG4gICAgdmFyIHN0YXJ0ID0gc3RyLm1hdGNoKC9eXFxbfF5cXHsoPyFcXHspLyksIGVuZCA9IHsnWyc6IC9dJC8sICd7JzogL30kL307XG5cbiAgICByZXR1cm4gc3RhcnQgJiYgZW5kW3N0YXJ0WzBdXS50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogSlNPTlAgY2xpZW50IChCcm93c2VyKS5cbiAqL1xuXG52YXIganNvbnBDbGllbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZU9iaihmdW5jdGlvbiAocmVzb2x2ZSkge1xuXG4gICAgICAgIHZhciBuYW1lID0gcmVxdWVzdC5qc29ucCB8fCAnY2FsbGJhY2snLCBjYWxsYmFjayA9IHJlcXVlc3QuanNvbnBDYWxsYmFjayB8fCAnX2pzb25wJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKSwgYm9keSA9IG51bGwsIGhhbmRsZXIsIHNjcmlwdDtcblxuICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcblxuXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsb2FkJyAmJiBib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gNTAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdHVzICYmIHdpbmRvd1tjYWxsYmFja10pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25kV2l0aChib2R5LCB7c3RhdHVzOiBzdGF0dXN9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93W2NhbGxiYWNrXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHt0eXBlOiAnYWJvcnQnfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5wYXJhbXNbbmFtZV0gPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAocmVxdWVzdC50aW1lb3V0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlcXVlc3QuYWJvcnQsIHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHJlcXVlc3QuZ2V0VXJsKCk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBoYW5kbGVyO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGhhbmRsZXI7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBKU09OUCBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIganNvbnAgPSBmdW5jdGlvbiAocmVxdWVzdCwgbmV4dCkge1xuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09ICdKU09OUCcpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnQgPSBqc29ucENsaWVudDtcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIEJlZm9yZSBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIgYmVmb3JlID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHJlcXVlc3QuYmVmb3JlKSkge1xuICAgICAgICByZXF1ZXN0LmJlZm9yZS5jYWxsKHRoaXMsIHJlcXVlc3QpO1xuICAgIH1cblxuICAgIG5leHQoKTtcbn07XG5cbi8qKlxuICogSFRUUCBtZXRob2Qgb3ZlcnJpZGUgSW50ZXJjZXB0b3IuXG4gKi9cblxudmFyIG1ldGhvZCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBuZXh0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5lbXVsYXRlSFRUUCAmJiAvXihQVVR8UEFUQ0h8REVMRVRFKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgcmVxdWVzdC5tZXRob2QpO1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9ICdQT1NUJztcbiAgICB9XG5cbiAgICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIEhlYWRlciBJbnRlcmNlcHRvci5cbiAqL1xuXG52YXIgaGVhZGVyID0gZnVuY3Rpb24gKHJlcXVlc3QsIG5leHQpIHtcblxuICAgIHZhciBoZWFkZXJzID0gYXNzaWduKHt9LCBIdHRwLmhlYWRlcnMuY29tbW9uLFxuICAgICAgICAhcmVxdWVzdC5jcm9zc09yaWdpbiA/IEh0dHAuaGVhZGVycy5jdXN0b20gOiB7fSxcbiAgICAgICAgSHR0cC5oZWFkZXJzW3RvTG93ZXIocmVxdWVzdC5tZXRob2QpXVxuICAgICk7XG5cbiAgICBlYWNoKGhlYWRlcnMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIFhNTEh0dHAgY2xpZW50IChCcm93c2VyKS5cbiAqL1xuXG52YXIgeGhyQ2xpZW50ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYmooZnVuY3Rpb24gKHJlc29sdmUpIHtcblxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25kV2l0aChcbiAgICAgICAgICAgICAgICAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cywgLy8gSUU5IHN0YXR1cyBidWdcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHRyaW0oeGhyLnN0YXR1c1RleHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZWFjaCh0cmltKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5hcHBlbmQocm93LnNsaWNlKDAsIHJvdy5pbmRleE9mKCc6JykpLCByb3cuc2xpY2Uocm93LmluZGV4T2YoJzonKSArIDEpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LmFib3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geGhyLmFib3J0KCk7IH07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCByZXF1ZXN0LnByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHJlcXVlc3QucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QuZ2V0VXJsKCksIHRydWUpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHhoci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUeXBlICYmICdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzIHx8IHJlcXVlc3QuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeGhyLm9ubG9hZCA9IGhhbmRsZXI7XG4gICAgICAgIHhoci5vbmFib3J0ID0gaGFuZGxlcjtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBoYW5kbGVyO1xuICAgICAgICB4aHIub250aW1lb3V0ID0gaGFuZGxlcjtcbiAgICAgICAgeGhyLnNlbmQocmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBIdHRwIGNsaWVudCAoTm9kZSkuXG4gKi9cblxudmFyIG5vZGVDbGllbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgdmFyIGNsaWVudCA9IHJlcXVpcmUoJ2dvdCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHVybCA9IHJlcXVlc3QuZ2V0VXJsKCk7XG4gICAgICAgIHZhciBib2R5ID0gcmVxdWVzdC5nZXRCb2R5KCk7XG4gICAgICAgIHZhciBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB7fSwgaGFuZGxlcjtcblxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xpZW50KHVybCwge2JvZHk6IGJvZHksIG1ldGhvZDogbWV0aG9kLCBoZWFkZXJzOiBoZWFkZXJzfSkudGhlbihoYW5kbGVyID0gZnVuY3Rpb24gKHJlc3ApIHtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25kV2l0aChyZXNwLmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRyaW0ocmVzcC5zdGF0dXNNZXNzYWdlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGVhY2gocmVzcC5oZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yJCQxKSB7IHJldHVybiBoYW5kbGVyKGVycm9yJCQxLnJlc3BvbnNlKTsgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEJhc2UgY2xpZW50LlxuICovXG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgdmFyIHJlcUhhbmRsZXJzID0gW3NlbmRSZXF1ZXN0XSwgcmVzSGFuZGxlcnMgPSBbXSwgaGFuZGxlcjtcblxuICAgIGlmICghaXNPYmplY3QoY29udGV4dCkpIHtcbiAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ2xpZW50KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gcmVxSGFuZGxlcnMucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgcmVxdWVzdCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybigoXCJJbnZhbGlkIGludGVyY2VwdG9yIG9mIHR5cGUgXCIgKyAodHlwZW9mIGhhbmRsZXIpICsgXCIsIG11c3QgYmUgYSBmdW5jdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQocmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHJlc3BvbnNlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc0hhbmRsZXJzLnVuc2hpZnQocmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZXNwb25zZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXNIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHdoZW4ocmVzcG9uc2UsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoY29udGV4dCwgcmVzcG9uc2UpIHx8IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoZW4ocmVzcG9uc2UsIHJlc29sdmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoKTtcblxuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBDbGllbnQudXNlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmVxSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENsaWVudDtcbn07XG5cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIHJlc29sdmUpIHtcblxuICAgIHZhciBjbGllbnQgPSByZXF1ZXN0LmNsaWVudCB8fCAoaW5Ccm93c2VyID8geGhyQ2xpZW50IDogbm9kZUNsaWVudCk7XG5cbiAgICByZXNvbHZlKGNsaWVudChyZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogSFRUUCBIZWFkZXJzLlxuICovXG5cbnZhciBIZWFkZXJzID0gZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblxuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBlYWNoKGhlYWRlcnMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkgeyByZXR1cm4gdGhpcyQxLmFwcGVuZChuYW1lLCB2YWx1ZSk7IH0pO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChuYW1lKSB7XG4gICAgcmV0dXJuIGdldE5hbWUodGhpcy5tYXAsIG5hbWUpICE9PSBudWxsO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChuYW1lKSB7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW2dldE5hbWUodGhpcy5tYXAsIG5hbWUpXTtcblxuICAgIHJldHVybiBsaXN0ID8gbGlzdC5qb2luKCkgOiBudWxsO1xufTtcblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gZ2V0QWxsIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW2dldE5hbWUodGhpcy5tYXAsIG5hbWUpXSB8fCBbXTtcbn07XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKGdldE5hbWUodGhpcy5tYXAsIG5hbWUpIHx8IG5hbWUpXSA9IFt0cmltKHZhbHVlKV07XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG5hbWUsIHZhbHVlKXtcblxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbZ2V0TmFtZSh0aGlzLm1hcCwgbmFtZSldO1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgICAgbGlzdC5wdXNoKHRyaW0odmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuSGVhZGVycy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gZGVsZXRlJDEgKG5hbWUpe1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtnZXROYW1lKHRoaXMubWFwLCBuYW1lKV07XG59O1xuXG5IZWFkZXJzLnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiBkZWxldGVBbGwgKCl7XG4gICAgdGhpcy5tYXAgPSB7fTtcbn07XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGVhY2godGhpcy5tYXAsIGZ1bmN0aW9uIChsaXN0LCBuYW1lKSB7XG4gICAgICAgIGVhY2gobGlzdCwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzJDEpOyB9KTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldE5hbWUobWFwLCBuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgIHJldHVybiB0b0xvd2VyKG5hbWUpID09PSB0b0xvd2VyKGN1cnIpID8gY3VyciA6IHByZXY7XG4gICAgfSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuXG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaW0obmFtZSk7XG59XG5cbi8qKlxuICogSFRUUCBSZXNwb25zZS5cbiAqL1xuXG52YXIgUmVzcG9uc2UgPSBmdW5jdGlvbiBSZXNwb25zZShib2R5LCByZWYpIHtcbiAgICB2YXIgdXJsID0gcmVmLnVybDtcbiAgICB2YXIgaGVhZGVycyA9IHJlZi5oZWFkZXJzO1xuICAgIHZhciBzdGF0dXMgPSByZWYuc3RhdHVzO1xuICAgIHZhciBzdGF0dXNUZXh0ID0gcmVmLnN0YXR1c1RleHQ7XG5cblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMub2sgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cyB8fCAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIGlmIChpc1N0cmluZyhib2R5KSkge1xuXG4gICAgICAgIHRoaXMuYm9keVRleHQgPSBib2R5O1xuXG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblxuICAgICAgICB0aGlzLmJvZHlCbG9iID0gYm9keTtcblxuICAgICAgICBpZiAoaXNCbG9iVGV4dChib2R5KSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5VGV4dCA9IGJsb2JUZXh0KGJvZHkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiBibG9iICgpIHtcbiAgICByZXR1cm4gd2hlbih0aGlzLmJvZHlCbG9iKTtcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gdGV4dCAoKSB7XG4gICAgcmV0dXJuIHdoZW4odGhpcy5ib2R5VGV4dCk7XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIGpzb24gKCkge1xuICAgIHJldHVybiB3aGVuKHRoaXMudGV4dCgpLCBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTsgfSk7XG59O1xuXG5mdW5jdGlvbiBibG9iVGV4dChib2R5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlT2JqKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYm9keSk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQmxvYlRleHQoYm9keSkge1xuICAgIHJldHVybiBib2R5LnR5cGUuaW5kZXhPZigndGV4dCcpID09PSAwIHx8IGJvZHkudHlwZS5pbmRleE9mKCdqc29uJykgIT09IC0xO1xufVxuXG4vKipcbiAqIEhUVFAgUmVxdWVzdC5cbiAqL1xuXG52YXIgUmVxdWVzdCA9IGZ1bmN0aW9uIFJlcXVlc3Qob3B0aW9ucyQkMSkge1xuXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xuXG4gICAgYXNzaWduKHRoaXMsIG9wdGlvbnMkJDEsIHtcbiAgICAgICAgbWV0aG9kOiB0b1VwcGVyKG9wdGlvbnMkJDEubWV0aG9kIHx8ICdHRVQnKVxuICAgIH0pO1xuXG4gICAgaWYgKCEodGhpcy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICB9XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRVcmwgPSBmdW5jdGlvbiBnZXRVcmwgKCl7XG4gICAgcmV0dXJuIFVybCh0aGlzKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiBnZXRCb2R5ICgpe1xuICAgIHJldHVybiB0aGlzLmJvZHk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kV2l0aCA9IGZ1bmN0aW9uIHJlc3BvbmRXaXRoIChib2R5LCBvcHRpb25zJCQxKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBhc3NpZ24ob3B0aW9ucyQkMSB8fCB7fSwge3VybDogdGhpcy5nZXRVcmwoKX0pKTtcbn07XG5cbi8qKlxuICogU2VydmljZSBmb3Igc2VuZGluZyBuZXR3b3JrIHJlcXVlc3RzLlxuICovXG5cbnZhciBDT01NT05fSEVBREVSUyA9IHsnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKid9O1xudmFyIEpTT05fQ09OVEVOVF9UWVBFID0geydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04J307XG5cbmZ1bmN0aW9uIEh0dHAob3B0aW9ucyQkMSkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LCBjbGllbnQgPSBDbGllbnQoc2VsZi4kdm0pO1xuXG4gICAgZGVmYXVsdHMob3B0aW9ucyQkMSB8fCB7fSwgc2VsZi4kb3B0aW9ucywgSHR0cC5vcHRpb25zKTtcblxuICAgIEh0dHAuaW50ZXJjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcblxuICAgICAgICBpZiAoaXNTdHJpbmcoaGFuZGxlcikpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIdHRwLmludGVyY2VwdG9yW2hhbmRsZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgIGNsaWVudC51c2UoaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNsaWVudChuZXcgUmVxdWVzdChvcHRpb25zJCQxKSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyByZXNwb25zZSA6IFByb21pc2VPYmoucmVqZWN0KHJlc3BvbnNlKTtcblxuICAgIH0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcihyZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZU9iai5yZWplY3QocmVzcG9uc2UpO1xuICAgIH0pO1xufVxuXG5IdHRwLm9wdGlvbnMgPSB7fTtcblxuSHR0cC5oZWFkZXJzID0ge1xuICAgIHB1dDogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgcG9zdDogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgcGF0Y2g6IEpTT05fQ09OVEVOVF9UWVBFLFxuICAgIGRlbGV0ZTogSlNPTl9DT05URU5UX1RZUEUsXG4gICAgY29tbW9uOiBDT01NT05fSEVBREVSUyxcbiAgICBjdXN0b206IHt9XG59O1xuXG5IdHRwLmludGVyY2VwdG9yID0ge2JlZm9yZTogYmVmb3JlLCBtZXRob2Q6IG1ldGhvZCwgYm9keTogYm9keSwganNvbnA6IGpzb25wLCBoZWFkZXI6IGhlYWRlciwgY29yczogY29yc307XG5IdHRwLmludGVyY2VwdG9ycyA9IFsnYmVmb3JlJywgJ21ldGhvZCcsICdib2R5JywgJ2pzb25wJywgJ2hlYWRlcicsICdjb3JzJ107XG5cblsnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJywgJ2pzb25wJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kJCQxKSB7XG5cbiAgICBIdHRwW21ldGhvZCQkMV0gPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zJCQxKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zJCQxIHx8IHt9LCB7dXJsOiB1cmwsIG1ldGhvZDogbWV0aG9kJCQxfSkpO1xuICAgIH07XG5cbn0pO1xuXG5bJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kJCQxKSB7XG5cbiAgICBIdHRwW21ldGhvZCQkMV0gPSBmdW5jdGlvbiAodXJsLCBib2R5JCQxLCBvcHRpb25zJCQxKSB7XG4gICAgICAgIHJldHVybiB0aGlzKGFzc2lnbihvcHRpb25zJCQxIHx8IHt9LCB7dXJsOiB1cmwsIG1ldGhvZDogbWV0aG9kJCQxLCBib2R5OiBib2R5JCQxfSkpO1xuICAgIH07XG5cbn0pO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIGludGVyYWN0aW5nIHdpdGggUkVTVGZ1bCBzZXJ2aWNlcy5cbiAqL1xuXG5mdW5jdGlvbiBSZXNvdXJjZSh1cmwsIHBhcmFtcywgYWN0aW9ucywgb3B0aW9ucyQkMSkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IHt9LCByZXNvdXJjZSA9IHt9O1xuXG4gICAgYWN0aW9ucyA9IGFzc2lnbih7fSxcbiAgICAgICAgUmVzb3VyY2UuYWN0aW9ucyxcbiAgICAgICAgYWN0aW9uc1xuICAgICk7XG5cbiAgICBlYWNoKGFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24sIG5hbWUpIHtcblxuICAgICAgICBhY3Rpb24gPSBtZXJnZSh7dXJsOiB1cmwsIHBhcmFtczogYXNzaWduKHt9LCBwYXJhbXMpfSwgb3B0aW9ucyQkMSwgYWN0aW9uKTtcblxuICAgICAgICByZXNvdXJjZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoc2VsZi4kaHR0cCB8fCBIdHRwKShvcHRzKGFjdGlvbiwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIG9wdHMoYWN0aW9uLCBhcmdzKSB7XG5cbiAgICB2YXIgb3B0aW9ucyQkMSA9IGFzc2lnbih7fSwgYWN0aW9uKSwgcGFyYW1zID0ge30sIGJvZHk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cbiAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgYm9keSA9IGFyZ3NbMV07XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcblxuICAgICAgICAgICAgaWYgKC9eKFBPU1R8UFVUfFBBVENIKSQvaS50ZXN0KG9wdGlvbnMkJDEubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB1cCB0byAyIGFyZ3VtZW50cyBbcGFyYW1zLCBib2R5XSwgZ290ICcgKyBhcmdzLmxlbmd0aCArICcgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICBvcHRpb25zJCQxLmJvZHkgPSBib2R5O1xuICAgIG9wdGlvbnMkJDEucGFyYW1zID0gYXNzaWduKHt9LCBvcHRpb25zJCQxLnBhcmFtcywgcGFyYW1zKTtcblxuICAgIHJldHVybiBvcHRpb25zJCQxO1xufVxuXG5SZXNvdXJjZS5hY3Rpb25zID0ge1xuXG4gICAgZ2V0OiB7bWV0aG9kOiAnR0VUJ30sXG4gICAgc2F2ZToge21ldGhvZDogJ1BPU1QnfSxcbiAgICBxdWVyeToge21ldGhvZDogJ0dFVCd9LFxuICAgIHVwZGF0ZToge21ldGhvZDogJ1BVVCd9LFxuICAgIHJlbW92ZToge21ldGhvZDogJ0RFTEVURSd9LFxuICAgIGRlbGV0ZToge21ldGhvZDogJ0RFTEVURSd9XG5cbn07XG5cbi8qKlxuICogSW5zdGFsbCBwbHVnaW4uXG4gKi9cblxuZnVuY3Rpb24gcGx1Z2luKFZ1ZSkge1xuXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwoVnVlKTtcblxuICAgIFZ1ZS51cmwgPSBVcmw7XG4gICAgVnVlLmh0dHAgPSBIdHRwO1xuICAgIFZ1ZS5yZXNvdXJjZSA9IFJlc291cmNlO1xuICAgIFZ1ZS5Qcm9taXNlID0gUHJvbWlzZU9iajtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZ1ZS5wcm90b3R5cGUsIHtcblxuICAgICAgICAkdXJsOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyhWdWUudXJsLCB0aGlzLCB0aGlzLiRvcHRpb25zLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgJGh0dHA6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zKFZ1ZS5odHRwLCB0aGlzLCB0aGlzLiRvcHRpb25zLmh0dHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRyZXNvdXJjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5yZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICRwcm9taXNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhlY3V0b3IpIHsgcmV0dXJuIG5ldyBWdWUuUHJvbWlzZShleGVjdXRvciwgdGhpcyQxKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luO1xuZXhwb3J0IHsgVXJsLCBIdHRwLCBSZXNvdXJjZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMS4zLjFAdnVlLXJlc291cmNlL2Rpc3QvdnVlLXJlc291cmNlLmVzMjAxNS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Vue.js v2.2.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString(val) {\n  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject(obj) {\n  return toString.call(obj) === OBJECT_STRING;\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Perform no operation.\n */\nfunction noop() {}\n\n/**\n * Always return false.\n */\nvar no = function no() {\n  return false;\n};\n\n/**\n * Return same value\n */\nvar identity = function identity(_) {\n  return _;\n};\n\n/**\n * Generate a static keys string from compiler modules.\n */\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b);\n    } catch (e) {\n      // possible circular reference\n      return a === b;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  };\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: ['component', 'directive', 'filter'],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n      obj = obj[segments[i]];\n    }\n    return obj;\n  };\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function isServerRendering() {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer;\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n  return (/native code/.test(Ctor.toString())\n  );\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function logError(err) {\n      console.error(err);\n    };\n    timerFunc = function timerFunc() {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function timerFunc() {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        cb.call(ctx);\n      }\n      if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  };\n}();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function classify(str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function warn(msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (vm ? formatLocation(formatComponentName(vm)) : ''));\n    }\n  };\n\n  tip = function tip(msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (vm ? formatLocation(formatComponentName(vm)) : ''));\n    }\n  };\n\n  formatComponentName = function formatComponentName(vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n    var name = typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var formatLocation = function formatLocation(str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return \"\\n(found in \" + str + \")\";\n  };\n}\n\n/*  */\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(_target) {\n  if (Dep.target) {\n    targetStack.push(Dep.target);\n  }\n  Dep.target = _target;\n}\n\nfunction popTarget() {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break;\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) {\n      ob.observeArray(inserted);\n    }\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, asRootData) {\n  if (!isObject(value)) {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1(obj, key, val, customSetter) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1);\n    return;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n  if (!hasOwn(target, key)) {\n    return;\n  }\n  delete target[key];\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n    return defaultStrat(parent, child);\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(childVal.call(this), parentVal.call(this));\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook(parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, childVal) : res;\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\nstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret;\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options) {\n  var props = options.props;\n  if (!props) {\n    return;\n  }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$2) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\n/*  */\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value;\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n  if (value == null && !prop.required) {\n    return;\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n    return;\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1];\n}\n\nfunction isType(type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type);\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true;\n    }\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction handleError(err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Error in \" + info + \":\", vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function warnNonPresent(target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed;\n    }\n  };\n\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function mark(tag) {\n      return perf.mark(tag);\n    };\n    measure = function measure(name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function createEmptyVNode() {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned;\n}\n\nfunction cloneVNodes(vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res;\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  };\n});\n\nfunction createFnInvoker(fns) {\n  function invoker() {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments);\n    }\n  }\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n  return children;\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') {\n      continue;\n    }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res;\n}\n\n/*  */\n\nfunction getFirstComponentChild(children) {\n  return children && children.filter(function (c) {\n    return c && c.componentOptions;\n  })[0];\n}\n\n/*  */\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm;\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm;\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm;\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n  var slots = {};\n  if (!children) {\n    return slots;\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) && child.data && (name = child.data.slot)) {\n      var slot = slots[name] || (slots[name] = []);\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment || node.text === ' ';\n}\n\nfunction resolveScopedSlots(fns) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res;\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle(vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n      , vm.$options._parentElm, vm.$options._refElm);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function updateComponent() {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure(name + \" render\", startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure(name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function updateComponent() {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  parentVnode.data.scopedSlots || // has new scoped slots\n  vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, hook + \" hook\");\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n  queue.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  }\n\n  // call updated hooks\n  index = queue.length;\n  while (index--) {\n    watcher = queue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher(vm, expOrFn, cb, options) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n  this.value = this.lazy ? undefined : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value;\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown() {\n  var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse(val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if (!isA && !isObject(val) || !Object.isExtensible(val)) {\n    return;\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return;\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n  if (opts.watch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function loop(key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) {\n    loop(key);\n  }observerState.shouldConvert = true;\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? data.call(vm) : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\"The data property \\\"\" + keys[i] + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed(vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data;\n  };\n  var propsDef = {};\n  propsDef.get = function () {\n    return this._props;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating, parentElm, refElm) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n\n  insert: function insert(vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy(vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (!Ctor) {\n    return;\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n    return;\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return;\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });\n  return vnode;\n}\n\nfunction createFunctionalComponent(Ctor, propsData, data, context, children) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function h(a, b, c, d) {\n    return createElement(_context, a, b, c, d, true);\n  };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function slots() {\n      return resolveSlots(children, context);\n    }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent, // activeInstance in lifecycle state\nparentElm, refElm) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options);\n}\n\nfunction resolveAsyncComponent(factory, baseCtor, cb) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function resolve(res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function reject(reason) {\n      process.env.NODE_ENV !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved;\n  }\n}\n\nfunction extractProps(data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return;\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (key !== keyInLowerCase && attrs && attrs.hasOwnProperty(keyInLowerCase)) {\n          warn(\"Prop \\\"\" + keyInLowerCase + \"\\\" is not declared in component \" + formatComponentName(Ctor) + \". Note that HTML attributes are \" + \"case-insensitive and camelCased props need to use their kebab-case \" + \"equivalents when using in-DOM templates. You should probably use \" + \"\\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction mergeHooks(data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1(one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  };\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) {\n      applyNS(vnode, ns);\n    }\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return;\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInAlias) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1;\n  } else {\n    return keyCodes !== eventKeyCode;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender(vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  };\n}\n\nfunction renderMixin(Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          vm[key] = source._provided[provideKey];\n          break;\n        }\n        source = source.$parent;\n      }\n    }\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      mark('vue-perf-init');\n    }\n\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark('vue-perf-init-end');\n      measure(vm._name + \" init\", 'vue-perf-init', 'vue-perf-init-end');\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified;\n}\n\nfunction dedupe(latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res;\n  } else {\n    return latest;\n  }\n}\n\nfunction Vue$2(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$2)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$2);\nstateMixin(Vue$2);\neventsMixin(Vue$2);\nlifecycleMixin(Vue$2);\nrenderMixin(Vue$2);\n\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return;\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this;\n  };\n}\n\n/*  */\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n      }\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction pruneCache(cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created() {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed() {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include(val) {\n      pruneCache(this.cache, function (name) {\n        return matches(val, name);\n      });\n    },\n    exclude: function exclude(val) {\n      pruneCache(this.cache, function (name) {\n        return !matches(val, name);\n      });\n    }\n  },\n\n  render: function render() {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n        return vnode;\n      }\n      var key = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode;\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () {\n    return config;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$2);\n\nObject.defineProperty(Vue$2.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$2.version = '2.2.4';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function mustUseProp(tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function isXlink(name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function getXlinkProp(name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function isFalsyAttrValue(val) {\n  return val == null || val === false;\n};\n\n/*  */\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction genClassFromData(data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  var res = '';\n  if (!value) {\n    return res;\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if (stringified = stringifyClass(value[i])) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1);\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) {\n        res += key + ' ';\n      }\n    }\n    return res.slice(0, -1);\n  }\n  /* istanbul ignore next */\n  return res;\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isReservedTag = function isReservedTag(tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n  if (isReservedTag(tag)) {\n    return false;\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n    return selected;\n  } else {\n    return el;\n  }\n}\n\n/*  */\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm;\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute(node, key, val) {\n  node.setAttribute(key, val);\n}\n\nvar nodeOps = Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef(s) {\n  return s == null;\n}\n\nfunction isDef(s) {\n  return s != null;\n}\n\nfunction sameVnode(vnode1, vnode2) {\n  return vnode1.key === vnode2.key && vnode1.tag === vnode2.tag && vnode1.isComment === vnode2.isComment && !vnode1.data === !vnode2.data;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks[i]] !== undefined) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) {\n        i.create(emptyNode, vnode);\n      }\n      if (i.insert) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope(vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key && (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate(elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false;\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true /* hydrating */);\n      }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break;\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false;\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode) {\n    if (vnode.tag) {\n      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) {\n        invokeDestroyHook(oldVnode);\n      }\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(vnode, insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parentElm$1 !== null) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function callInsert() {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res;\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [ref, directives];\n\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return;\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n  }\n}\n\n/*  */\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar str;\nvar index$1;\n\n/*  */\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1(event, _handler, once, capture) {\n  if (once) {\n    var oldHandler = _handler;\n    var _target = target$1; // save current target element in closure\n    _handler = function handler(ev) {\n      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, _handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, _handler, capture);\n}\n\nfunction remove$2(event, handler, capture, _target) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return;\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return;\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n      if (cur === oldProps[key]) {\n        continue;\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, vnode, checkVal) {\n  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n}\n\nfunction isDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal;\n}\n\nfunction isInputChanged(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (modifiers && modifiers.number || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal);\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim();\n  }\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n  return bindingStyle;\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function setProp(el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && prop in testEl.style) {\n    return prop;\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style && !oldData.staticStyle && !oldData.style) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) {\n    return cb();\n  }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function end() {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function onEnd(e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n}\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1)) * 1000;\n}\n\n/*  */\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return;\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm();\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n  if (!fn) {\n    return false;\n  }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function cb() {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple ? binding.value.some(function (v) {\n        return hasNoMatchingOption(v, el.options);\n      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return;\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) {\n      return;\n    }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  return (/\\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null\n  );\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return;\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) {\n      return c.tag;\n    });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return;\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) {\n      return d.name === 'show';\n    })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function performLeave() {\n          delayedLeave();\n        };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n\n  beforeUpdate: function beforeUpdate() {\n    // force removing pass\n    this.__patch__(this._vnode, this.kept, false, // hydrating\n    true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      if (this._hasMove != null) {\n        return this._hasMove;\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$2.config.mustUseProp = mustUseProp;\nVue$2.config.isReservedTag = isReservedTag;\nVue$2.config.getTagNamespace = getTagNamespace;\nVue$2.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$2.options.directives, platformDirectives);\nextend(Vue$2.options.components, platformComponents);\n\n// install platform patch function\nVue$2.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$2.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$2);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n  }\n}, 0);\n\nexports.default = Vue$2;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcz9hNDI3Il0sIm5hbWVzIjpbIl90b1N0cmluZyIsInZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJ0b051bWJlciIsIm4iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsIm1hcCIsIk9iamVjdCIsImNyZWF0ZSIsImxpc3QiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093biIsIm9iaiIsImtleSIsImNhbGwiLCJpc1ByaW1pdGl2ZSIsInZhbHVlIiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0Iiwic2xpY2UiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJBcnJheSIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJpc09iamVjdCIsInRvU3RyaW5nIiwiT0JKRUNUX1NUUklORyIsImlzUGxhaW5PYmplY3QiLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJubyIsImlkZW50aXR5IiwibG9vc2VFcXVhbCIsImIiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJlIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfYXNzZXRUeXBlcyIsIl9saWZlY3ljbGVIb29rcyIsIl9tYXhVcGRhdGVDb3VudCIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInBhdGgiLCJ0ZXN0Iiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsIndpbmRvdyIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwidW5kZWZpbmVkIiwiZ2xvYmFsIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIm5leHRUaWNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsInRpbWVyRnVuYyIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsImxvZ0Vycm9yIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwidGhlbiIsImNhdGNoIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsImRhdGEiLCJxdWV1ZU5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsInB1c2giLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ3YXJuIiwidGlwIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsImZvcm1hdExvY2F0aW9uIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm5hbWUiLCJvcHRpb25zIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsIm1hdGNoIiwidWlkJDEiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmd1bWVudHMkMSIsImFyZ3MiLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJpc0FycmF5IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImtleXMiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwiZ2V0Iiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIk1hdGgiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsInBhcmVudCIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImNvbmNhdCIsImhvb2siLCJtZXJnZUFzc2V0cyIsInR5cGUiLCJ3YXRjaCIsInByb3BzIiwibWV0aG9kcyIsImNvbXB1dGVkIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtaXhpbiIsIlZ1ZSQyIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJqb2luIiwidmFsaWRhdG9yIiwibGVuIiwiaGFuZGxlRXJyb3IiLCJpbmZvIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5IiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsIm9uY2UkJDEiLCJjYXB0dXJlIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJldmVudCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwibmVzdGVkSW5kZXgiLCJsYXN0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImZpbHRlciIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiVnVlIiwiaG9va1JFIiwidGhpcyQxIiwiaSQxIiwiY2JzIiwiJGVtaXQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImV2ZXJ5IiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkcGFyZW50IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGZvcmNlVXBkYXRlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwicXVldWUiLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImVtaXQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsInN5bmMiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwidHJhdmVyc2UiLCJjbGVhbnVwRGVwcyIsInRtcCIsIm9sZFZhbHVlIiwiZXZhbHVhdGUiLCJzZWVuT2JqZWN0cyIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJkZXBJZCIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInByb3h5Iiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsIm9wdHMiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwiaXNSZXNlcnZlZFByb3AiLCJyZWYiLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiaGFuZGxlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwiX2Jhc2UiLCJjaWQiLCJyZXNvbHZlZCIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZXh0cmFjdFByb3BzIiwiZnVuY3Rpb25hbCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJfY29udGV4dCIsImgiLCJkIiwiY3JlYXRlRWxlbWVudCIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwiZmFjdG9yeSIsInJlcXVlc3RlZCIsInBlbmRpbmdDYWxsYmFja3MiLCJyZWplY3QiLCJyZWFzb24iLCJhdHRycyIsImRvbVByb3BzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJhcHBseU5TIiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCJyZXNvbHZlRmlsdGVyIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJ0cmVlIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsImluaXRQcm92aWRlIiwicHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwiaW5qZWN0IiwicHJvdmlkZUtleSIsInNvdXJjZSIsInVpZCIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiZ2V0Q29tcG9uZW50TmFtZSIsIm1hdGNoZXMiLCJwYXR0ZXJuIiwicHJ1bmVDYWNoZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwiZ2VuQ2xhc3NGcm9tRGF0YSIsInN0YXRpY0NsYXNzIiwiY2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwiaG9va3MiLCJpc1VuZGVmIiwicyIsImlzRGVmIiwic2FtZVZub2RlIiwidm5vZGUxIiwidm5vZGUyIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwibW9kdWxlcyIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImluUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwiYW5jZXN0b3IiLCJfc2NvcGVJZCIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsImVsbVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiaGFzRGF0YSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiYmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImh5ZHJhdGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsIndyYXBGaWx0ZXIiLCJleHAiLCJpbmRleCQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwiZXZlbnRzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJudW1iZXIiLCJ0cmltIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemUiLCJwcmVmaXhlcyIsInRlc3RFbCIsInVwcGVyIiwicHJlZml4ZWQiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJ0aW1lb3V0IiwicHJvcENvdW50IiwiZW5kZWQiLCJlbmQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJOdW1iZXIiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJtb2RlbCQxIiwiYmluZGluZyIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsIm5lZWRSZXNldCIsInNvbWUiLCJ2IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJnZXRWYWx1ZSIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsImNvbXAiLCJrZXkkMSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYmVmb3JlVXBkYXRlIiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsImJvZHkiLCJmIiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIs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NUR3QixjQUFRQSxRQUFROEssSUFBUixHQUFlLE1BQWYsR0FBd0IsS0FBaEMsRUFDRSwrRUFDQSx1Q0FGRjtBQUlEO0FBQ0Y7QUFDRCxNQUFJL08sUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQ0FOLE9BQU9HLGFBQVAsS0FBeUIsS0FEekIsSUFFQWdDLFNBRkEsSUFFYSxPQUFPa0MsT0FBUCxLQUFtQixXQUZwQyxFQUVpRDtBQUMvQ0EsWUFBUUEsUUFBUThLLElBQVIsR0FBZSxNQUFmLEdBQXdCLEtBQWhDLEVBQ0UsK0NBQ0EsdUVBREEsR0FFQSwwREFIRjtBQUtEO0FBQ0YsQ0FwQkQsRUFvQkcsQ0FwQkg7O2tCQXNCZTlCLEsiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjIuNFxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gX3RvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcG9zc2libGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICByZXR1cm4gYSA9PT0gYlxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqL1xuICBfYXNzZXRUeXBlczogW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF0sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbGlmZWN5Y2xlIGhvb2tzLlxuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgc2NoZWR1bGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcbn07XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikgeyBjYi5jYWxsKGN0eCk7IH1cbiAgICAgIGlmIChfcmVzb2x2ZSkgeyBfcmVzb2x2ZShjdHgpOyB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICA6IHZtLm5hbWU7XG5cbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciBmb3JtYXRMb2NhdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSBcIjxBbm9ueW1vdXM+XCIpIHtcbiAgICAgIHN0ciArPSBcIiAtIHVzZSB0aGUgXFxcIm5hbWVcXFwiIG9wdGlvbiBmb3IgYmV0dGVyIGRlYnVnZ2luZyBtZXNzYWdlcy5cIjtcbiAgICB9XG4gICAgcmV0dXJuIChcIlxcbihmb3VuZCBpbiBcIiArIHN0ciArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlLFxuICBpc1NldHRpbmdQcm9wczogZmFsc2Vcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXJcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9IHRhcmdldC5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gdGFyZ2V0Ll9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gdHlwZW9mIGV4dGVuZHNGcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLm9wdGlvbnMsIHZtKVxuICAgICAgOiBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgIGlmIChtaXhpbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBWdWUkMikge1xuICAgICAgICBtaXhpbiA9IG1peGluLm9wdGlvbnM7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnc3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnTnVtYmVyJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ251bWJlcicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnYm9vbGVhbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXVxufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjpcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnNcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gJyc7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9uc1xuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmICghY3VyKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFvbGQpIHtcbiAgICAgIGlmICghY3VyLmZucykge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoIW9uW25hbWVdKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoIW9sZEhvb2spIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob2xkSG9vay5mbnMgJiYgb2xkSG9vay5tZXJnZWQpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjID09IG51bGwgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIGxhc3QudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjLnRleHQgJiYgbGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGMudGFnICYmIGMua2V5ID09IG51bGwgJiYgbmVzdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAmJiBjLmNvbXBvbmVudE9wdGlvbnM7IH0pWzBdXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UkJDEpIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICB2YXIgbmFtZSwgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICBjaGlsZC5kYXRhICYmIChuYW1lID0gY2hpbGQuZGF0YS5zbG90KSkge1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zXG4pIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHJlc1tmbnNbaV1bMF1dID0gZm5zW2ldWzFdO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIHF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkLCB2bTtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsbCB1cGRhdGVkIGhvb2tzXG4gIGluZGV4ID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+PSAwICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoTWF0aC5tYXgoaSwgaW5kZXgpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHsga2V5OiAxLCByZWY6IDEsIHNsb3Q6IDEgfTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZGF0YS5jYWxsKHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXlzW2ldKSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XG4gIHZhciBvcHRpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKCFDdG9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoIUN0b3IuY2lkKSB7XG4gICAgaWYgKEN0b3IucmVzb2x2ZWQpIHtcbiAgICAgIEN0b3IgPSBDdG9yLnJlc29sdmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGl0J3Mgb2sgdG8gcXVldWUgdGhpcyBvbiBldmVyeSByZW5kZXIgYmVjYXVzZVxuICAgICAgICAvLyAkZm9yY2VVcGRhdGUgaXMgYnVmZmVyZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICAgICAgY29udGV4dC4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFDdG9yKSB7XG4gICAgICAgIC8vIHJldHVybiBub3RoaW5nIGlmIHRoaXMgaXMgaW5kZWVkIGFuIGFzeW5jIGNvbXBvbmVudFxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGRhdGEubW9kZWwpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzKGRhdGEsIEN0b3IpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKHByb3BPcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgZGF0YTogZGF0YSxcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY2Jcbikge1xuICBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICByZXMgPSBiYXNlQ3Rvci5leHRlbmQocmVzKTtcbiAgICAgIH1cbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAvLyBoYW5kbGUgcHJvbWlzZVxuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nICYmICFmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHMgKGRhdGEsIEN0b3IpIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcE9wdGlvbnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIHZhciBkb21Qcm9wcyA9IGRhdGEuZG9tUHJvcHM7XG4gIGlmIChhdHRycyB8fCBwcm9wcyB8fCBkb21Qcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgbm90IGRlY2xhcmVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZShDdG9yKSkgKyBcIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgXCIgK1xuICAgICAgICAgICAgXCJjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIHByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgXCIgK1xuICAgICAgICAgICAgXCJlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiICtcbiAgICAgICAgICAgIFwiXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5KSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgZG9tUHJvcHMsIGtleSwgYWx0S2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChoYXNoKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChvbltldmVudF0pIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYWx3YXlzTm9ybWFsaXplKSB7IG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTsgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmICh2bm9kZSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgJiYgIWNoaWxkLm5zKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIGluamVjdCA9IHZtLiRvcHRpb25zLmluamVjdDtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgLy8gaXNBcnJheSBoZXJlXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGluamVjdCk7XG4gICAgdmFyIGtleXMgPSBpc0FycmF5XG4gICAgICA/IGluamVjdFxuICAgICAgOiBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpc0FycmF5ID8ga2V5IDogaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIHZtW2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIG1hcmsoJ3Z1ZS1wZXJmLWluaXQnKTtcbiAgICB9XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKCd2dWUtcGVyZi1pbml0LWVuZCcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksICd2dWUtcGVyZi1pbml0JywgJ3Z1ZS1wZXJmLWluaXQtZW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDIgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMikpIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQyKTtcbnN0YXRlTWl4aW4oVnVlJDIpO1xuZXZlbnRzTWl4aW4oVnVlJDIpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDIpO1xucmVuZGVyTWl4aW4oVnVlJDIpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwXTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faW5hY3RpdmUpIHtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQyKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQyLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cblZ1ZSQyLnZlcnNpb24gPSAnMi4yLjQnO1xuXG4vKiAgKi9cblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogY2hpbGQuY2xhc3NcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChzdGF0aWNDbGFzcyB8fCBkeW5hbWljQ2xhc3MpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGlmICgoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHsgcmVzICs9IGtleSArICcgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cblxuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAocykge1xuICByZXR1cm4gcyAhPSBudWxsXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAodm5vZGUxLCB2bm9kZTIpIHtcbiAgcmV0dXJuIChcbiAgICB2bm9kZTEua2V5ID09PSB2bm9kZTIua2V5ICYmXG4gICAgdm5vZGUxLnRhZyA9PT0gdm5vZGUyLnRhZyAmJlxuICAgIHZub2RlMS5pc0NvbW1lbnQgPT09IHZub2RlMi5pc0NvbW1lbnQgJiZcbiAgICAhdm5vZGUxLmRhdGEgPT09ICF2bm9kZTIuZGF0YVxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChtb2R1bGVzW2pdW2hvb2tzW2ldXSAhPT0gdW5kZWZpbmVkKSB7IGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLmlzQ29tbWVudCkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzUmVhY3RpdmF0ZWQpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpLmNyZWF0ZSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGkuaW5zZXJ0KSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChybSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmICghcm0pIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKHZub2RlLmlzU3RhdGljICYmXG4gICAgICAgIG9sZFZub2RlLmlzU3RhdGljICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgICh2bm9kZS5pc0Nsb25lZCB8fCB2bm9kZS5pc09uY2UpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgaGFzRGF0YSA9IGlzRGVmKGRhdGEpO1xuICAgIGlmIChoYXNEYXRhICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChoYXNEYXRhICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaW5pdGlhbCAmJiB2bm9kZS5wYXJlbnQpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoIXZub2RlKSB7XG4gICAgICBpZiAob2xkVm5vZGUpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoIW9sZFZub2RlKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGh5ZHJhdGluZykge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodm5vZGUucGFyZW50KSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRFbG0kMSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoYXR0cnMuX19vYl9fKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChhdHRyc1trZXldID09IG51bGwpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoIWRhdGEuc3RhdGljQ2xhc3MgJiYgIWRhdGEuY2xhc3MgJiZcbiAgICAgICghb2xkRGF0YSB8fCAoIW9sZERhdGEuc3RhdGljQ2xhc3MgJiYgIW9sZERhdGEuY2xhc3MpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuXG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cblxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIHN0cjtcbnZhciBpbmRleCQxO1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAob25bUkFOR0VfVE9LRU5dKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkge1xuICAgIC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuICAgIGV2ZW50ID0gaXNDaHJvbWUgPyAnY2xpY2snIDogJ2NoYW5nZSc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSxcbiAgY2FwdHVyZVxuKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGN1ciA9PSBudWxsID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyKSB8fCBlbG0udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZVtub3JtYWxpemUobmFtZSldID0gdmFsO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoIWRhdGEuc3RhdGljU3R5bGUgJiYgIWRhdGEuc3R5bGUgJiZcbiAgICAgICFvbGREYXRhLnN0YXRpY1N0eWxlICYmICFvbGREYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZFZub2RlLmRhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgdm5vZGUuZGF0YS5zdHlsZSA9IHN0eWxlLl9fb2JfXyA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYikge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKCFmbikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGludm9rZXJGbnMpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQyLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDIuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDIuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQyLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDIub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQyLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDIucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDIucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(34)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(17),\n  /* template */\n  __webpack_require__(29),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"E:\\\\Demo\\\\Vue-Edit\\\\webpack\\\\src\\\\App.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] App.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-5b7a3b96\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-5b7a3b96\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT84MzM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUE4TDs7QUFFOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlEQUFpRCxJQUFJO0FBQ3BJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlcj97XFxcImlkXFxcIjpcXFwiZGF0YS12LTViN2EzYjk2XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XFxcImlkXFxcIjpcXFwiZGF0YS12LTViN2EzYjk2XFxcIn0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkU6XFxcXERlbW9cXFxcVnVlLUVkaXRcXFxcd2VicGFja1xcXFxzcmNcXFxcQXBwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIEFwcC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNWI3YTNiOTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi01YjdhM2I5NlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\nsection[data-v-005ef7ca] {\\n  width: calc(100% - 250px);\\n  height: calc(100% - 100px);\\n  box-sizing: border-box;\\n  padding: 20px;\\n  float: right;\\n}\\n.rightShow[data-v-005ef7ca] {\\n  width: 100%;\\n  height: 100%;\\n  background: pink;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"E:/Demo/Vue-Edit/webpack/src/components/RightShow.vue\"],\"names\":[],\"mappings\":\";AAAA;EACE,0BAA0B;EAC1B,2BAA2B;EAC3B,uBAAuB;EACvB,cAAc;EACd,aAAa;CAAE;AAEjB;EACE,YAAY;EACZ,aAAa;EACb,iBAAiB;CAAE\",\"file\":\"RightShow.vue\",\"sourcesContent\":[\"section {\\n  width: calc(100% - 250px);\\n  height: calc(100% - 100px);\\n  box-sizing: border-box;\\n  padding: 20px;\\n  float: right; }\\n\\n.rightShow {\\n  width: 100%;\\n  height: 100%;\\n  background: pink; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SaWdodFNob3cudnVlPzJkNWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxxREFBc0QsOEJBQThCLCtCQUErQiwyQkFBMkIsa0JBQWtCLGlCQUFpQixHQUFHLCtCQUErQixnQkFBZ0IsaUJBQWlCLHFCQUFxQixHQUFHLFVBQVUsd0dBQXdHLEtBQUssWUFBWSxhQUFhLGFBQWEsV0FBVyxVQUFVLEtBQUssTUFBTSxVQUFVLFVBQVUsWUFBWSx5REFBeUQsOEJBQThCLCtCQUErQiwyQkFBMkIsa0JBQWtCLGlCQUFpQixFQUFFLGdCQUFnQixnQkFBZ0IsaUJBQWlCLHFCQUFxQixFQUFFLHFCQUFxQjs7QUFFNXZCIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5zZWN0aW9uW2RhdGEtdi0wMDVlZjdjYV0ge1xcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDI1MHB4KTtcXG4gIGhlaWdodDogY2FsYygxMDAlIC0gMTAwcHgpO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbi5yaWdodFNob3dbZGF0YS12LTAwNWVmN2NhXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IHBpbms7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJFOi9EZW1vL1Z1ZS1FZGl0L3dlYnBhY2svc3JjL2NvbXBvbmVudHMvUmlnaHRTaG93LnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDRSwwQkFBMEI7RUFDMUIsMkJBQTJCO0VBQzNCLHVCQUF1QjtFQUN2QixjQUFjO0VBQ2QsYUFBYTtDQUFFO0FBRWpCO0VBQ0UsWUFBWTtFQUNaLGFBQWE7RUFDYixpQkFBaUI7Q0FBRVwiLFwiZmlsZVwiOlwiUmlnaHRTaG93LnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJzZWN0aW9uIHtcXG4gIHdpZHRoOiBjYWxjKDEwMCUgLSAyNTBweCk7XFxuICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDEwMHB4KTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLnJpZ2h0U2hvdyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IHBpbms7IH1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4wLjI4LjBAY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP3tcImlkXCI6XCJkYXRhLXYtMDA1ZWY3Y2FcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+Ly42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvUmlnaHRTaG93LnZ1ZVxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.showImg{\\n\\twidth: 250px;\\n\\theight: 250px;\\n}\\n.showImg>img{\\n\\twidth: 100%;\\n\\theight: 100%\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"E:/Demo/Vue-Edit/webpack/src/components/uploadbg.vue?d8beb2ec\"],\"names\":[],\"mappings\":\";AAwCA;CACA,aAAA;CACA,cAAA;CACA;AACA;CACA,YAAA;CACA,YAAA;CACA\",\"file\":\"uploadbg.vue\",\"sourcesContent\":[\"<template>\\r\\n\\t<div>\\r\\n\\t\\t<span class=\\\"forFile\\\">\\r\\n\\t\\t\\t<p>{{fileName}}</p>\\r\\n\\t\\t\\t<input type=\\\"file\\\" name='bg' v-on:change=\\\"choosecoverimg\\\">\\r\\n\\t\\t</span>\\r\\n\\t\\t<div class=\\\"showImg\\\"><img id=\\\"showImgs\\\" v-bind:src=\\\"fileUrl\\\" /></div>\\r\\n\\t\\t<input type=\\\"hidden\\\" class=\\\"hide\\\" v-model=\\\"fileUrl\\\" />\\r\\n\\t</div>\\r\\n</template>\\r\\n<script>\\r\\n\\texport default {\\r\\n\\t\\tdata:function(){\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\tfileUrl: '',\\r\\n\\t\\t\\t\\tfileName:''\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\tmethods:{\\r\\n\\t\\t\\tchoosecoverimg: function (e) {\\r\\n\\t\\t\\t\\tvar file = e.target.files[0];\\r\\n\\t\\t\\t\\tvar data = new FormData();\\r\\n\\t\\t\\t\\tdata.append('file', file);  \\r\\n\\r\\n\\t\\t\\t\\tthis.$http.post('http://172.16.0.107:9011/pages/159/file', data)\\r\\n\\t\\t\\t\\t.then((res)=>{\\r\\n\\t\\t\\t\\t\\tconsole.log(res)\\r\\n\\t\\t\\t\\t\\tthis.fileUrl = 'http://172.16.0.107:9011/pages/159/'+res.data.data.key;\\r\\n\\t\\t\\t\\t}, (err)=>{\\r\\n\\t\\t\\t\\t\\tconsole.log(err)\\r\\n\\t\\t\\t\\t});\\t\\t\\t  \\r\\n\\t\\t\\t\\tthis.fileName = e.target.files[0].name;\\r\\n\\t\\t\\t\\tthis.$emit('choosecoverimg',this.fileName)\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n</script>\\r\\n<style>\\r\\n\\t.showImg{\\r\\n\\t\\twidth: 250px;\\r\\n\\t\\theight: 250px;\\r\\n\\t}\\r\\n\\t.showImg>img{\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%\\r\\n\\t}\\r\\n</style>\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy91cGxvYWRiZy52dWU/Y2YxMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLG9DQUFxQyxpQkFBaUIsa0JBQWtCLEdBQUcsZUFBZSxnQkFBZ0IsbUJBQW1CLFVBQVUsZ0hBQWdILE1BQU0sVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsbUhBQW1ILFVBQVUsK1NBQStTLHdCQUF3QixrQkFBa0IsMERBQTBELFNBQVMsa0JBQWtCLHdDQUF3Qyx5Q0FBeUMsc0NBQXNDLHNDQUFzQyw0R0FBNEcsbUhBQW1ILGFBQWEsVUFBVSwyQ0FBMkMsRUFBRSwyREFBMkQsaUVBQWlFLGFBQWEsT0FBTywyQ0FBMkMscUJBQXFCLHNCQUFzQixPQUFPLG1CQUFtQixvQkFBb0IsMkJBQTJCLCtCQUErQjs7QUFFeG1EIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uc2hvd0ltZ3tcXG5cXHR3aWR0aDogMjUwcHg7XFxuXFx0aGVpZ2h0OiAyNTBweDtcXG59XFxuLnNob3dJbWc+aW1ne1xcblxcdHdpZHRoOiAxMDAlO1xcblxcdGhlaWdodDogMTAwJVxcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRTovRGVtby9WdWUtRWRpdC93ZWJwYWNrL3NyYy9jb21wb25lbnRzL3VwbG9hZGJnLnZ1ZT9kOGJlYjJlY1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBd0NBO0NBQ0EsYUFBQTtDQUNBLGNBQUE7Q0FDQTtBQUNBO0NBQ0EsWUFBQTtDQUNBLFlBQUE7Q0FDQVwiLFwiZmlsZVwiOlwidXBsb2FkYmcudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG5cXHQ8ZGl2PlxcclxcblxcdFxcdDxzcGFuIGNsYXNzPVxcXCJmb3JGaWxlXFxcIj5cXHJcXG5cXHRcXHRcXHQ8cD57e2ZpbGVOYW1lfX08L3A+XFxyXFxuXFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcImZpbGVcXFwiIG5hbWU9J2JnJyB2LW9uOmNoYW5nZT1cXFwiY2hvb3NlY292ZXJpbWdcXFwiPlxcclxcblxcdFxcdDwvc3Bhbj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzaG93SW1nXFxcIj48aW1nIGlkPVxcXCJzaG93SW1nc1xcXCIgdi1iaW5kOnNyYz1cXFwiZmlsZVVybFxcXCIgLz48L2Rpdj5cXHJcXG5cXHRcXHQ8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBjbGFzcz1cXFwiaGlkZVxcXCIgdi1tb2RlbD1cXFwiZmlsZVVybFxcXCIgLz5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuXFx0ZXhwb3J0IGRlZmF1bHQge1xcclxcblxcdFxcdGRhdGE6ZnVuY3Rpb24oKXtcXHJcXG5cXHRcXHRcXHRyZXR1cm4ge1xcclxcblxcdFxcdFxcdFxcdGZpbGVVcmw6ICcnLFxcclxcblxcdFxcdFxcdFxcdGZpbGVOYW1lOicnXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0sXFxyXFxuXFx0XFx0bWV0aG9kczp7XFxyXFxuXFx0XFx0XFx0Y2hvb3NlY292ZXJpbWc6IGZ1bmN0aW9uIChlKSB7XFxyXFxuXFx0XFx0XFx0XFx0dmFyIGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xcclxcblxcdFxcdFxcdFxcdGRhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7ICBcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR0aGlzLiRodHRwLnBvc3QoJ2h0dHA6Ly8xNzIuMTYuMC4xMDc6OTAxMS9wYWdlcy8xNTkvZmlsZScsIGRhdGEpXFxyXFxuXFx0XFx0XFx0XFx0LnRoZW4oKHJlcyk9PntcXHJcXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmxvZyhyZXMpXFxyXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5maWxlVXJsID0gJ2h0dHA6Ly8xNzIuMTYuMC4xMDc6OTAxMS9wYWdlcy8xNTkvJytyZXMuZGF0YS5kYXRhLmtleTtcXHJcXG5cXHRcXHRcXHRcXHR9LCAoZXJyKT0+e1xcclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUubG9nKGVycilcXHJcXG5cXHRcXHRcXHRcXHR9KTtcXHRcXHRcXHQgIFxcclxcblxcdFxcdFxcdFxcdHRoaXMuZmlsZU5hbWUgPSBlLnRhcmdldC5maWxlc1swXS5uYW1lO1xcclxcblxcdFxcdFxcdFxcdHRoaXMuJGVtaXQoJ2Nob29zZWNvdmVyaW1nJyx0aGlzLmZpbGVOYW1lKVxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFx0fVxcclxcblxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG5cXHQuc2hvd0ltZ3tcXHJcXG5cXHRcXHR3aWR0aDogMjUwcHg7XFxyXFxuXFx0XFx0aGVpZ2h0OiAyNTBweDtcXHJcXG5cXHR9XFxyXFxuXFx0LnNob3dJbWc+aW1ne1xcclxcblxcdFxcdHdpZHRoOiAxMDAlO1xcclxcblxcdFxcdGhlaWdodDogMTAwJVxcclxcblxcdH1cXHJcXG48L3N0eWxlPlwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjAuMjguMEBjc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1wiaWRcIjpcImRhdGEtdi0xMDczOTU3NFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy91cGxvYWRiZy52dWVcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n*{\\n\\tmargin: 0;\\n\\tpadding: 0\\n}\\nhtml,body{\\n\\twidth: 100%;\\n\\theight: 100%\\n}\\n#app{\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\tbackground-color: #fafafa;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"E:/Demo/Vue-Edit/webpack/src/App.vue?0a5628cd\"],\"names\":[],\"mappings\":\";AA6DA;CACA,UAAA;CACA,UAAA;CACA;AACA;CACA,YAAA;CACA,YAAA;CACA;AACA;CACA,YAAA;CACA,aAAA;CACA,0BAAA;CACA\",\"file\":\"App.vue\",\"sourcesContent\":[\"<template>\\r\\n\\t<div id=\\\"app\\\">\\r\\n\\t\\t<headMain></headMain>\\r\\n\\t\\t<leftNav></leftNav>\\r\\n\\t\\t<rightShow></rightShow>\\r\\n\\t\\t<!-- <bg v-on:choosecoverimg=\\\"getName\\\"></bg>\\r\\n\\t\\t<button type='button' v-on:click=\\\"onSend\\\">提交</button> -->\\r\\n\\t</div>\\r\\n</template>\\r\\n<script>\\r\\n\\timport bg from './components/uploadbg.vue';\\r\\n\\timport headMain from './components/Header.vue';\\r\\n\\timport leftNav from './components/LeftNav.vue';\\r\\n\\timport rightShow from './components/RightShow.vue';\\r\\n\\tvar Data = {\\r\\n\\t\\tconfigData:{\\r\\n\\t        one:{\\r\\n\\t\\t\\t\\tbg:\\\"\\\",\\r\\n\\t\\t\\t\\ttitle:\\\"\\\",\\r\\n\\t\\t\\t\\tdes:\\\"\\\"\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tsource:[{\\r\\n\\t\\t\\t\\tsubTitle:\\\"\\\",\\r\\n\\t\\t\\t\\ttextList:[\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\ttext:'',\\r\\n\\t\\t\\t\\t\\t\\taudio:''\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t],\\r\\n\\t\\t\\t\\timgList:[\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\timg:'',\\t\\t\\r\\n\\t\\t\\t\\t\\t\\taudio:''\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t]\\r\\n\\t\\t\\t}]\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\texport default {\\r\\n\\t\\tcomponents: {\\r\\n\\t\\t\\tbg,\\r\\n\\t\\t\\theadMain,\\r\\n\\t\\t\\tleftNav,\\r\\n\\t\\t\\trightShow\\r\\n\\t\\t},\\r\\n\\t\\tdata: function () {\\r\\n\\t\\t\\treturn Data;\\r\\n\\t\\t},\\r\\n\\t\\tmethods:{\\r\\n\\t\\t\\tgetName: function (msg) {\\r\\n\\t\\t\\t\\tthis.configData.one.bg = msg;\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tonSend:function(){\\r\\n\\t    \\t\\tvar data = this.configData;\\r\\n\\t    \\t\\tvar _data = JSON.stringify(data);\\r\\n\\t    \\t\\tconsole.log(_data)\\r\\n\\t    \\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n</script>\\r\\n<style>\\r\\n\\t*{\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tpadding: 0\\r\\n\\t}\\r\\n\\thtml,body{\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%\\r\\n\\t}\\r\\n\\t#app{\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\tbackground-color: #fafafa;\\r\\n\\t}\\r\\n</style>\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9hZGY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsNkJBQThCLGNBQWMsaUJBQWlCLFlBQVksZ0JBQWdCLG1CQUFtQixPQUFPLGdCQUFnQixpQkFBaUIsOEJBQThCLEdBQUcsVUFBVSxnR0FBZ0csTUFBTSxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsa1hBQWtYLHFEQUFxRCxxREFBcUQseURBQXlELGtCQUFrQixvQkFBb0IsbUJBQW1CLDBFQUEwRSxvQkFBb0IsK0RBQStELCtEQUErRCxrREFBa0Qsa0VBQWtFLHdCQUF3QixVQUFVLFFBQVEsc0JBQXNCLHFCQUFxQiw4RUFBOEUsNEJBQTRCLHNCQUFzQixTQUFTLGtCQUFrQixtQ0FBbUMseUNBQXlDLFdBQVcsNkJBQTZCLHlDQUF5QywrQ0FBK0MsNkNBQTZDLFNBQVMsT0FBTyxnQ0FBZ0Msa0JBQWtCLHlCQUF5QixnQkFBZ0Isb0JBQW9CLDJCQUEyQixXQUFXLG9CQUFvQixxQkFBcUIsa0NBQWtDLE9BQU8sK0JBQStCOztBQUU3aEUiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbip7XFxuXFx0bWFyZ2luOiAwO1xcblxcdHBhZGRpbmc6IDBcXG59XFxuaHRtbCxib2R5e1xcblxcdHdpZHRoOiAxMDAlO1xcblxcdGhlaWdodDogMTAwJVxcbn1cXG4jYXBwe1xcblxcdHdpZHRoOiAxMDAlO1xcblxcdGhlaWdodDogMTAwJTtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmFmYWZhO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRTovRGVtby9WdWUtRWRpdC93ZWJwYWNrL3NyYy9BcHAudnVlPzBhNTYyOGNkXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUE2REE7Q0FDQSxVQUFBO0NBQ0EsVUFBQTtDQUNBO0FBQ0E7Q0FDQSxZQUFBO0NBQ0EsWUFBQTtDQUNBO0FBQ0E7Q0FDQSxZQUFBO0NBQ0EsYUFBQTtDQUNBLDBCQUFBO0NBQ0FcIixcImZpbGVcIjpcIkFwcC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcblxcdDxkaXYgaWQ9XFxcImFwcFxcXCI+XFxyXFxuXFx0XFx0PGhlYWRNYWluPjwvaGVhZE1haW4+XFxyXFxuXFx0XFx0PGxlZnROYXY+PC9sZWZ0TmF2PlxcclxcblxcdFxcdDxyaWdodFNob3c+PC9yaWdodFNob3c+XFxyXFxuXFx0XFx0PCEtLSA8Ymcgdi1vbjpjaG9vc2Vjb3ZlcmltZz1cXFwiZ2V0TmFtZVxcXCI+PC9iZz5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9J2J1dHRvbicgdi1vbjpjbGljaz1cXFwib25TZW5kXFxcIj7mj5DkuqQ8L2J1dHRvbj4gLS0+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcblxcdGltcG9ydCBiZyBmcm9tICcuL2NvbXBvbmVudHMvdXBsb2FkYmcudnVlJztcXHJcXG5cXHRpbXBvcnQgaGVhZE1haW4gZnJvbSAnLi9jb21wb25lbnRzL0hlYWRlci52dWUnO1xcclxcblxcdGltcG9ydCBsZWZ0TmF2IGZyb20gJy4vY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZSc7XFxyXFxuXFx0aW1wb3J0IHJpZ2h0U2hvdyBmcm9tICcuL2NvbXBvbmVudHMvUmlnaHRTaG93LnZ1ZSc7XFxyXFxuXFx0dmFyIERhdGEgPSB7XFxyXFxuXFx0XFx0Y29uZmlnRGF0YTp7XFxyXFxuXFx0ICAgICAgICBvbmU6e1xcclxcblxcdFxcdFxcdFxcdGJnOlxcXCJcXFwiLFxcclxcblxcdFxcdFxcdFxcdHRpdGxlOlxcXCJcXFwiLFxcclxcblxcdFxcdFxcdFxcdGRlczpcXFwiXFxcIlxcclxcblxcdFxcdFxcdH0sXFxyXFxuXFx0XFx0XFx0c291cmNlOlt7XFxyXFxuXFx0XFx0XFx0XFx0c3ViVGl0bGU6XFxcIlxcXCIsXFxyXFxuXFx0XFx0XFx0XFx0dGV4dExpc3Q6W1xcclxcblxcdFxcdFxcdFxcdFxcdHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0OicnLFxcclxcblxcdFxcdFxcdFxcdFxcdFxcdGF1ZGlvOicnXFxyXFxuXFx0XFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdF0sXFxyXFxuXFx0XFx0XFx0XFx0aW1nTGlzdDpbXFxyXFxuXFx0XFx0XFx0XFx0XFx0e1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGltZzonJyxcXHRcXHRcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRhdWRpbzonJ1xcclxcblxcdFxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRcXHRdXFxyXFxuXFx0XFx0XFx0fV1cXHJcXG5cXHRcXHR9XFxyXFxuXFx0fTtcXHJcXG5cXHRleHBvcnQgZGVmYXVsdCB7XFxyXFxuXFx0XFx0Y29tcG9uZW50czoge1xcclxcblxcdFxcdFxcdGJnLFxcclxcblxcdFxcdFxcdGhlYWRNYWluLFxcclxcblxcdFxcdFxcdGxlZnROYXYsXFxyXFxuXFx0XFx0XFx0cmlnaHRTaG93XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRkYXRhOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFx0XFx0XFx0cmV0dXJuIERhdGE7XFxyXFxuXFx0XFx0fSxcXHJcXG5cXHRcXHRtZXRob2RzOntcXHJcXG5cXHRcXHRcXHRnZXROYW1lOiBmdW5jdGlvbiAobXNnKSB7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy5jb25maWdEYXRhLm9uZS5iZyA9IG1zZztcXHJcXG5cXHRcXHRcXHR9LFxcclxcblxcdFxcdFxcdG9uU2VuZDpmdW5jdGlvbigpe1xcclxcblxcdCAgICBcXHRcXHR2YXIgZGF0YSA9IHRoaXMuY29uZmlnRGF0YTtcXHJcXG5cXHQgICAgXFx0XFx0dmFyIF9kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XFxyXFxuXFx0ICAgIFxcdFxcdGNvbnNvbGUubG9nKF9kYXRhKVxcclxcblxcdCAgICBcXHR9XFxyXFxuXFx0XFx0fVxcclxcblxcdH1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuXFx0KntcXHJcXG5cXHRcXHRtYXJnaW46IDA7XFxyXFxuXFx0XFx0cGFkZGluZzogMFxcclxcblxcdH1cXHJcXG5cXHRodG1sLGJvZHl7XFxyXFxuXFx0XFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0XFx0aGVpZ2h0OiAxMDAlXFxyXFxuXFx0fVxcclxcblxcdCNhcHB7XFxyXFxuXFx0XFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0XFx0aGVpZ2h0OiAxMDAlO1xcclxcblxcdFxcdGJhY2tncm91bmQtY29sb3I6ICNmYWZhZmE7XFxyXFxuXFx0fVxcclxcbjwvc3R5bGU+XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMC4yOC4wQGNzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz97XCJpZFwiOlwiZGF0YS12LTViN2EzYjk2XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\nsection[data-v-5e1ce17e] {\\n  width: 250px;\\n  height: calc(100% - 120px);\\n  float: left;\\n}\\n.leftNav[data-v-5e1ce17e] {\\n  width: 100%;\\n  height: 100%;\\n  background: green;\\n}\\n.leftNav li[data-v-5e1ce17e] {\\n    width: 100%;\\n    line-height: 45px;\\n    background: #fafafa;\\n    margin: 20px 0;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"E:/Demo/Vue-Edit/webpack/src/components/LeftNav.vue\"],\"names\":[],\"mappings\":\";AAAA;EACE,aAAa;EACb,2BAA2B;EAC3B,YAAY;CAAE;AAEhB;EACE,YAAY;EACZ,aAAa;EACb,kBAAkB;CAAE;AACpB;IACE,YAAY;IACZ,kBAAkB;IAClB,oBAAoB;IACpB,eAAe;CAAE\",\"file\":\"LeftNav.vue\",\"sourcesContent\":[\"section {\\n  width: 250px;\\n  height: calc(100% - 120px);\\n  float: left; }\\n\\n.leftNav {\\n  width: 100%;\\n  height: 100%;\\n  background: green; }\\n  .leftNav li {\\n    width: 100%;\\n    line-height: 45px;\\n    background: #fafafa;\\n    margin: 20px 0; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZT83OWExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EscURBQXNELGlCQUFpQiwrQkFBK0IsZ0JBQWdCLEdBQUcsNkJBQTZCLGdCQUFnQixpQkFBaUIsc0JBQXNCLEdBQUcsZ0NBQWdDLGtCQUFrQix3QkFBd0IsMEJBQTBCLHFCQUFxQixHQUFHLFVBQVUsc0dBQXNHLEtBQUssVUFBVSxZQUFZLFdBQVcsS0FBSyxNQUFNLFVBQVUsVUFBVSxZQUFZLEtBQUssTUFBTSxVQUFVLFlBQVksYUFBYSxXQUFXLHVEQUF1RCxpQkFBaUIsK0JBQStCLGdCQUFnQixFQUFFLGNBQWMsZ0JBQWdCLGlCQUFpQixzQkFBc0IsRUFBRSxpQkFBaUIsa0JBQWtCLHdCQUF3QiwwQkFBMEIscUJBQXFCLEVBQUUscUJBQXFCOztBQUV2NEIiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5zZWN0aW9uW2RhdGEtdi01ZTFjZTE3ZV0ge1xcbiAgd2lkdGg6IDI1MHB4O1xcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSAxMjBweCk7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuLmxlZnROYXZbZGF0YS12LTVlMWNlMTdlXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IGdyZWVuO1xcbn1cXG4ubGVmdE5hdiBsaVtkYXRhLXYtNWUxY2UxN2VdIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGxpbmUtaGVpZ2h0OiA0NXB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmFmYWZhO1xcbiAgICBtYXJnaW46IDIwcHggMDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkU6L0RlbW8vVnVlLUVkaXQvd2VicGFjay9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDRSxhQUFhO0VBQ2IsMkJBQTJCO0VBQzNCLFlBQVk7Q0FBRTtBQUVoQjtFQUNFLFlBQVk7RUFDWixhQUFhO0VBQ2Isa0JBQWtCO0NBQUU7QUFDcEI7SUFDRSxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLG9CQUFvQjtJQUNwQixlQUFlO0NBQUVcIixcImZpbGVcIjpcIkxlZnROYXYudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcInNlY3Rpb24ge1xcbiAgd2lkdGg6IDI1MHB4O1xcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSAxMjBweCk7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi5sZWZ0TmF2IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogZ3JlZW47IH1cXG4gIC5sZWZ0TmF2IGxpIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGxpbmUtaGVpZ2h0OiA0NXB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmFmYWZhO1xcbiAgICBtYXJnaW46IDIwcHggMDsgfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjAuMjguMEBjc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1wiaWRcIjpcImRhdGEtdi01ZTFjZTE3ZVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vLjYuMC4zQHNhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\nheader[data-v-77c6181b] {\\n  width: 100%;\\n  height: 100px;\\n  background: #fafafa;\\n  box-sizing: border-box;\\n  padding: 10px 0;\\n  display: flex;\\n  justify-content: space-around;\\n  align-items: center;\\n  border-bottom: 1px #333 solid;\\n}\\n.logo[data-v-77c6181b] {\\n  width: 80px;\\n  height: 100%;\\n  background: red;\\n  padding: 0 5px;\\n  border-right: 1px #333 solid;\\n}\\n.logo img[data-v-77c6181b] {\\n    width: 100%;\\n    height: 100%;\\n}\\n.name[data-v-77c6181b] {\\n  width: calc(100% - 80px - 200px);\\n  height: 100%;\\n  background: blue;\\n  box-sizing: border-box;\\n  padding: 20px;\\n  line-height: 40px;\\n  font-size: 24px;\\n  color: #333;\\n}\\n.userInfo[data-v-77c6181b] {\\n  width: 200px;\\n  height: 100%;\\n  background: yellow;\\n}\\n.userInfo .userAva[data-v-77c6181b] {\\n    width: 80px;\\n    height: 100%;\\n    float: right;\\n}\\n.userInfo .userAva img[data-v-77c6181b] {\\n      width: 100%;\\n      height: 100%;\\n}\\n.userInfo .userName[data-v-77c6181b] {\\n    width: 120px;\\n    height: 100%;\\n    line-height: 80px;\\n    text-align: center;\\n    font-size: 24px;\\n    color: #333;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"E:/Demo/Vue-Edit/webpack/src/components/Header.vue\"],\"names\":[],\"mappings\":\";AAAA;EACE,YAAY;EACZ,cAAc;EACd,oBAAoB;EACpB,uBAAuB;EACvB,gBAAgB;EAChB,cAAc;EACd,8BAA8B;EAC9B,oBAAoB;EACpB,8BAA8B;CAAE;AAElC;EACE,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,eAAe;EACf,6BAA6B;CAAE;AAC/B;IACE,YAAY;IACZ,aAAa;CAAE;AAEnB;EACE,iCAAiC;EACjC,aAAa;EACb,iBAAiB;EACjB,uBAAuB;EACvB,cAAc;EACd,kBAAkB;EAClB,gBAAgB;EAChB,YAAY;CAAE;AAEhB;EACE,aAAa;EACb,aAAa;EACb,mBAAmB;CAAE;AACrB;IACE,YAAY;IACZ,aAAa;IACb,aAAa;CAAE;AACf;MACE,YAAY;MACZ,aAAa;CAAE;AACnB;IACE,aAAa;IACb,aAAa;IACb,kBAAkB;IAClB,mBAAmB;IACnB,gBAAgB;IAChB,YAAY;CAAE\",\"file\":\"Header.vue\",\"sourcesContent\":[\"header {\\n  width: 100%;\\n  height: 100px;\\n  background: #fafafa;\\n  box-sizing: border-box;\\n  padding: 10px 0;\\n  display: flex;\\n  justify-content: space-around;\\n  align-items: center;\\n  border-bottom: 1px #333 solid; }\\n\\n.logo {\\n  width: 80px;\\n  height: 100%;\\n  background: red;\\n  padding: 0 5px;\\n  border-right: 1px #333 solid; }\\n  .logo img {\\n    width: 100%;\\n    height: 100%; }\\n\\n.name {\\n  width: calc(100% - 80px - 200px);\\n  height: 100%;\\n  background: blue;\\n  box-sizing: border-box;\\n  padding: 20px;\\n  line-height: 40px;\\n  font-size: 24px;\\n  color: #333; }\\n\\n.userInfo {\\n  width: 200px;\\n  height: 100%;\\n  background: yellow; }\\n  .userInfo .userAva {\\n    width: 80px;\\n    height: 100%;\\n    float: right; }\\n    .userInfo .userAva img {\\n      width: 100%;\\n      height: 100%; }\\n  .userInfo .userName {\\n    width: 120px;\\n    height: 100%;\\n    line-height: 80px;\\n    text-align: center;\\n    font-size: 24px;\\n    color: #333; }\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXIudnVlP2U2MWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxvREFBcUQsZ0JBQWdCLGtCQUFrQix3QkFBd0IsMkJBQTJCLG9CQUFvQixrQkFBa0Isa0NBQWtDLHdCQUF3QixrQ0FBa0MsR0FBRywwQkFBMEIsZ0JBQWdCLGlCQUFpQixvQkFBb0IsbUJBQW1CLGlDQUFpQyxHQUFHLDhCQUE4QixrQkFBa0IsbUJBQW1CLEdBQUcsMEJBQTBCLHFDQUFxQyxpQkFBaUIscUJBQXFCLDJCQUEyQixrQkFBa0Isc0JBQXNCLG9CQUFvQixnQkFBZ0IsR0FBRyw4QkFBOEIsaUJBQWlCLGlCQUFpQix1QkFBdUIsR0FBRyx1Q0FBdUMsa0JBQWtCLG1CQUFtQixtQkFBbUIsR0FBRywyQ0FBMkMsb0JBQW9CLHFCQUFxQixHQUFHLHdDQUF3QyxtQkFBbUIsbUJBQW1CLHdCQUF3Qix5QkFBeUIsc0JBQXNCLGtCQUFrQixHQUFHLFVBQVUscUdBQXFHLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFVBQVUsVUFBVSxZQUFZLFdBQVcsWUFBWSxLQUFLLE1BQU0sVUFBVSxVQUFVLEtBQUssTUFBTSxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsWUFBWSxhQUFhLFdBQVcsS0FBSyxNQUFNLFVBQVUsVUFBVSxZQUFZLEtBQUssTUFBTSxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxxREFBcUQsZ0JBQWdCLGtCQUFrQix3QkFBd0IsMkJBQTJCLG9CQUFvQixrQkFBa0Isa0NBQWtDLHdCQUF3QixrQ0FBa0MsRUFBRSxXQUFXLGdCQUFnQixpQkFBaUIsb0JBQW9CLG1CQUFtQixpQ0FBaUMsRUFBRSxlQUFlLGtCQUFrQixtQkFBbUIsRUFBRSxXQUFXLHFDQUFxQyxpQkFBaUIscUJBQXFCLDJCQUEyQixrQkFBa0Isc0JBQXNCLG9CQUFvQixnQkFBZ0IsRUFBRSxlQUFlLGlCQUFpQixpQkFBaUIsdUJBQXVCLEVBQUUsd0JBQXdCLGtCQUFrQixtQkFBbUIsbUJBQW1CLEVBQUUsOEJBQThCLG9CQUFvQixxQkFBcUIsRUFBRSx5QkFBeUIsbUJBQW1CLG1CQUFtQix3QkFBd0IseUJBQXlCLHNCQUFzQixrQkFBa0IsRUFBRSxxQkFBcUI7O0FBRWh1RiIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbmhlYWRlcltkYXRhLXYtNzdjNjE4MWJdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDBweDtcXG4gIGJhY2tncm91bmQ6ICNmYWZhZmE7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcGFkZGluZzogMTBweCAwO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJvcmRlci1ib3R0b206IDFweCAjMzMzIHNvbGlkO1xcbn1cXG4ubG9nb1tkYXRhLXYtNzdjNjE4MWJdIHtcXG4gIHdpZHRoOiA4MHB4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogcmVkO1xcbiAgcGFkZGluZzogMCA1cHg7XFxuICBib3JkZXItcmlnaHQ6IDFweCAjMzMzIHNvbGlkO1xcbn1cXG4ubG9nbyBpbWdbZGF0YS12LTc3YzYxODFiXSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcbi5uYW1lW2RhdGEtdi03N2M2MTgxYl0ge1xcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDgwcHggLSAyMDBweCk7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiBibHVlO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBsaW5lLWhlaWdodDogNDBweDtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4udXNlckluZm9bZGF0YS12LTc3YzYxODFiXSB7XFxuICB3aWR0aDogMjAwcHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiB5ZWxsb3c7XFxufVxcbi51c2VySW5mbyAudXNlckF2YVtkYXRhLXYtNzdjNjE4MWJdIHtcXG4gICAgd2lkdGg6IDgwcHg7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG4udXNlckluZm8gLnVzZXJBdmEgaW1nW2RhdGEtdi03N2M2MTgxYl0ge1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgIGhlaWdodDogMTAwJTtcXG59XFxuLnVzZXJJbmZvIC51c2VyTmFtZVtkYXRhLXYtNzdjNjE4MWJdIHtcXG4gICAgd2lkdGg6IDEyMHB4O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGxpbmUtaGVpZ2h0OiA4MHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgY29sb3I6ICMzMzM7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJFOi9EZW1vL1Z1ZS1FZGl0L3dlYnBhY2svc3JjL2NvbXBvbmVudHMvSGVhZGVyLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDRSxZQUFZO0VBQ1osY0FBYztFQUNkLG9CQUFvQjtFQUNwQix1QkFBdUI7RUFDdkIsZ0JBQWdCO0VBQ2hCLGNBQWM7RUFDZCw4QkFBOEI7RUFDOUIsb0JBQW9CO0VBQ3BCLDhCQUE4QjtDQUFFO0FBRWxDO0VBQ0UsWUFBWTtFQUNaLGFBQWE7RUFDYixnQkFBZ0I7RUFDaEIsZUFBZTtFQUNmLDZCQUE2QjtDQUFFO0FBQy9CO0lBQ0UsWUFBWTtJQUNaLGFBQWE7Q0FBRTtBQUVuQjtFQUNFLGlDQUFpQztFQUNqQyxhQUFhO0VBQ2IsaUJBQWlCO0VBQ2pCLHVCQUF1QjtFQUN2QixjQUFjO0VBQ2Qsa0JBQWtCO0VBQ2xCLGdCQUFnQjtFQUNoQixZQUFZO0NBQUU7QUFFaEI7RUFDRSxhQUFhO0VBQ2IsYUFBYTtFQUNiLG1CQUFtQjtDQUFFO0FBQ3JCO0lBQ0UsWUFBWTtJQUNaLGFBQWE7SUFDYixhQUFhO0NBQUU7QUFDZjtNQUNFLFlBQVk7TUFDWixhQUFhO0NBQUU7QUFDbkI7SUFDRSxhQUFhO0lBQ2IsYUFBYTtJQUNiLGtCQUFrQjtJQUNsQixtQkFBbUI7SUFDbkIsZ0JBQWdCO0lBQ2hCLFlBQVk7Q0FBRVwiLFwiZmlsZVwiOlwiSGVhZGVyLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJoZWFkZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbiAgYmFja2dyb3VuZDogI2ZhZmFmYTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwYWRkaW5nOiAxMHB4IDA7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4ICMzMzMgc29saWQ7IH1cXG5cXG4ubG9nbyB7XFxuICB3aWR0aDogODBweDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IHJlZDtcXG4gIHBhZGRpbmc6IDAgNXB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggIzMzMyBzb2xpZDsgfVxcbiAgLmxvZ28gaW1nIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTsgfVxcblxcbi5uYW1lIHtcXG4gIHdpZHRoOiBjYWxjKDEwMCUgLSA4MHB4IC0gMjAwcHgpO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogYmx1ZTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICBjb2xvcjogIzMzMzsgfVxcblxcbi51c2VySW5mbyB7XFxuICB3aWR0aDogMjAwcHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiB5ZWxsb3c7IH1cXG4gIC51c2VySW5mbyAudXNlckF2YSB7XFxuICAgIHdpZHRoOiA4MHB4O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGZsb2F0OiByaWdodDsgfVxcbiAgICAudXNlckluZm8gLnVzZXJBdmEgaW1nIHtcXG4gICAgICB3aWR0aDogMTAwJTtcXG4gICAgICBoZWlnaHQ6IDEwMCU7IH1cXG4gIC51c2VySW5mbyAudXNlck5hbWUge1xcbiAgICB3aWR0aDogMTIwcHg7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgbGluZS1oZWlnaHQ6IDgwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZm9udC1zaXplOiAyNHB4O1xcbiAgICBjb2xvcjogIzMzMzsgfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjAuMjguMEBjc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1wiaWRcIjpcImRhdGEtdi03N2M2MTgxYlwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vLjYuMC4zQHNhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9IZWFkZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4wLjExLjlAcHJvY2Vzcy9icm93c2VyLmpzPzNiZWUiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLElBQUlBLFVBQVVDLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUMsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0g7QUFDRCxTQUFTQyxtQkFBVCxHQUFnQztBQUM1QixVQUFNLElBQUlELEtBQUosQ0FB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IGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC4xMS45QHByb2Nlc3MvYnJvd3Nlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4xLjAuMEBpc2FycmF5L2luZGV4LmpzPzM1NDIiXSwibmFtZXMiOlsidG9TdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyIiwiY2FsbCJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxXQUFXLEdBQUdBLFFBQWxCOztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCQyxNQUFNQyxPQUFOLElBQWlCLFVBQVVDLEdBQVYsRUFBZTtBQUMvQyxTQUFPTCxTQUFTTSxJQUFULENBQWNELEdBQWQsS0FBc0IsZ0JBQTdCO0FBQ0QsQ0FGRCIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMS4wLjBAaXNhcnJheS9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4xLjEuOEBpZWVlNzU0L2luZGV4LmpzP2U3ODkiXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlYWQiLCJidWZmZXIiLCJvZmZzZXQiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImUiLCJtIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiaSIsImQiLCJzIiwiTmFOIiwiSW5maW5pdHkiLCJNYXRoIiwicG93Iiwid3JpdGUiLCJ2YWx1ZSIsImMiLCJydCIsImFicyIsImlzTmFOIiwiZmxvb3IiLCJsb2ciLCJMTjIiXSwibWFwcGluZ3MiOiI7O0FBQUFBLFFBQVFDLElBQVIsR0FBZSxVQUFVQyxNQUFWLEVBQWtCQyxNQUFsQixFQUEwQkMsSUFBMUIsRUFBZ0NDLElBQWhDLEVBQXNDQyxNQUF0QyxFQUE4QztBQUMzRCxNQUFJQyxDQUFKLEVBQU9DLENBQVA7QUFDQSxNQUFJQyxPQUFPSCxTQUFTLENBQVQsR0FBYUQsSUFBYixHQUFvQixDQUEvQjtBQUNBLE1BQUlLLE9BQU8sQ0FBQyxLQUFLRCxJQUFOLElBQWMsQ0FBekI7QUFDQSxNQUFJRSxRQUFRRCxRQUFRLENBQXBCO0FBQ0EsTUFBSUUsUUFBUSxDQUFDLENBQWI7QUFDQSxNQUFJQyxJQUFJVCxPQUFRRSxTQUFTLENBQWpCLEdBQXNCLENBQTlCO0FBQ0EsTUFBSVEsSUFBSVYsT0FBTyxDQUFDLENBQVIsR0FBWSxDQUFwQjtBQUNBLE1BQUlXLElBQUliLE9BQU9DLFNBQVNVLENBQWhCLENBQVI7O0FBRUFBLE9BQUtDLENBQUw7O0FBRUFQLE1BQUlRLElBQUssQ0FBQyxLQUFNLENBQUNILEtBQVIsSUFBa0IsQ0FBM0I7QUFDQUcsUUFBTyxDQUFDSCxLQUFSO0FBQ0FBLFdBQVNILElBQVQ7QUFDQSxTQUFPRyxRQUFRLENBQWYsRUFBa0JMLElBQUlBLElBQUksR0FBSixHQUFVTCxPQUFPQyxTQUFTVSxDQUFoQixDQUFkLEVBQWtDQSxLQUFLQyxDQUF2QyxFQUEwQ0YsU0FBUyxD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Q0FBSjtBQUNBRCxVQUFJRyxJQUFKO0FBQ0QsS0FIRCxNQUdPLElBQUlILElBQUlJLEtBQUosSUFBYSxDQUFqQixFQUFvQjtBQUN6QkgsVUFBSSxDQUFDYSxRQUFRQyxDQUFSLEdBQVksQ0FBYixJQUFrQkosS0FBS0MsR0FBTCxDQUFTLENBQVQsRUFBWWQsSUFBWixDQUF0QjtBQUNBRSxVQUFJQSxJQUFJSSxLQUFSO0FBQ0QsS0FITSxNQUdBO0FBQ0xILFVBQUlhLFFBQVFILEtBQUtDLEdBQUwsQ0FBUyxDQUFULEVBQVlSLFFBQVEsQ0FBcEIsQ0FBUixHQUFpQ08sS0FBS0MsR0FBTCxDQUFTLENBQVQsRUFBWWQsSUFBWixDQUFyQztBQUNBRSxVQUFJLENBQUo7QUFDRDtBQUNGOztBQUVELFNBQU9GLFFBQVEsQ0FBZixFQUFrQkgsT0FBT0MsU0FBU1UsQ0FBaEIsSUFBcUJMLElBQUksSUFBekIsRUFBK0JLLEtBQUtDLENBQXBDLEVBQXVDTixLQUFLLEdBQTVDLEVBQWlESCxRQUFRLENBQTNFLEVBQThFLENBQUU7O0FBRWhGRSxNQUFLQSxLQUFLRixJQUFOLEdBQWNHLENBQWxCO0FBQ0FDLFVBQVFKLElBQVI7QUFDQSxTQUFPSSxPQUFPLENBQWQsRUFBaUJQLE9BQU9DLFNBQVNVLENBQWhCLElBQXFCTixJQUFJLElBQXpCLEVBQStCTSxLQUFLQyxDQUFwQyxFQUF1Q1AsS0FBSyxHQUE1QyxFQUFpREUsUUFBUSxDQUExRSxFQUE2RSxDQUFFOztBQUUvRVAsU0FBT0MsU0FBU1UsQ0FBVCxHQUFhQyxDQUFwQixLQUEwQkMsSUFBSSxHQUE5QjtBQUNELENBbEREIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4xLjEuOEBpZWVlNzU0L2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction placeHoldersCount(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n}\n\nfunction byteLength(b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64);\n}\n\nfunction toByteArray(b64) {\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n  placeHolders = placeHoldersCount(b64);\n\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = tmp >> 16 & 0xFF;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[tmp << 4 & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    output += lookup[tmp >> 10];\n    output += lookup[tmp >> 4 & 0x3F];\n    output += lookup[tmp << 2 & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('');\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4xLjIuMEBiYXNlNjQtanMvaW5kZXguanM/N2U5OCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImNvZGUiLCJpIiwibGVuIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInBsYWNlSG9sZGVyc0NvdW50IiwiYjY0IiwiRXJyb3IiLCJqIiwibCIsInRtcCIsInBsYWNlSG9sZGVycyIsImFyciIsIkwiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJwdXNoIiwiam9pbiIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUFBLFFBQVFDLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0FELFFBQVFFLFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0FGLFFBQVFHLGFBQVIsR0FBd0JBLGFBQXhCOztBQUVBLElBQUlDLFNBQVMsRUFBYjtBQUNBLElBQUlDLFlBQVksRUFBaEI7QUFDQSxJQUFJQyxNQUFNLE9BQU9DLFVBQVAsS0FBc0IsV0FBdEIsR0FBb0NBLFVBQXBDLEdBQWlEQyxLQUEzRDs7QUFFQSxJQUFJQyxPQUFPLGtFQUFYO0FBQ0EsS0FBSyxJQUFJQyxJQUFJLENBQVIsRUFBV0MsTUFBTUYsS0FBS0csTUFBM0IsRUFBbUNGLElBQUlDLEdBQXZDLEVBQTRDLEVBQUVELENBQTlDLEVBQWlEO0FBQy9DTixTQUFPTSxDQUFQLElBQVlELEtBQUtDLENBQUwsQ0FBWjtBQUNBTCxZQUFVSSxLQUFLSSxVQUFMLENBQWdCSCxDQUFoQixDQUFWLElBQWdDQSxDQUFoQztBQUNEOztBQUVETCxVQUFVLElBQUlRLFVBQUosQ0FBZSxDQUFmLENBQVYsSUFBK0Is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SUFBOUIsR0FBc0N6QixJQUFJd0IsY0FBaEUsQ0FBWDtBQUNEOztBQUVEO0FBQ0EsTUFBSUYsZUFBZSxDQUFuQixFQUFzQjtBQUNwQmIsVUFBTU8sTUFBTWYsTUFBTSxDQUFaLENBQU47QUFDQWtCLGNBQVV6QixPQUFPZSxPQUFPLENBQWQsQ0FBVjtBQUNBVSxjQUFVekIsT0FBUWUsT0FBTyxDQUFSLEdBQWEsSUFBcEIsQ0FBVjtBQUNBVSxjQUFVLElBQVY7QUFDRCxHQUxELE1BS08sSUFBSUcsZUFBZSxDQUFuQixFQUFzQjtBQUMzQmIsVUFBTSxDQUFDTyxNQUFNZixNQUFNLENBQVosS0FBa0IsQ0FBbkIsSUFBeUJlLE1BQU1mLE1BQU0sQ0FBWixDQUEvQjtBQUNBa0IsY0FBVXpCLE9BQU9lLE9BQU8sRUFBZCxDQUFWO0FBQ0FVLGNBQVV6QixPQUFRZSxPQUFPLENBQVIsR0FBYSxJQUFwQixDQUFWO0FBQ0FVLGNBQVV6QixPQUFRZSxPQUFPLENBQVIsR0FBYSxJQUFwQixDQUFWO0FBQ0FVLGNBQVUsR0FBVjtBQUNEOztBQUVESSxRQUFNSCxJQUFOLENBQVdELE1BQVg7O0FBRUEsU0FBT0ksTUFBTUYsSUFBTixDQUFXLEVBQVgsQ0FBUDtBQUNEIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMS4yLjBAYmFzZTY0LWpzL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(15);\nvar ieee754 = __webpack_require__(14);\nvar isArray = __webpack_require__(13);\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {\n        return 42;\n      } };\n    return arr.foo() === 42 && // typed array instances can be augmented\n    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that;\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n    return allocUnsafe(this, arg);\n  }\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    });\n  }\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n  return createBuffer(that, size);\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that;\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nBuffer.compare = function compare(a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0;\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n      case 'hex':\n        return len >>> 1;\n      case 'base64':\n        return base64ToBytes(string).length;\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0;\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1;\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset; // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0;\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return '';\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly40LjkuMUBidWZmZXIvaW5kZXguanM/ZDBkOSJdLCJuYW1lcyI6WyJiYXNlNjQiLCJyZXF1aXJlIiwiaWVlZTc1NCIsImlzQXJyYXkiLCJleHBvcnRzIiwiQnVmZmVyIiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImdsb2JhbCIsInVuZGVmaW5lZCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImFyciIsIlVpbnQ4QXJyYXkiLCJfX3Byb3RvX18iLCJwcm90b3R5cGUiLCJmb28iLCJzdWJhcnJheSIsImJ5dGVMZW5ndGgiLCJlIiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwidmFsdWUiLCJUeXBlRXJyb3IiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0IiwiU3ltYm9sIiwic3BlY2llcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJpIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYXJyYXkiLCJieXRlT2Zmc2V0Iiwib2JqIiwiaXNCdWZmZXIiLCJsZW4iLCJjb3B5IiwiYnVmZmVyIiwiaXNuYW4iLCJ0eXBlIiwiZGF0YSIsInRvU3RyaW5nIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJhIiwieCIsInkiLCJNYXRoIiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJzdGFydCIsImVuZCIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibiIsIm0iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJhcmd1bWVudHMiLCJhcHBseSIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJtYXRjaCIsImpvaW4iLCJ0YXJnZXQiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJpc05hTiIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJjYWxsIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaiIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJvZmZzZXQiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJBcnJheSIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsInB1c2giLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsImZsb29yIiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJyZXBsYWNlIiwidHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiYyIsImhpIiwibG8iLCJ0b0J5dGVBcnJheSIsInNyYyIsImRzdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BOztBQUVBOztBQUVBLElBQUlBLFNBQVMsbUJBQUFDLENBQVEsRUFBUixDQUFiO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxFQUFSLENBQWQ7QUFDQSxJQUFJRSxVQUFVLG1CQUFBRixDQUFRLEVBQVIsQ0FBZDs7QUFFQUcsUUFBUUMsTUFBUixHQUFpQkEsTUFBakI7QUFDQUQsUUFBUUUsVUFBUixHQUFxQkEsVUFBckI7QUFDQUYsUUFBUUcsaUJBQVIsR0FBNEIsRUFBNUI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQUYsT0FBT0csbUJBQVAsR0FBNkJDLE9BQU9ELG1CQUFQLEtBQStCRSxTQUEvQixHQUN6QkQsT0FBT0QsbUJBRGtCLEdBRXpCRyxtQkFGSjs7QUFJQTs7O0FBR0FQLFFBQVFRLFVBQVIsR0FBcUJBLFlBQXJCOztBQUVBLFNBQVNELGlCQUFULEdBQThCO0FBQzVCLE1BQUk7QUFDRixRQUFJRSxNQUFNLElBQUlDLFVBQUosQ0FBZSxDQUFmLENBQVY7QUFDQUQsUUFBSUUsU0FBSixHQUFnQixFQUFDQSxXQUFXRCxXQUFXRSxTQUF2QixFQUFrQ0MsS0FBSyxlQUFZO0FBQUUsZUFBTyxFQUFQO0FBQVcsT0FBaEUsRUFBaEI7QUFDQSxXQUFPSixJQUFJSSxHQUFKLE9BQWMsRUFBZCxJQUFvQjtBQUN2QixXQUFPSixJQUFJSyxRQUFYLEtBQXdCLFVBRHJCLElBQ21DO0FBQ3RDTCxRQUFJSyxRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQkMsVUFBbkIsS0FBa0MsQ0FGdEMsQ0FIRSxDQUtzQztBQUN6QyxHQU5ELENBTUUsT0FBT0MsQ0FBUCxFQUFVO0FBQ1YsV0FBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTUixVQUFULEdBQXVCO0FBQ3JCLFNBQU9QLE9BQU9HLG1CQUFQLEdBQ0gsVUFE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SUFBSW1GLE1BQUosSUFBYzRHLElBQUl6TixNQUFuQixJQUErQjBCLEtBQUs4TCxJQUFJeE4sTUFBNUMsRUFBcUQ7QUFDckR5TixRQUFJL0wsSUFBSW1GLE1BQVIsSUFBa0IyRyxJQUFJOUwsQ0FBSixDQUFsQjtBQUNEO0FBQ0QsU0FBT0EsQ0FBUDtBQUNEOztBQUVELFNBQVNlLEtBQVQsQ0FBZ0JtRCxHQUFoQixFQUFxQjtBQUNuQixTQUFPQSxRQUFRQSxHQUFmLENBRG1CLENBQ0E7QUFDcEIsQyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjQuOS4xQGJ1ZmZlci9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _uploadbg = __webpack_require__(26);\n\nvar _uploadbg2 = _interopRequireDefault(_uploadbg);\n\nvar _Header = __webpack_require__(23);\n\nvar _Header2 = _interopRequireDefault(_Header);\n\nvar _LeftNav = __webpack_require__(24);\n\nvar _LeftNav2 = _interopRequireDefault(_LeftNav);\n\nvar _RightShow = __webpack_require__(25);\n\nvar _RightShow2 = _interopRequireDefault(_RightShow);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nvar Data = {\n\tconfigData: {\n\t\tone: {\n\t\t\tbg: \"\",\n\t\t\ttitle: \"\",\n\t\t\tdes: \"\"\n\t\t},\n\t\tsource: [{\n\t\t\tsubTitle: \"\",\n\t\t\ttextList: [{\n\t\t\t\ttext: '',\n\t\t\t\taudio: ''\n\t\t\t}],\n\t\t\timgList: [{\n\t\t\t\timg: '',\n\t\t\t\taudio: ''\n\t\t\t}]\n\t\t}]\n\t}\n};\nexports.default = {\n\tcomponents: {\n\t\tbg: _uploadbg2.default,\n\t\theadMain: _Header2.default,\n\t\tleftNav: _LeftNav2.default,\n\t\trightShow: _RightShow2.default\n\t},\n\tdata: function data() {\n\t\treturn Data;\n\t},\n\tmethods: {\n\t\tgetName: function getName(msg) {\n\t\t\tthis.configData.one.bg = msg;\n\t\t},\n\t\tonSend: function onSend() {\n\t\t\tvar data = this.configData;\n\t\t\tvar _data = JSON.stringify(data);\n\t\t\tconsole.log(_data);\n\t\t}\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQXBwLnZ1ZT81ZGFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQVVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7OztPQUlBO1VBQ0E7UUFFQTtBQUpBOzthQU1BOztVQUdBO1dBR0E7QUFKQSxJQURBOztTQVFBO1dBTUE7QUFQQSxJQURBO0FBUkE7QUFOQTtBQURBOzs7QUEwQkE7QUFDQTtBQUNBO0FBRUE7QUFMQTt1QkFNQTtTQUNBO0FBQ0E7O2lDQUVBOzRCQUNBO0FBQ0E7NEJBQ0E7bUJBQ0E7OEJBQ0E7ZUFDQTtBQUVBO0FBVEE7QUFWQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuXHQ8ZGl2IGlkPVwiYXBwXCI+XHJcblx0XHQ8aGVhZE1haW4+PC9oZWFkTWFpbj5cclxuXHRcdDxsZWZ0TmF2PjwvbGVmdE5hdj5cclxuXHRcdDxyaWdodFNob3c+PC9yaWdodFNob3c+XHJcblx0XHQ8IS0tIDxiZyB2LW9uOmNob29zZWNvdmVyaW1nPVwiZ2V0TmFtZVwiPjwvYmc+XHJcblx0XHQ8YnV0dG9uIHR5cGU9J2J1dHRvbicgdi1vbjpjbGljaz1cIm9uU2VuZFwiPuaPkOS6pDwvYnV0dG9uPiAtLT5cclxuXHQ8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgYmcgZnJvbSAnLi9jb21wb25lbnRzL3VwbG9hZGJnLnZ1ZSc7XHJcblx0aW1wb3J0IGhlYWRNYWluIGZyb20gJy4vY29tcG9uZW50cy9IZWFkZXIudnVlJztcclxuXHRpbXBvcnQgbGVmdE5hdiBmcm9tICcuL2NvbXBvbmVudHMvTGVmdE5hdi52dWUnO1xyXG5cdGltcG9ydCByaWdodFNob3cgZnJvbSAnLi9jb21wb25lbnRzL1JpZ2h0U2hvdy52dWUnO1xyXG5cdHZhciBEYXRhID0ge1xyXG5cdFx0Y29uZmlnRGF0YTp7XHJcblx0ICAgICAgICBvbmU6e1xyXG5cdFx0XHRcdGJnOlwiXCIsXHJcblx0XHRcdFx0dGl0bGU6XCJcIixcclxuXHRcdFx0XHRkZXM6XCJcIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzb3VyY2U6W3tcclxuXHRcdFx0XHRzdWJUaXRsZTpcIlwiLFxyXG5cdFx0XHRcdHRleHRMaXN0OltcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dGV4dDonJyxcclxuXHRcdFx0XHRcdFx0YXVkaW86JydcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRdLFxyXG5cdFx0XHRcdGltZ0xpc3Q6W1xyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRpbWc6JycsXHRcdFxyXG5cdFx0XHRcdFx0XHRhdWRpbzonJ1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdF1cclxuXHRcdFx0fV1cclxuXHRcdH1cclxuXHR9O1xyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdGNvbXBvbmVudHM6IHtcclxuXHRcdFx0YmcsXHJcblx0XHRcdGhlYWRNYWluLFxyXG5cdFx0XHRsZWZ0TmF2LFxyXG5cdFx0XHRyaWdodFNob3dcclxuXHRcdH0sXHJcblx0XHRkYXRhOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBEYXRhO1xyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6e1xyXG5cdFx0XHRnZXROYW1lOiBmdW5jdGlvbiAobXNnKSB7XHJcblx0XHRcdFx0dGhpcy5jb25maWdEYXRhLm9uZS5iZyA9IG1zZztcclxuXHRcdFx0fSxcclxuXHRcdFx0b25TZW5kOmZ1bmN0aW9uKCl7XHJcblx0ICAgIFx0XHR2YXIgZGF0YSA9IHRoaXMuY29uZmlnRGF0YTtcclxuXHQgICAgXHRcdHZhciBfZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG5cdCAgICBcdFx0Y29uc29sZS5sb2coX2RhdGEpXHJcblx0ICAgIFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuXHQqe1xyXG5cdFx0bWFyZ2luOiAwO1xyXG5cdFx0cGFkZGluZzogMFxyXG5cdH1cclxuXHRodG1sLGJvZHl7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGhlaWdodDogMTAwJVxyXG5cdH1cclxuXHQjYXBwe1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmFmYWZhO1xyXG5cdH1cclxuPC9zdHlsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gQXBwLnZ1ZT8wYTU2MjhjZCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n\tdata: function data() {\n\t\treturn {\n\t\t\tlogo: 'assets/image/logo.png',\n\t\t\tname: '123123123123',\n\t\t\tuserInfo: {\n\t\t\t\tuserName: 'pany',\n\t\t\t\tuserAva: 'assets/image/user1.jpg'\n\t\t\t}\n\t\t};\n\t},\n\tmethods: {}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vSGVhZGVyLnZ1ZT9kZDZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWVBOzs7dUJBRUE7O1NBRUE7U0FDQTs7Y0FFQTthQUdBO0FBSkE7QUFIQTtBQVFBO1VBR0E7QUFiQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuXHQ8aGVhZGVyPlxyXG5cdFx0PGRpdiBjbGFzcz1cImxvZ29cIj5cclxuXHRcdFx0PGltZyB2LWJpbmQ6c3JjPVwibG9nb1wiIGFsdD1cIlwiPlxyXG5cdFx0PC9kaXY+XHJcblx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPnt7bmFtZX19PC9kaXY+XHJcblx0XHQ8ZGl2IGNsYXNzPVwidXNlckluZm9cIj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInVzZXJBdmFcIj5cclxuXHRcdFx0XHQ8aW1nIHYtYmluZDpzcmM9XCJ1c2VySW5mby51c2VyQXZhXCIgYWx0PVwiXCI+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwidXNlck5hbWVcIj57e3VzZXJJbmZvLnVzZXJOYW1lfX08L2Rpdj5cclxuXHRcdDwvZGl2PlxyXG5cdDwvaGVhZGVyPlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdGRhdGE6ZnVuY3Rpb24oKXtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRsb2dvOiAnYXNzZXRzL2ltYWdlL2xvZ28ucG5nJyxcclxuXHRcdFx0XHRuYW1lOicxMjMxMjMxMjMxMjMnLFxyXG5cdFx0XHRcdHVzZXJJbmZvOntcclxuXHRcdFx0XHRcdHVzZXJOYW1lOidwYW55JyxcclxuXHRcdFx0XHRcdHVzZXJBdmE6ICdhc3NldHMvaW1hZ2UvdXNlcjEuanBnJ1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOntcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZSBzdHlsZSBsYW5nPVwic2Fzc1wiIHNjb3BlZD5cclxuXHRoZWFkZXJ7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGhlaWdodDogMTAwcHg7XHJcblx0XHRiYWNrZ3JvdW5kOiAjZmFmYWZhO1xyXG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcclxuXHRcdHBhZGRpbmc6IDEwcHggMDtcclxuXHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcclxuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblx0XHRib3JkZXItYm90dG9tOiAxcHggIzMzMyBzb2xpZDtcclxuXHR9XHJcblx0LmxvZ297XHJcblx0XHR3aWR0aDogODBweDtcclxuXHRcdGhlaWdodDogMTAwJTtcclxuXHRcdGJhY2tncm91bmQ6IHJlZDtcclxuXHRcdHBhZGRpbmc6IDAgNXB4O1xyXG4gICAgXHRib3JkZXItcmlnaHQ6IDFweCAjMzMzIHNvbGlkO1xyXG5cdFx0aW1ne1xyXG5cdFx0XHR3aWR0aDogMTAwJTtcclxuXHRcdFx0aGVpZ2h0OiAxMDAlXHJcblx0XHR9XHJcblx0fVxyXG5cdC5uYW1le1xyXG5cdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDgwcHggLSAyMDBweCk7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRiYWNrZ3JvdW5kOiBibHVlO1xyXG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcclxuXHRcdHBhZGRpbmc6IDIwcHg7XHJcblx0XHRsaW5lLWhlaWdodDogNDBweDtcclxuXHQgICAgZm9udC1zaXplOiAyNHB4O1xyXG5cdCAgICBjb2xvcjogIzMzMztcclxuXHR9XHJcblx0LnVzZXJJbmZve1xyXG5cdFx0d2lkdGg6IDIwMHB4O1xyXG5cdFx0aGVpZ2h0OiAxMDAlO1xyXG5cdFx0YmFja2dyb3VuZDogeWVsbG93O1xyXG5cdFx0LnVzZXJBdmF7XHJcblx0XHRcdHdpZHRoOiA4MHB4O1xyXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRcdGZsb2F0OiByaWdodDtcclxuXHRcdFx0aW1ne1xyXG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0XHRcdGhlaWdodDogMTAwJTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0LnVzZXJOYW1le1xyXG5cdFx0XHR3aWR0aDogMTIwcHg7XHJcblx0XHRcdGhlaWdodDogMTAwJTtcclxuXHRcdFx0bGluZS1oZWlnaHQ6IDgwcHg7XHJcblx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHRcdFx0Zm9udC1zaXplOiAyNHB4O1xyXG5cdFx0XHRjb2xvcjogIzMzM1xyXG5cdFx0fVxyXG5cdH1cclxuPC9zdHlsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gSGVhZGVyLnZ1ZT9lNzc3MGI5MCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n\tdata: function data() {\n\t\treturn {\n\t\t\tnavList: [{ navList_1: '导航一' }, { navList_1: '导航二' }, { navList_1: '导航三' }, { navList_1: '导航四' }]\n\t\t};\n\t},\n\tmethods: {}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vTGVmdE5hdi52dWU/OTViZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVFBOzs7dUJBRUE7O1lBRUEsY0FDQSxzQkFDQSxzQkFDQSxzQkFHQTtBQVBBO0FBUUE7VUFHQTtBQWJBIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG5cdDxzZWN0aW9uPlxyXG5cdFx0PHVsIGNsYXNzPVwibGVmdE5hdlwiPlxyXG5cdFx0XHQ8bGkgdi1mb3I9XCJpdGVtIGluIG5hdkxpc3RcIj57e2l0ZW0ubmF2TGlzdF8xfX08L2xpPlxyXG5cdFx0PC91bD5cclxuXHQ8L3NlY3Rpb24+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0ZGF0YTpmdW5jdGlvbigpe1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdG5hdkxpc3Q6W1xyXG5cdFx0XHRcdFx0e25hdkxpc3RfMTogJ+WvvOiIquS4gCd9LFxyXG5cdFx0XHRcdFx0e25hdkxpc3RfMTogJ+WvvOiIquS6jCd9LFxyXG5cdFx0XHRcdFx0e25hdkxpc3RfMTogJ+WvvOiIquS4iSd9LFxyXG5cdFx0XHRcdFx0e25hdkxpc3RfMTogJ+WvvOiIquWbmyd9XHJcblx0XHRcdFx0XVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0bWV0aG9kczp7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgc3R5bGUgbGFuZz1cInNhc3NcIiBzY29wZWQ+XHJcblx0c2VjdGlvbntcclxuXHRcdHdpZHRoOiAyNTBweDtcclxuXHRcdGhlaWdodDogY2FsYygxMDAlIC0gMTIwcHgpO1xyXG5cdFx0ZmxvYXQ6IGxlZnQ7XHJcblx0fVxyXG5cdC5sZWZ0TmF2e1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRiYWNrZ3JvdW5kOiBncmVlbjtcclxuXHRcdGxpe1xyXG5cdFx0XHR3aWR0aDogMTAwJTtcclxuXHRcdFx0bGluZS1oZWlnaHQ6IDQ1cHg7XHJcblx0XHRcdGJhY2tncm91bmQ6ICNmYWZhZmE7XHJcblx0XHRcdG1hcmdpbjogMjBweCAwO1xyXG5cdFx0fVxyXG5cdH1cclxuPC9zdHlsZT5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gTGVmdE5hdi52dWU/Njk2YTYxMjMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n\tdata: function data() {\n\t\treturn {\n\t\t\tfileUrl: '',\n\t\t\tfileName: ''\n\t\t};\n\t},\n\tmethods: {\n\t\tchoosecoverimg: function choosecoverimg(e) {\n\t\t\tvar _this = this;\n\n\t\t\tvar file = e.target.files[0];\n\t\t\tvar data = new FormData();\n\t\t\tdata.append('file', file);\n\n\t\t\tthis.$http.post('http://172.16.0.107:9011/pages/159/file', data).then(function (res) {\n\t\t\t\tconsole.log(res);\n\t\t\t\t_this.fileUrl = 'http://172.16.0.107:9011/pages/159/' + res.data.data.key;\n\t\t\t}, function (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t});\n\t\t\tthis.fileName = e.target.files[0].name;\n\t\t\tthis.$emit('choosecoverimg', this.fileName);\n\t\t}\n\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXBsb2FkYmcudnVlP2I1NjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFXQTs7O3VCQUVBOztZQUVBO2FBRUE7QUFIQTtBQUlBOzs7QUFFQTs7NkJBQ0E7a0JBQ0E7dUJBRUE7OzhEQUNBLDBCQUNBO2dCQUNBOzBFQUNBO3FCQUNBO2dCQUNBO0FBQ0E7cUNBQ0E7cUNBQ0E7QUFHQTs7QUFqQkE7QUFQQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuXHQ8ZGl2PlxyXG5cdFx0PHNwYW4gY2xhc3M9XCJmb3JGaWxlXCI+XHJcblx0XHRcdDxwPnt7ZmlsZU5hbWV9fTwvcD5cclxuXHRcdFx0PGlucHV0IHR5cGU9XCJmaWxlXCIgbmFtZT0nYmcnIHYtb246Y2hhbmdlPVwiY2hvb3NlY292ZXJpbWdcIj5cclxuXHRcdDwvc3Bhbj5cclxuXHRcdDxkaXYgY2xhc3M9XCJzaG93SW1nXCI+PGltZyBpZD1cInNob3dJbWdzXCIgdi1iaW5kOnNyYz1cImZpbGVVcmxcIiAvPjwvZGl2PlxyXG5cdFx0PGlucHV0IHR5cGU9XCJoaWRkZW5cIiBjbGFzcz1cImhpZGVcIiB2LW1vZGVsPVwiZmlsZVVybFwiIC8+XHJcblx0PC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0ZGF0YTpmdW5jdGlvbigpe1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGZpbGVVcmw6ICcnLFxyXG5cdFx0XHRcdGZpbGVOYW1lOicnXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOntcclxuXHRcdFx0Y2hvb3NlY292ZXJpbWc6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0dmFyIGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcclxuXHRcdFx0XHR2YXIgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG5cdFx0XHRcdGRhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7ICBcclxuXHJcblx0XHRcdFx0dGhpcy4kaHR0cC5wb3N0KCdodHRwOi8vMTcyLjE2LjAuMTA3OjkwMTEvcGFnZXMvMTU5L2ZpbGUnLCBkYXRhKVxyXG5cdFx0XHRcdC50aGVuKChyZXMpPT57XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhyZXMpXHJcblx0XHRcdFx0XHR0aGlzLmZpbGVVcmwgPSAnaHR0cDovLzE3Mi4xNi4wLjEwNzo5MDExL3BhZ2VzLzE1OS8nK3Jlcy5kYXRhLmRhdGEua2V5O1xyXG5cdFx0XHRcdH0sIChlcnIpPT57XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhlcnIpXHJcblx0XHRcdFx0fSk7XHRcdFx0ICBcclxuXHRcdFx0XHR0aGlzLmZpbGVOYW1lID0gZS50YXJnZXQuZmlsZXNbMF0ubmFtZTtcclxuXHRcdFx0XHR0aGlzLiRlbWl0KCdjaG9vc2Vjb3ZlcmltZycsdGhpcy5maWxlTmFtZSlcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5cdC5zaG93SW1ne1xyXG5cdFx0d2lkdGg6IDI1MHB4O1xyXG5cdFx0aGVpZ2h0OiAyNTBweDtcclxuXHR9XHJcblx0LnNob3dJbWc+aW1ne1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCVcclxuXHR9XHJcbjwvc3R5bGU+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHVwbG9hZGJnLnZ1ZT9kOGJlYjJlYyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles(parentId, list) {\n  var styles = [];\n  var newStyles = {};\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n  return styles;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanM/YTA4MiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibGlzdFRvU3R5bGVzIiwicGFyZW50SWQiLCJsaXN0Iiwic3R5bGVzIiwibmV3U3R5bGVzIiwiaSIsImxlbmd0aCIsIml0ZW0iLCJpZCIsImNzcyIsIm1lZGlhIiwic291cmNlTWFwIiwicGFydCIsInB1c2giLCJwYXJ0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUlBQSxPQUFPQyxPQUFQLEdBQWlCLFNBQVNDLFlBQVQsQ0FBdUJDLFFBQXZCLEVBQWlDQyxJQUFqQyxFQUF1QztBQUN0RCxNQUFJQyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxZQUFZLEVBQWhCO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILEtBQUtJLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztBQUNwQyxRQUFJRSxPQUFPTCxLQUFLRyxDQUFMLENBQVg7QUFDQSxRQUFJRyxLQUFLRCxLQUFLLENBQUwsQ0FBVDtBQUNBLFFBQUlFLE1BQU1GLEtBQUssQ0FBTCxDQUFWO0FBQ0EsUUFBSUcsUUFBUUgsS0FBSyxDQUFMLENBQVo7QUFDQSxRQUFJSSxZQUFZSixLQUFLLENBQUwsQ0FBaEI7QUFDQSxRQUFJSyxPQUFPO0FBQ1RKLFVBQUlQLFdBQVcsR0FBWCxHQUFpQkksQ0FEWjtBQUVUSSxXQUFLQSxHQUZJO0FBR1RDLGFBQU9BLEtBSEU7QUFJVEMsaUJBQVdBO0FBSkYsS0FBWDtBQU1BLFFBQUksQ0FBQ1AsVUFBVUksRUFBVixDQUFMLEVBQW9CO0FBQ2xCTCxhQUFPVSxJQUFQLENBQVlULFVBQVVJLEVBQVYsSUFBZ0IsRUFBRUEsSUFBSUEsRUFBTixFQUFVTSxPQUFPLENBQUNGLElBQUQsQ0FBakIsRUFBNUI7QUFDRCxLQUZELE1BRU87QUFDTFIsZ0JBQVVJLEVBQVYsRUFBY00sS0FBZCxDQUFvQkQsSUFBcEIsQ0FBeUJELElBQXpCO0FBQ0Q7QUFDRjtBQUNELFNBQU9ULE1BQVA7QUFDRCxDQXRCRCIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlLWxvYWRlci9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _vue = __webpack_require__(5);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _vueResource = __webpack_require__(4);\n\nvar _vueResource2 = _interopRequireDefault(_vueResource);\n\nvar _App = __webpack_require__(6);\n\nvar _App2 = _interopRequireDefault(_App);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_vue2.default.use(_vueResource2.default); //使用插件方式\n\nnew _vue2.default({\n\tel: '#app',\n\trender: function render(h) {\n\t\treturn h(_App2.default);\n\t}\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJ1c2UiLCJlbCIsInJlbmRlciIsImgiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxjQUFJQSxHQUFKLHdCLENBQWdCOztBQUVoQixrQkFBUTtBQUNQQyxLQUFJLE1BREc7QUFFUEMsU0FBUTtBQUFBLFNBQUtDLGdCQUFMO0FBQUE7QUFGRCxDQUFSIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xyXG5pbXBvcnQgVnVlUmVzIGZyb20gJ3Z1ZS1yZXNvdXJjZSc7XHJcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJztcclxuXHJcblZ1ZS51c2UoVnVlUmVzKTsvL+S9v+eUqOaPkuS7tuaWueW8j1xyXG5cclxubmV3IFZ1ZSh7XHJcblx0ZWw6ICcjYXBwJyxcclxuXHRyZW5kZXI6IGggPT4gaChBcHApXHJcbn0pXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(36)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(18),\n  /* template */\n  __webpack_require__(31),\n  /* scopeId */\n  \"data-v-77c6181b\",\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"E:\\\\Demo\\\\Vue-Edit\\\\webpack\\\\src\\\\components\\\\Header.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] Header.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-77c6181b\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-77c6181b\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXIudnVlP2U1ZTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQWdNOztBQUVoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsaURBQWlELElBQUk7QUFDcEksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlcj97XFxcImlkXFxcIjpcXFwiZGF0YS12LTc3YzYxODFiXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0hlYWRlci52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzdjNjE4MWJcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi03N2M2MTgxYlwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRTpcXFxcRGVtb1xcXFxWdWUtRWRpdFxcXFx3ZWJwYWNrXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXEhlYWRlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBIZWFkZXIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTc3YzYxODFiXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNzdjNjE4MWJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvSGVhZGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(35)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(19),\n  /* template */\n  __webpack_require__(30),\n  /* scopeId */\n  \"data-v-5e1ce17e\",\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"E:\\\\Demo\\\\Vue-Edit\\\\webpack\\\\src\\\\components\\\\LeftNav.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] LeftNav.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-5e1ce17e\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-5e1ce17e\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZT9jMzJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUFnTTs7QUFFaE07QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlEQUFpRCxJQUFJO0FBQ3BJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXI/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01ZTFjZTE3ZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hc2Fzcy1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9MZWZ0TmF2LnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9MZWZ0TmF2LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWUxY2UxN2VcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vTGVmdE5hdi52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgXCJkYXRhLXYtNWUxY2UxN2VcIixcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkU6XFxcXERlbW9cXFxcVnVlLUVkaXRcXFxcd2VicGFja1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxMZWZ0TmF2LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIExlZnROYXYudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTVlMWNlMTdlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNWUxY2UxN2VcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvTGVmdE5hdi52dWVcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(32)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  null,\n  /* template */\n  __webpack_require__(27),\n  /* scopeId */\n  \"data-v-005ef7ca\",\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"E:\\\\Demo\\\\Vue-Edit\\\\webpack\\\\src\\\\components\\\\RightShow.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] RightShow.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-005ef7ca\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-005ef7ca\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SaWdodFNob3cudnVlPzhiZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQWdNOztBQUVoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsaURBQWlELElBQUk7QUFDcEksbUNBQW1DOztBQUVuQztBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlcj97XFxcImlkXFxcIjpcXFwiZGF0YS12LTAwNWVmN2NhXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSFzYXNzLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1JpZ2h0U2hvdy52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgbnVsbCxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMDA1ZWY3Y2FcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vUmlnaHRTaG93LnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBcImRhdGEtdi0wMDVlZjdjYVwiLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRTpcXFxcRGVtb1xcXFxWdWUtRWRpdFxcXFx3ZWJwYWNrXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXFJpZ2h0U2hvdy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBSaWdodFNob3cudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTAwNWVmN2NhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMDA1ZWY3Y2FcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvUmlnaHRTaG93LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(33)\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(20),\n  /* template */\n  __webpack_require__(28),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"E:\\\\Demo\\\\Vue-Edit\\\\webpack\\\\src\\\\components\\\\uploadbg.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] uploadbg.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-10739574\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-10739574\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy91cGxvYWRiZy52dWU/MDgzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSxzQkFBaU07O0FBRWpNO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpREFBaUQsSUFBSTtBQUNwSSxtQ0FBbUM7O0FBRW5DO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTA3Mzk1NzRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3VwbG9hZGJnLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi91cGxvYWRiZy52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XFxcImlkXFxcIjpcXFwiZGF0YS12LTEwNzM5NTc0XFxcIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3VwbG9hZGJnLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiRTpcXFxcRGVtb1xcXFxWdWUtRWRpdFxcXFx3ZWJwYWNrXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXHVwbG9hZGJnLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHVwbG9hZGJnLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xMDczOTU3NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTEwNzM5NTc0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3VwbG9hZGJnLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('section', [_c('div', {\n    staticClass: \"rightShow\"\n  })])\n}]}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-005ef7ca\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SaWdodFNob3cudnVlP2VkNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBLENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF92bS5fbSgwKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzZWN0aW9uJywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicmlnaHRTaG93XCJcbiAgfSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTAwNWVmN2NhXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLmpzP3tcImlkXCI6XCJkYXRhLXYtMDA1ZWY3Y2FcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1JpZ2h0U2hvdy52dWVcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('span', {\n    staticClass: \"forFile\"\n  }, [_c('p', [_vm._v(_vm._s(_vm.fileName))]), _vm._v(\" \"), _c('input', {\n    attrs: {\n      \"type\": \"file\",\n      \"name\": \"bg\"\n    },\n    on: {\n      \"change\": _vm.choosecoverimg\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"showImg\"\n  }, [_c('img', {\n    attrs: {\n      \"id\": \"showImgs\",\n      \"src\": _vm.fileUrl\n    }\n  })]), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.fileUrl),\n      expression: \"fileUrl\"\n    }],\n    staticClass: \"hide\",\n    attrs: {\n      \"type\": \"hidden\"\n    },\n    domProps: {\n      \"value\": (_vm.fileUrl)\n    },\n    on: {\n      \"input\": function($event) {\n        if ($event.target.composing) { return; }\n        _vm.fileUrl = $event.target.value\n      }\n    }\n  })])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-10739574\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy91cGxvYWRiZy52dWU/NWI1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCBbX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZm9yRmlsZVwiXG4gIH0sIFtfYygncCcsIFtfdm0uX3YoX3ZtLl9zKF92bS5maWxlTmFtZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCdpbnB1dCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwiZmlsZVwiLFxuICAgICAgXCJuYW1lXCI6IFwiYmdcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2hhbmdlXCI6IF92bS5jaG9vc2Vjb3ZlcmltZ1xuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJzaG93SW1nXCJcbiAgfSwgW19jKCdpbWcnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJzaG93SW1nc1wiLFxuICAgICAgXCJzcmNcIjogX3ZtLmZpbGVVcmxcbiAgICB9XG4gIH0pXSksIF92bS5fdihcIiBcIiksIF9jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5maWxlVXJsKSxcbiAgICAgIGV4cHJlc3Npb246IFwiZmlsZVVybFwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiaGlkZVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS5maWxlVXJsKVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLmZpbGVVcmwgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTEwNzM5NTc0XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLmpzP3tcImlkXCI6XCJkYXRhLXYtMTA3Mzk1NzRcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL3VwbG9hZGJnLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [_c('headMain'), _vm._v(\" \"), _c('leftNav'), _vm._v(\" \"), _c('rightShow')], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-5b7a3b96\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8zNTJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJhcHBcIlxuICAgIH1cbiAgfSwgW19jKCdoZWFkTWFpbicpLCBfdm0uX3YoXCIgXCIpLCBfYygnbGVmdE5hdicpLCBfdm0uX3YoXCIgXCIpLCBfYygncmlnaHRTaG93JyldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi01YjdhM2I5NlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci5qcz97XCJpZFwiOlwiZGF0YS12LTViN2EzYjk2XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('section', [_c('ul', {\n    staticClass: \"leftNav\"\n  }, _vm._l((_vm.navList), function(item) {\n    return _c('li', [_vm._v(_vm._s(item.navList_1))])\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-5e1ce17e\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZT83MDdhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NlY3Rpb24nLCBbX2MoJ3VsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxlZnROYXZcIlxuICB9LCBfdm0uX2woKF92bS5uYXZMaXN0KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnbGknLCBbX3ZtLl92KF92bS5fcyhpdGVtLm5hdkxpc3RfMSkpXSlcbiAgfSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNWUxY2UxN2VcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/e1wiaWRcIjpcImRhdGEtdi01ZTFjZTE3ZVwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvTGVmdE5hdi52dWVcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('header', [_c('div', {\n    staticClass: \"logo\"\n  }, [_c('img', {\n    attrs: {\n      \"src\": _vm.logo,\n      \"alt\": \"\"\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"name\"\n  }, [_vm._v(_vm._s(_vm.name))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"userInfo\"\n  }, [_c('div', {\n    staticClass: \"userAva\"\n  }, [_c('img', {\n    attrs: {\n      \"src\": _vm.userInfo.userAva,\n      \"alt\": \"\"\n    }\n  })]), _vm._v(\" \"), _c('div', {\n    staticClass: \"userName\"\n  }, [_vm._v(_vm._s(_vm.userInfo.userName))])])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-77c6181b\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXIudnVlP2EzM2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnaGVhZGVyJywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibG9nb1wiXG4gIH0sIFtfYygnaW1nJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInNyY1wiOiBfdm0ubG9nbyxcbiAgICAgIFwiYWx0XCI6IFwiXCJcbiAgICB9XG4gIH0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmFtZVwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5uYW1lKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ1c2VySW5mb1wiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInVzZXJBdmFcIlxuICB9LCBbX2MoJ2ltZycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzcmNcIjogX3ZtLnVzZXJJbmZvLnVzZXJBdmEsXG4gICAgICBcImFsdFwiOiBcIlwiXG4gICAgfVxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInVzZXJOYW1lXCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLnVzZXJJbmZvLnVzZXJOYW1lKSldKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNzdjNjE4MWJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/e1wiaWRcIjpcImRhdGEtdi03N2M2MTgxYlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvSGVhZGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"82c5b6f4\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-005ef7ca\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/.6.0.3@sass-loader/lib/loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./RightShow.vue\", function() {\n     var newContent = require(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-005ef7ca\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/.6.0.3@sass-loader/lib/loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./RightShow.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SaWdodFNob3cudnVlPzQ4ODQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxtQ0FBNE07QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSxxRUFBcUU7QUFDM00sK0lBQStJLHFFQUFxRTtBQUNwTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy8uMC4yOC4wQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTAwNWVmN2NhXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvLjYuMC4zQHNhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9SaWdodFNob3cudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI4MmM1YjZmNFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wMDVlZjdjYVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzLy42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vUmlnaHRTaG93LnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wMDVlZjdjYVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzLy42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vUmlnaHRTaG93LnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyIS4vfi8uMC4yOC4wQGNzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz97XCJpZFwiOlwiZGF0YS12LTAwNWVmN2NhXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi8uNi4wLjNAc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL1JpZ2h0U2hvdy52dWVcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(8);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"7c4419ba\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-10739574\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./uploadbg.vue\", function() {\n     var newContent = require(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-10739574\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./uploadbg.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy91cGxvYWRiZy52dWU/YmRhYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG1DQUE2TTtBQUM3TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLHNFQUFzRTtBQUM1TSwrSUFBK0ksc0VBQXNFO0FBQ3JOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTA3Mzk1NzRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3VwbG9hZGJnLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiN2M0NDE5YmFcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTA3Mzk1NzRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3VwbG9hZGJnLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0xMDczOTU3NFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vdXBsb2FkYmcudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+Ly4wLjI4LjBAY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP3tcImlkXCI6XCJkYXRhLXYtMTA3Mzk1NzRcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdXBsb2FkYmcudnVlXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"260abff8\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../node_modules/.0.28.0@css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-5b7a3b96\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue\", function() {\n     var newContent = require(\"!!../node_modules/.0.28.0@css-loader/index.js?sourceMap!../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-5b7a3b96\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./App.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT84NmMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsbUNBQXVNO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0ksc0VBQXNFO0FBQ3RNLHlJQUF5SSxzRUFBc0U7QUFDL007QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01YjdhM2I5NlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMjYwYWJmZjhcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWI3YTNiOTZcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzLy4wLjI4LjBAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWI3YTNiOTZcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL34vdnVlLXN0eWxlLWxvYWRlciEuL34vLjAuMjguMEBjc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1wiaWRcIjpcImRhdGEtdi01YjdhM2I5NlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(10);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"2bd20120\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-5e1ce17e\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/.6.0.3@sass-loader/lib/loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./LeftNav.vue\", function() {\n     var newContent = require(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-5e1ce17e\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/.6.0.3@sass-loader/lib/loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./LeftNav.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZT9iZGFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQTRNO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0kscUVBQXFFO0FBQzNNLCtJQUErSSxxRUFBcUU7QUFDcE47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01ZTFjZTE3ZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzLy42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vTGVmdE5hdi52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjJiZDIwMTIwXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy8uMC4yOC4wQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTVlMWNlMTdlXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvLjYuMC4zQHNhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9MZWZ0TmF2LnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01ZTFjZTE3ZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzLy42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vTGVmdE5hdi52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL34vdnVlLXN0eWxlLWxvYWRlciEuL34vLjAuMjguMEBjc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1wiaWRcIjpcImRhdGEtdi01ZTFjZTE3ZVwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vLjYuMC4zQHNhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy9MZWZ0TmF2LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(11);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"4c3ff95c\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-77c6181b\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/.6.0.3@sass-loader/lib/loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Header.vue\", function() {\n     var newContent = require(\"!!../../node_modules/.0.28.0@css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-rewriter.js?{\\\"id\\\":\\\"data-v-77c6181b\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/.6.0.3@sass-loader/lib/loader.js!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Header.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXIudnVlP2QwYzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBNE07QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSxxRUFBcUU7QUFDM00sK0lBQStJLHFFQUFxRTtBQUNwTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy8uMC4yOC4wQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTc3YzYxODFiXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvLjYuMC4zQHNhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9IZWFkZXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI0YzNmZjk1Y1wiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03N2M2MTgxYlxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzLy42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLjAuMjguMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03N2M2MTgxYlxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzLy42LjAuM0BzYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vSGVhZGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvfi92dWUtc3R5bGUtbG9hZGVyIS4vfi8uMC4yOC4wQGNzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz97XCJpZFwiOlwiZGF0YS12LTc3YzYxODFiXCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi8uNi4wLjNAc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9jb21wb25lbnRzL0hlYWRlci52dWVcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ290IChpZ25vcmVkKT8xZWMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZ290IChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);